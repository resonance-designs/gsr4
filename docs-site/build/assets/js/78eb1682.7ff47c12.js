"use strict";(self.webpackChunktlbx_docs=self.webpackChunktlbx_docs||[]).push([[304],{4866(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"developer/audio-engine","title":"Audio Engine","description":"The GrainRust audio engine is a hybrid system combining imperative loop-based processing with functional DSP graphs.","source":"@site/docs/developer/audio-engine.md","sourceDirName":"developer","slug":"/developer/audio-engine","permalink":"/docs/developer/audio-engine","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Audio Engine","sidebar_position":3},"sidebar":"devSidebar","previous":{"title":"Architecture Overview","permalink":"/docs/developer/architecture"},"next":{"title":"UI System","permalink":"/docs/developer/ui-system"}}');var r=s(4848),t=s(8453);const o={title:"Audio Engine",sidebar_position:3},d="Audio Engine",c={},l=[{value:"Core Processing Loop",id:"core-processing-loop",level:2},{value:"Step-by-Step Processing",id:"step-by-step-processing",level:3},{value:"Engines and Devices",id:"engines-and-devices",level:2},{value:"Engines (The Sound Sources)",id:"engines-the-sound-sources",level:3},{value:"Devices (The Effects)",id:"devices-the-effects",level:3},{value:"DSP with <code>fundsp</code>",id:"dsp-with-fundsp",level:2},{value:"Thread Safety &amp; Performance",id:"thread-safety--performance",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"audio-engine",children:"Audio Engine"})}),"\n",(0,r.jsx)(n.p,{children:"The GrainRust audio engine is a hybrid system combining imperative loop-based processing with functional DSP graphs."}),"\n",(0,r.jsx)(n.h2,{id:"core-processing-loop",children:"Core Processing Loop"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"process"})," function in ",(0,r.jsx)(n.code,{children:"src/lib.rs"})," is the heartbeat of the application. It executes every time the host (DAW or Standalone driver) requests a new buffer of audio."]}),"\n",(0,r.jsx)(n.h3,{id:"step-by-step-processing",children:"Step-by-Step Processing"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clock Update"}),": Updates the master phase and step index (0-15) based on the current tempo and sample rate."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recording"}),": If a track is in recording mode, input audio is written directly into the track's sample buffer."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Track Iteration"}),": Processes each of the 4 tracks sequentially:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Engine Dispatch"}),": Calls the specific processing function for the loaded engine (e.g., ",(0,r.jsx)(n.code,{children:"process_animate"}),", ",(0,r.jsx)(n.code,{children:"process_syndrm"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Internal Buffering"}),": Each track renders into a local ",(0,r.jsx)(n.code,{children:"track_buffer"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Master Chain"}),": Sums the 4 track buffers and applies the master compressor and filter."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Metering"}),": Calculates the peak level for each track and the master output, storing them in atomic variables for the UI."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"engines-and-devices",children:"Engines and Devices"}),"\n",(0,r.jsx)(n.h3,{id:"engines-the-sound-sources",children:"Engines (The Sound Sources)"}),"\n",(0,r.jsx)(n.p,{children:"Engines are responsible for generating or manipulating raw audio data."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tape-Deck"}),": A high-fidelity playback engine with support for variable speed, reverse, and looping."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Granulator"}),": A multi-voice granular engine that shreds audio into tiny grains."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SynDRM"}),": A percussion-focused synthesizer engine."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Void Seed"}),": An experimental noise/drone engine."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"devices-the-effects",children:"Devices (The Effects)"}),"\n",(0,r.jsx)(n.p,{children:'Each track features a dedicated effect slot called a "Device".'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Silk"}),": A lush, ethereal reverb/diffuser."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reflect"}),": A high-density delay and space modeler."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Texture"}),": A multi-stage distortion and saturation module."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"G-8"}),": A performance-oriented gate and chopper."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"dsp-with-fundsp",children:["DSP with ",(0,r.jsx)(n.code,{children:"fundsp"})]}),"\n",(0,r.jsxs)(n.p,{children:["GrainRust uses ",(0,r.jsx)(n.code,{children:"fundsp"})," for complex signal paths."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Static Graphs"}),": Devices like ",(0,r.jsx)(n.code,{children:"Silk"})," are defined as ",(0,r.jsx)(n.code,{children:"fundsp"})," graphs."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Parameters"}),": Parameters are passed into the graphs using ",(0,r.jsx)(n.code,{children:"An"})," (Audio Node) wrappers, allowing for smooth parameter modulation."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"thread-safety--performance",children:"Thread Safety & Performance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Allocations"}),": The audio thread NEVER allocates memory. All buffers (like ",(0,r.jsx)(n.code,{children:"track_buffer"}),") are pre-allocated during initialization or when the sample rate changes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lock-Free"}),": While ",(0,r.jsx)(n.code,{children:"Arc<Mutex<T>>"})," is used for sharing large data (like sample libraries), the audio thread uses ",(0,r.jsx)(n.code,{children:".try_lock()"}),". If a lock cannot be acquired immediately, the thread skips processing that frame or uses a cached value to avoid blocking."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453(e,n,s){s.d(n,{R:()=>o,x:()=>d});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);