/**
 * TLBX-1 - A Rust-based audio toolbox.
 * Copyright (C) 2026 Richard Bakos @ Resonance Designs.
 * Author: Richard Bakos <info@resonancedesigns.dev>
 * Website: https://resonancedesigns.dev
 * Version: 0.1.26
 * Component: Core Logic
 */

use nih_plug::prelude::*;
use cpal::traits::{DeviceTrait, HostTrait};
use parking_lot::Mutex;
use slint::{
    Image, LogicalPosition, ModelRc, PhysicalSize, Rgba8Pixel, SharedPixelBuffer, SharedString,
    VecModel,
};
use slint::platform::{
    self, Platform, PlatformError, PointerEventButton, WindowAdapter, WindowEvent,
};
use slint::platform::software_renderer::{
    MinimalSoftwareWindow, PremultipliedRgbaColor, RepaintBufferType,
};
use baseview::{
    Event as BaseEvent, EventStatus as BaseEventStatus, Window as BaseWindow, WindowHandle,
    WindowHandler as BaseWindowHandler, WindowOpenOptions, WindowScalePolicy,
};
use keyboard_types::{Key, KeyState};
use raw_window_handle::{HasRawWindowHandle, RawWindowHandle};
use raw_window_handle_06 as raw_window_handle_06;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::io::Write;
use std::fs;

#[derive(Serialize, Deserialize, Default)]
struct TrackData {
    engine_type: u32,
    params: HashMap<String, f32>,
    sequence: Vec<bool>,
    sample_path: Option<String>,
}

#[derive(Serialize, Deserialize, Default)]
struct ProjectData {
    title: String,
    description: String,
    bpm: f32,
    master_gain: f32,
    master_filter: f32,
    master_comp: f32,
    tracks: Vec<String>, // Paths to .trk files relative to project root
}

#[derive(Clone, Copy, Default)]
struct PendingProjectParams {
    gain: f32,
    master_filter: f32,
    master_comp: f32,
}

#[derive(Serialize, Deserialize, Clone)]
struct FmmiScaleDef {
    name: String,
    notes: Vec<i32>,
}
use std::process::Command as ProcessCommand;
use std::sync::atomic::AtomicI32;
use std::sync::atomic::{AtomicBool, AtomicU32, Ordering};
use std::cell::RefCell;
use std::sync::mpsc;
use std::sync::{Arc, Once, OnceLock};
use std::time::Instant;
use std::f32::consts::PI;
use fundsp::hacker32::{
    AudioUnit, Tanh, bandpass, highpass, lowpass, moog, noise, shape, sine,
};

pub const NUM_TRACKS: usize = 4;
pub const SYNDRM_PAGE_SIZE: usize = 16;
pub const SYNDRM_PAGES: usize = 8;
pub const SYNDRM_STEPS: usize = SYNDRM_PAGE_SIZE * SYNDRM_PAGES;
pub const SYNDRM_SAMPLE_CHANNELS: usize = 7;
pub const SYNDRM_LANES: usize = 7 + SYNDRM_SAMPLE_CHANNELS;
pub const FMMI_PAGE_SIZE: usize = 16;
pub const FMMI_PAGES: usize = 8;
pub const FMMI_STEPS: usize = FMMI_PAGE_SIZE * FMMI_PAGES;
pub const MONOMI_PAGE_SIZE: usize = 16;
pub const MONOMI_PAGES: usize = 8;
pub const MONOMI_STEPS: usize = MONOMI_PAGE_SIZE * MONOMI_PAGES;

const FMMI_SCALES_PATH: &str = "src/ui/assets/scales.json";
pub const MODUL8_LFOS: usize = 8;
pub const MODUL8_TARGET_COUNT: u32 = 172;
const FMMI_VOICES: usize = 8;

fn fmmi_compute_env(
    sr: f32,
    default_gate_ms: f32,
    attack: f32,
    decay: f32,
    sustain: f32,
    release: f32,
    gate_len: f32,
) -> (u32, u32, u32, f32, u32) {
    let attack_time = (attack / 127.0).clamp(0.0, 1.0) * 2.0;
    let decay_time = (decay / 127.0).clamp(0.0, 1.0) * 2.0;
    let release_time = (release / 127.0).clamp(0.0, 1.0) * 2.0;
    let attack_samples = (attack_time * sr).round().max(1.0) as u32;
    let decay_samples = (decay_time * sr).round().max(1.0) as u32;
    let release_samples = (release_time * sr).round().max(1.0) as u32;
    let sustain_level = (sustain / 127.0).clamp(0.0, 1.0);
    let gate_len_ms = if gate_len.is_finite() {
        gate_len.max(0.0)
    } else {
        default_gate_ms
    };
    let hold_samples = ((gate_len_ms / 1000.0) * sr).round().max(0.0) as u32;
    (
        attack_samples,
        decay_samples,
        release_samples,
        sustain_level,
        hold_samples,
    )
}

fn fmmi_trigger_voice(
    dsp_state: &mut FmmiDspState,
    sr: f32,
    default_gate_ms: f32,
    car_wave: u32,
    car_freq: f32,
    car_detune: f32,
    mod_wave: u32,
    mod_mode: u32,
    mod_value: f32,
    mod_detune: f32,
    index: f32,
    feedback: f32,
    drive: f32,
    out_level: f32,
    amp_attack: f32,
    amp_decay: f32,
    amp_sustain: f32,
    amp_release: f32,
    gate_length: f32,
) {
    let mut voice_idx = None;
    for (idx, voice) in dsp_state.voices.iter().enumerate() {
        if !voice.active {
            voice_idx = Some(idx);
            break;
        }
    }
    let idx = if let Some(idx) = voice_idx {
        idx
    } else {
        let mut best_idx = 0;
        let mut best_level = f32::MAX;
        let mut best_trigger = u64::MAX;
        for (idx, voice) in dsp_state.voices.iter().enumerate() {
            if voice.gate_level < best_level
                || (voice.gate_level == best_level && voice.last_trigger < best_trigger)
            {
                best_level = voice.gate_level;
                best_trigger = voice.last_trigger;
                best_idx = idx;
            }
        }
        best_idx
    };

    dsp_state.voice_clock = dsp_state.voice_clock.wrapping_add(1);
    let (attack_samples, decay_samples, release_samples, sustain_level, hold_samples) =
        fmmi_compute_env(
            sr,
            default_gate_ms,
            amp_attack,
            amp_decay,
            amp_sustain,
            amp_release,
            gate_length,
        );
    dsp_state.voices[idx] = FmmiVoiceState {
        active: true,
        car_phase: 0.0,
        mod_phase: 0.0,
        gate_level: 0.0,
        gate_stage: 1,
        gate_pos: 0,
        gate_hold: hold_samples,
        last_carrier: 0.0,
        car_wave,
        car_freq,
        car_detune,
        mod_wave,
        mod_mode,
        mod_value,
        mod_detune,
        index,
        feedback,
        drive,
        out_level,
        amp_attack,
        amp_decay,
        amp_sustain,
        amp_release,
        gate_length,
        attack_samples,
        decay_samples,
        release_samples,
        sustain_level,
        hold_samples,
        last_trigger: dsp_state.voice_clock,
    };
}

fn default_fmmi_scales() -> Vec<FmmiScaleDef> {
    vec![
        FmmiScaleDef {
            name: "Chromatic".to_string(),
            notes: vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
        },
        FmmiScaleDef {
            name: "Major".to_string(),
            notes: vec![0, 2, 4, 5, 7, 9, 11],
        },
        FmmiScaleDef {
            name: "Minor".to_string(),
            notes: vec![0, 2, 3, 5, 7, 8, 10],
        },
        FmmiScaleDef {
            name: "Pentatonic".to_string(),
            notes: vec![0, 2, 4, 7, 9],
        },
        FmmiScaleDef {
            name: "Blues".to_string(),
            notes: vec![0, 3, 5, 6, 7, 10],
        },
    ]
}

fn sanitize_fmmi_scales(mut scales: Vec<FmmiScaleDef>) -> Vec<FmmiScaleDef> {
    for scale in scales.iter_mut() {
        scale.notes.retain(|note| (0..=11).contains(note));
        scale.notes.sort_unstable();
        scale.notes.dedup();
        if scale.notes.is_empty() {
            scale.notes = vec![0, 2, 4, 5, 7, 9, 11];
        }
    }
    scales.retain(|scale| !scale.name.trim().is_empty());
    if scales.is_empty() {
        default_fmmi_scales()
    } else {
        scales
    }
}

fn fmmi_scales() -> &'static Vec<FmmiScaleDef> {
    static FMMI_SCALES: OnceLock<Vec<FmmiScaleDef>> = OnceLock::new();
    FMMI_SCALES.get_or_init(|| {
        let fallback = default_fmmi_scales();
        let Ok(text) = fs::read_to_string(FMMI_SCALES_PATH) else {
            return fallback;
        };
        let Ok(scales) = serde_json::from_str::<Vec<FmmiScaleDef>>(&text) else {
            return fallback;
        };
        sanitize_fmmi_scales(scales)
    })
}

fn fmmi_scale_mask(scale_notes: &[i32]) -> i32 {
    let mut mask = 0i32;
    for &note in scale_notes {
        if (0..=11).contains(&note) {
            mask |= 1 << note;
        }
    }
    mask
}

fn fmmi_random_note_in_scale(rng_state: &mut u32, scale_index: usize) -> i32 {
    let scales = fmmi_scales();
    let notes = scales
        .get(scale_index)
        .map(|scale| scale.notes.as_slice())
        .unwrap_or_else(|| scales[0].notes.as_slice());
    let octave_min = (FMMI_NOTE_BASE / 12).max(0);
    let octave_max = (FMMI_NOTE_MAX / 12).max(octave_min);
    for _ in 0..16 {
        let octave = octave_min
            + (fmmi_rand_unit(rng_state) * ((octave_max - octave_min + 1) as f32)) as i32;
        let idx = (fmmi_rand_unit(rng_state) * (notes.len() as f32)) as usize;
        if let Some(&semitone) = notes.get(idx) {
            let note = octave * 12 + semitone;
            if (FMMI_NOTE_BASE..=FMMI_NOTE_MAX).contains(&note) {
                return note;
            }
        }
    }
    FMMI_NOTE_BASE
}

const MONOMI_LFO_TARGETS: [&str; 15] = [
    "Filter Cutoff",
    "Resonance",
    "Filter Morph",
    "Filter Env Intensity",
    "Filter Env Polarity",
    "Note Glide",
    "Osc1 Detune",
    "Osc2 Detune",
    "Osc3 Detune",
    "Osc1 Mix",
    "Osc2 Mix",
    "Osc3 Mix",
    "Osc1 PWM",
    "Osc2 PWM",
    "Osc3 PWM",
];

fn monomi_scale_mask(scale_notes: &[i32]) -> i32 {
    fmmi_scale_mask(scale_notes)
}

fn monomi_random_note_in_scale(rng_state: &mut u32, scale_index: usize) -> i32 {
    fmmi_random_note_in_scale(rng_state, scale_index)
}
pub const SYNDRM_FILTER_TYPES: u32 = 4;
pub const WAVEFORM_SUMMARY_SIZE: usize = 100;
pub const RECORD_MAX_SECONDS: usize = 30;
pub const RECORD_MAX_SAMPLE_RATE: usize = 48_000;
pub const RECORD_MAX_SAMPLES: usize = RECORD_MAX_SECONDS * RECORD_MAX_SAMPLE_RATE;
pub const MOSAIC_BUFFER_SECONDS: usize = 4;
pub const MOSAIC_BUFFER_SAMPLES: usize = MOSAIC_BUFFER_SECONDS * RECORD_MAX_SAMPLE_RATE;
pub const MOSAIC_BUFFER_CHANNELS: usize = 2;
pub const MOSAIC_OUTPUT_GAIN: f32 = 1.5;
const MOSAIC_RATE_MIN: f32 = 2.0;
const MOSAIC_RATE_MAX: f32 = 60.0;
const MOSAIC_SIZE_MIN_MS: f32 = 10.0;
const MOSAIC_SIZE_MAX_MS: f32 = 250.0;
const MOSAIC_PITCH_SEMITONES: f32 = 36.0;
const METAL_INHARM_RATIOS: [f32; 6] = [1.0, 1.483, 1.932, 2.546, 2.63, 3.897];
const METAL_RESONANCE_HZ: f32 = 4000.0;
const METAL_OCTAVES: f32 = 1.5;
const MOSAIC_DETUNE_CENTS: f32 = 25.0;
const MOSAIC_PARAM_SMOOTH_MS: f32 = 20.0;
const MOSAIC_MAX_GRAINS: usize = 128;
const MOSAIC_GRAIN_MARKER_COUNT: usize = 32;
const G8_GAIN_SMOOTH_MS: f32 = 5.0;
const G8_STEPS: usize = 64;
const REFLECT_MAX_SAMPLE_RATE: usize = 192_000;
const REFLECT_MAX_DELAY_SECONDS: f32 = 10.0;
const REFLECT_MAX_DELAY_SAMPLES: usize =
    (REFLECT_MAX_SAMPLE_RATE as f32 * REFLECT_MAX_DELAY_SECONDS) as usize + 1;
const REFLECT_REVERB_MIN_SCALE: f32 = 0.5;
const REFLECT_REVERB_MAX_SCALE: f32 = 1.5;
const REFLECT_REVERB_COMB_BASE: [usize; 4] = [1116, 1188, 1277, 1356];
const REFLECT_REVERB_AP_BASE: [usize; 2] = [556, 441];
const RING_PITCH_SEMITONES: f32 = 24.0;
const RING_CUTOFF_MIN_HZ: f32 = 20.0;
const RING_CUTOFF_MAX_HZ: f32 = 20_000.0;
const RING_DETUNE_CENTS: f32 = 20.0;
const RING_DETUNE_RATE_HZ: f32 = 0.25;
const RING_LFO_RATE_MIN_HZ: f32 = 0.20;
const RING_LFO_RATE_MAX_HZ: f32 = 50.0;
const ANIMATE_LFO_RATE_MIN_HZ: f32 = 0.01;
const ANIMATE_LFO_RATE_MAX_HZ: f32 = 20.0;
const METRONOME_CLICK_MS: f32 = 12.0;
const METRONOME_CLICK_GAIN: f32 = 0.25;
const METRONOME_COUNT_IN_MAX_TICKS: u32 = 8;
const KEYLOCK_GRAIN_SIZE: usize = 256;
const KEYLOCK_GRAIN_HOP: usize = KEYLOCK_GRAIN_SIZE / 2;
const OSCILLOSCOPE_SAMPLES: usize = 256;
const SPECTRUM_BINS: usize = 48;
const SPECTRUM_WINDOW: usize = 256;
const VECTORSCOPE_POINTS: usize = 128;
const SYNDRM_SAMPLE_LABEL_MAX_CHARS: usize = 18;
const SYNDRM_SAMPLE_LABEL_ELLIPSES: bool = true;
const FMMI_NOTE_BASE: i32 = 24; // C1
const FMMI_NOTE_MAX: i32 = 95; // B6
const MONOMI_NOTE_BASE: i32 = 24; // C1
const MONOMI_NOTE_MAX: i32 = 95; // B6

fn default_window_size() -> baseview::Size {
    #[cfg(target_os = "windows")]
    {
        use windows_sys::Win32::UI::WindowsAndMessaging::{GetSystemMetrics, SM_CXSCREEN, SM_CYSCREEN};
        use windows_sys::Win32::UI::HiDpi::GetDpiForSystem;

        let physical_width = unsafe { GetSystemMetrics(SM_CXSCREEN) } as f64;
        let physical_height = unsafe { GetSystemMetrics(SM_CYSCREEN) } as f64;
        let dpi = unsafe { GetDpiForSystem() } as f64;
        let scale = if dpi > 0.0 { dpi / 96.0 } else { 1.0 };
        return baseview::Size::new(physical_width / scale, physical_height / scale);
    }

    #[cfg(not(target_os = "windows"))]
    {
        baseview::Size::new(1280.0, 800.0)
    }
}

include!(concat!(env!("OUT_DIR"), "/tlbx1.rs"));

#[derive(Clone)]
struct VideoFrame {
    timestamp: f32,
    data: Arc<Vec<u8>>,
}

struct VideoCache {
    frames: Vec<VideoFrame>,
    width: u32,
    height: u32,
    fps: f32,
}

#[derive(Clone)]
enum SynDRMLaneParamsCopy {
    None,
    Kick {
        override_enabled: Vec<bool>,
        pitch: Vec<u32>,
        decay: Vec<u32>,
        attack: Vec<u32>,
        drive: Vec<u32>,
        level: Vec<u32>,
        filter_type: Vec<u32>,
        filter_cutoff: Vec<u32>,
        filter_resonance: Vec<u32>,
        retrig_enabled: Vec<bool>,
        retrig_division: Vec<u32>,
    },
    Snare {
        override_enabled: Vec<bool>,
        tone: Vec<u32>,
        decay: Vec<u32>,
        snappy: Vec<u32>,
        attack: Vec<u32>,
        drive: Vec<u32>,
        level: Vec<u32>,
        filter_type: Vec<u32>,
        filter_cutoff: Vec<u32>,
        filter_resonance: Vec<u32>,
        retrig_enabled: Vec<bool>,
        retrig_division: Vec<u32>,
    },
    PitchTone {
        override_enabled: Vec<bool>,
        pitch: Vec<u32>,
        decay: Vec<u32>,
        tone: Vec<u32>,
        drive: Vec<u32>,
        level: Vec<u32>,
        filter_type: Vec<u32>,
        filter_cutoff: Vec<u32>,
        filter_resonance: Vec<u32>,
        retrig_enabled: Vec<bool>,
        retrig_division: Vec<u32>,
    },
    Samp {
        override_enabled: Vec<bool>,
        pitch: Vec<u32>,
        attack: Vec<u32>,
        decay: Vec<u32>,
        drive: Vec<u32>,
        level: Vec<u32>,
        filter_type: Vec<u32>,
        filter_cutoff: Vec<u32>,
        filter_resonance: Vec<u32>,
        retrig_enabled: Vec<bool>,
        retrig_division: Vec<u32>,
    },
}

impl Default for SynDRMLaneParamsCopy {
    fn default() -> Self {
        Self::None
    }
}

struct SynDRMCopyBuffer {
    has_data: bool,
    lanes_mask: u16,
    start: usize,
    len: usize,
    include_steps: bool,
    include_params: bool,
    source_lane: Option<u32>,
    page_scoped: bool,
    steps: Vec<Vec<bool>>,
    params: Vec<SynDRMLaneParamsCopy>,
}

impl SynDRMCopyBuffer {
    fn new() -> Self {
        Self {
            has_data: false,
            lanes_mask: 0,
            start: 0,
            len: 0,
            include_steps: false,
            include_params: false,
            source_lane: None,
            page_scoped: false,
            steps: vec![Vec::new(); SYNDRM_LANES],
            params: vec![SynDRMLaneParamsCopy::None; SYNDRM_LANES],
        }
    }
}

struct FMMIStepParamsCopy {
    note: i32,
    car_wave: i32,
    mod_wave: i32,
    mod_mode: i32,
    car_freq: u32,
    car_detune: u32,
    mod_value: u32,
    mod_detune: u32,
    index: u32,
    feedback: u32,
    drive: u32,
    out_level: u32,
    amp_attack: u32,
    amp_decay: u32,
    amp_sustain: u32,
    amp_release: u32,
    gate_length: u32,
}

struct FMMICopyBuffer {
    has_data: bool,
    len: usize,
    include_steps: bool,
    include_params: bool,
    page_scoped: bool,
    steps: Vec<bool>,
    params: Vec<FMMIStepParamsCopy>,
}

impl FMMICopyBuffer {
    fn new() -> Self {
        Self {
            has_data: false,
            len: 0,
            include_steps: false,
            include_params: false,
            page_scoped: false,
            steps: Vec::new(),
            params: Vec::new(),
        }
    }
}

struct Track {
    /// Audio data for the track. Each channel is a Vec of f32.
    samples: Arc<Mutex<Vec<Vec<f32>>>>,
    /// Last loaded sample path, if any.
    sample_path: Arc<Mutex<Option<PathBuf>>>,
    /// Pre-calculated waveform summary for fast drawing.
    waveform_summary: Arc<Mutex<Vec<f32>>>,
    /// Cached video frames for the tape engine, if loaded.
    video_cache: Arc<Mutex<Option<VideoCache>>>,
    /// Whether a video stream is loaded for this track.
    video_enabled: AtomicBool,
    /// Video frame width.
    video_width: AtomicU32,
    /// Video frame height.
    video_height: AtomicU32,
    /// Video frame rate (fps) stored as f32 bits.
    video_fps: AtomicU32,
    /// Video cache version (increments on load).
    video_cache_id: AtomicU32,
    /// Whether the track is currently recording.
    is_recording: AtomicBool,
    /// Pending play start after count-in.
    pending_play: AtomicBool,
    /// Pending record start after count-in.
    pending_record: AtomicBool,
    /// Count-in samples remaining before starting.
    count_in_remaining: AtomicU32,
    /// Recording head position in samples.
    record_pos: AtomicU32,
    /// Whether the track is currently playing.
    is_playing: AtomicBool,
    /// Playback position in samples. Stored as u32 bits for f32.
    play_pos: AtomicU32,
    /// Track output level (linear gain).
    level: AtomicU32,
    /// Smoothed track output level (linear gain).
    level_smooth: AtomicU32,
    /// Smoothed track meter (left).
    meter_left: AtomicU32,
    /// Smoothed track meter (right).
    meter_right: AtomicU32,
    /// Track mute state.
    is_muted: AtomicBool,
    /// Tape speed multiplier.
    tape_speed: AtomicU32,
    /// Smoothed tape speed.
    tape_speed_smooth: AtomicU32,
    /// Tape tempo (BPM).
    tape_tempo: AtomicU32,
    /// Tape rate mode: 0=Free, 1=Straight, 2=Dotted, 3=Triplet.
    tape_rate_mode: AtomicU32,
    /// Pending sync request for straight tape playback.
    tape_sync_requested: AtomicBool,
    /// Tape rotate amount (normalized 0..1).
    tape_rotate: AtomicU32,
    /// Smoothed tape rotate.
    tape_rotate_smooth: AtomicU32,
    /// Tape glide amount (normalized 0..1).
    tape_glide: AtomicU32,
    /// Smoothed tape glide.
    tape_glide_smooth: AtomicU32,
    /// Tape sound-on-sound amount (normalized 0..1).
    tape_sos: AtomicU32,
    /// Tape reverse toggle.
    tape_reverse: AtomicBool,
    /// Tape freeze toggle.
    tape_freeze: AtomicBool,
    /// Tape keylock toggle.
    tape_keylock: AtomicBool,
    /// Keylock grain phase (0..KEYLOCK_GRAIN_HOP).
    keylock_phase: AtomicU32,
    /// Keylock grain A start position in samples.
    keylock_grain_a: AtomicU32,
    /// Keylock grain B start position in samples.
    keylock_grain_b: AtomicU32,
    /// Tape monitor toggle.
    tape_monitor: AtomicBool,
    /// Tape overdub toggle.
    tape_overdub: AtomicBool,
    /// Loop start position as normalized 0..1.
    loop_start: AtomicU32,
    /// Smoothed loop start position.
    loop_start_smooth: AtomicU32,
    /// Trigger start position as normalized 0..1.
    trigger_start: AtomicU32,
    /// Loop length as normalized 0..1.
    loop_length: AtomicU32,
    /// Smoothed loop length.
    loop_length_smooth: AtomicU32,
    /// Loop crossfade amount as normalized 0..0.5.
    loop_xfade: AtomicU32,
    /// Smoothed loop crossfade.
    loop_xfade_smooth: AtomicU32,
    /// Loop enabled.
    loop_enabled: AtomicBool,
    /// Loop mode for playback.
    loop_mode: AtomicU32,
    /// Playback direction for ping-pong mode.
    loop_dir: AtomicI32,
    /// Last loop start position in samples (for jump-to behavior).
    loop_start_last: AtomicU32,
    /// Granular device type (0 = none, 1 = Mosaic).
    granular_type: AtomicU32,
    /// Mosaic pitch amount.
    mosaic_pitch: AtomicU32,
    /// Smoothed mosaic pitch amount.
    mosaic_pitch_smooth: AtomicU32,
    /// Mosaic grain rate.
    mosaic_rate: AtomicU32,
    /// Smoothed mosaic grain rate.
    mosaic_rate_smooth: AtomicU32,
    /// Mosaic grain size.
    mosaic_size: AtomicU32,
    /// Smoothed mosaic grain size.
    mosaic_size_smooth: AtomicU32,
    /// Mosaic contour.
    mosaic_contour: AtomicU32,
    /// Smoothed mosaic contour.
    mosaic_contour_smooth: AtomicU32,
    /// Mosaic warp amount.
    mosaic_warp: AtomicU32,
    /// Smoothed mosaic warp amount.
    mosaic_warp_smooth: AtomicU32,
    /// Mosaic spray amount.
    mosaic_spray: AtomicU32,
    /// Smoothed mosaic spray amount.
    mosaic_spray_smooth: AtomicU32,
    /// Mosaic pattern amount.
    mosaic_pattern: AtomicU32,
    /// Smoothed mosaic pattern amount.
    mosaic_pattern_smooth: AtomicU32,
    /// Mosaic wet/dry.
    mosaic_wet: AtomicU32,
    /// Smoothed mosaic wet/dry.
    mosaic_wet_smooth: AtomicU32,
    /// Mosaic spatial random pan amount.
    mosaic_spatial: AtomicU32,
    /// Smoothed mosaic spatial random pan amount.
    mosaic_spatial_smooth: AtomicU32,
    /// Mosaic detune.
    mosaic_detune: AtomicU32,
    /// Smoothed mosaic detune.
    mosaic_detune_smooth: AtomicU32,
    /// Mosaic random rate.
    mosaic_rand_rate: AtomicU32,
    /// Smoothed mosaic random rate.
    mosaic_rand_rate_smooth: AtomicU32,
    /// Mosaic random size.
    mosaic_rand_size: AtomicU32,
    /// Smoothed mosaic random size.
    mosaic_rand_size_smooth: AtomicU32,
    /// Mosaic sound-on-sound.
    mosaic_sos: AtomicU32,
    /// Smoothed mosaic sound-on-sound.
    mosaic_sos_smooth: AtomicU32,
    /// Mosaic post gain (after granulation).
    mosaic_post_gain: AtomicU32,
    /// Smoothed mosaic post gain.
    mosaic_post_gain_smooth: AtomicU32,
    /// Mosaic output enabled.
    mosaic_enabled: AtomicBool,
    /// Mosaic grains locked to tape loop area.
    mosaic_loop_lock: AtomicBool,
    /// Mosaic ring buffer fed by tape output.
    mosaic_buffer: Arc<Mutex<Vec<Vec<f32>>>>,
    /// Mosaic ring buffer write position.
    mosaic_write_pos: AtomicU32,
    /// Mosaic grain active flags.
    mosaic_grain_active: [AtomicBool; MOSAIC_MAX_GRAINS],
    /// Mosaic grain start positions in ring buffer.
    mosaic_grain_start: [AtomicU32; MOSAIC_MAX_GRAINS],
    /// Mosaic grain positions within grains.
    mosaic_grain_pos: [AtomicU32; MOSAIC_MAX_GRAINS],
    /// Mosaic grain lengths in output samples.
    mosaic_grain_len: [AtomicU32; MOSAIC_MAX_GRAINS],
    /// Mosaic pitch ratios per grain.
    mosaic_grain_pitch: [AtomicU32; MOSAIC_MAX_GRAINS],
    /// Mosaic pan positions per grain.
    mosaic_grain_pan: [AtomicU32; MOSAIC_MAX_GRAINS],
    /// Mosaic samples until the next grain spawn in free rate.
    mosaic_spawn_phase: AtomicU32,
    /// Last grain start position for UI marker.
    mosaic_last_grain_start: AtomicU32,
    /// Last grain length for UI marker.
    mosaic_last_grain_len: AtomicU32,
    /// Mosaic RNG state for grain start selection.
    mosaic_rng_state: AtomicU32,
    /// Recent mosaic grain start markers (normalized 0..1).
    mosaic_grain_markers: [AtomicU32; MOSAIC_GRAIN_MARKER_COUNT],
    /// Write index for mosaic grain markers ring.
    mosaic_grain_marker_write: AtomicU32,
    /// Ring filter cutoff (normalized 0..1).
    ring_cutoff: AtomicU32,
    /// Smoothed ring cutoff.
    ring_cutoff_smooth: AtomicU32,
    /// Ring filter resonance (normalized 0..1).
    ring_resonance: AtomicU32,
    /// Smoothed ring resonance.
    ring_resonance_smooth: AtomicU32,
    /// Ring filter decay (normalized 0..1).
    ring_decay: AtomicU32,
    /// Smoothed ring decay.
    ring_decay_smooth: AtomicU32,
    /// Ring filter decay mode (0 = sustain, 1 = choke).
    ring_decay_mode: AtomicU32,
    /// Ring filter pitch offset (normalized 0..1, bipolar).
    ring_pitch: AtomicU32,
    /// Smoothed ring pitch offset.
    ring_pitch_smooth: AtomicU32,
    /// Ring filter tone (normalized 0..1, bipolar).
    ring_tone: AtomicU32,
    /// Smoothed ring tone.
    ring_tone_smooth: AtomicU32,
    /// Ring filter tilt (normalized 0..1, bipolar).
    ring_tilt: AtomicU32,
    /// Smoothed ring tilt.
    ring_tilt_smooth: AtomicU32,
    /// Ring filter slope (normalized 0..1).
    ring_slope: AtomicU32,
    /// Smoothed ring slope.
    ring_slope_smooth: AtomicU32,
    /// Ring filter wet mix (normalized 0..1).
    ring_wet: AtomicU32,
    /// Smoothed ring wet mix.
    ring_wet_smooth: AtomicU32,
    /// Ring filter detune (normalized 0..1).
    ring_detune: AtomicU32,
    /// Smoothed ring detune.
    ring_detune_smooth: AtomicU32,
    /// Ring waves depth (normalized 0..1).
    ring_waves: AtomicU32,
    /// Smoothed ring waves depth.
    ring_waves_smooth: AtomicU32,
    /// Ring waves rate (normalized 0..1).
    ring_waves_rate: AtomicU32,
    /// Smoothed ring waves rate.
    ring_waves_rate_smooth: AtomicU32,
    /// Ring waves rate mode (0 = free, 1 = straight, 2 = dotted, 3 = triplet).
    ring_waves_rate_mode: AtomicU32,
    /// Ring waves LFO phase.
    ring_waves_phase: AtomicU32,
    /// Ring noise depth (normalized 0..1).
    ring_noise: AtomicU32,
    /// Smoothed ring noise depth.
    ring_noise_smooth: AtomicU32,
    /// Ring noise rate (normalized 0..1).
    ring_noise_rate: AtomicU32,
    /// Smoothed ring noise rate.
    ring_noise_rate_smooth: AtomicU32,
    /// Ring noise rate mode (0 = free, 1 = straight, 2 = dotted, 3 = triplet).
    ring_noise_rate_mode: AtomicU32,
    /// Ring noise phase.
    ring_noise_phase: AtomicU32,
    /// Ring noise current value (-1..1).
    ring_noise_value: AtomicU32,
    /// Ring noise RNG state.
    ring_noise_rng: AtomicU32,
    /// Ring scale mode (0 = chromatic, 1 = major, 2 = minor).
    ring_scale: AtomicU32,
    /// Ring detune LFO phase.
    ring_detune_phase: AtomicU32,
    /// Ring filter enabled.
    ring_enabled: AtomicBool,
    /// Ring filter pre/post toggle (true = pre, false = post).
    ring_pre_post: AtomicBool,
    /// Ring filter low-pass state per channel.
    ring_low: [AtomicU32; 2],
    /// Ring filter band-pass state per channel.
    ring_band: [AtomicU32; 2],
    /// G8 trance gate enabled.
    g8_enabled: AtomicBool,
    /// G8 rate division index (0 = 1, 1 = 1/2, 2 = 1/4, 3 = 1/8, 4 = 1/16).
    g8_rate_index: AtomicU32,
    /// G8 per-step gain values (0..1).
    g8_steps: Arc<[AtomicU32; G8_STEPS]>,
    /// Smoothed G8 gate gain.
    g8_gain_smooth: AtomicU32,
    /// Modul8 enabled.
    modul8_enabled: AtomicBool,
    /// Modul8 LFO waveforms (0=sine,1=triangle,2=saw,3=square,4=s&h).
    modul8_wave: [AtomicU32; MODUL8_LFOS],
    /// Modul8 free-rate Hz.
    modul8_rate: [AtomicU32; MODUL8_LFOS],
    /// Modul8 BPM sync toggles.
    modul8_sync: [AtomicBool; MODUL8_LFOS],
    /// Modul8 BPM division index.
    modul8_division: [AtomicU32; MODUL8_LFOS],
    /// Modul8 modulation amount (0..1).
    modul8_amount: [AtomicU32; MODUL8_LFOS],
    /// Modul8 bias/center (0..1) within target range.
    modul8_bias: [AtomicU32; MODUL8_LFOS],
    /// Modul8 destination index.
    modul8_target: [AtomicU32; MODUL8_LFOS],
    /// Modul8 oscillator phase.
    modul8_phase: [AtomicU32; MODUL8_LFOS],
    /// Modul8 sample-and-hold value cache.
    modul8_snh: [AtomicU32; MODUL8_LFOS],
    /// Modul8 captured base value per LFO target.
    modul8_base_value: [AtomicU32; MODUL8_LFOS],
    /// Modul8 captured base target index per LFO (`u32::MAX` = none).
    modul8_base_target: [AtomicU32; MODUL8_LFOS],
    /// Modul8 RNG state for S&H.
    modul8_rng_state: AtomicU32,
    /// Texture device enabled.
    texture_enabled: AtomicBool,
    /// Texture noise gate enabled.
    texture_gate: AtomicBool,
    /// Texture drive amount.
    texture_drive: AtomicU32,
    /// Smoothed texture drive.
    texture_drive_smooth: AtomicU32,
    /// Texture compress amount.
    texture_compress: AtomicU32,
    /// Smoothed texture compress.
    texture_compress_smooth: AtomicU32,
    /// Texture crush amount.
    texture_crush: AtomicU32,
    /// Smoothed texture crush.
    texture_crush_smooth: AtomicU32,
    /// Texture tilt amount.
    texture_tilt: AtomicU32,
    /// Smoothed texture tilt.
    texture_tilt_smooth: AtomicU32,
    /// Texture noise amount.
    texture_noise: AtomicU32,
    /// Smoothed texture noise.
    texture_noise_smooth: AtomicU32,
    /// Texture noise decay.
    texture_noise_decay: AtomicU32,
    /// Smoothed texture noise decay.
    texture_noise_decay_smooth: AtomicU32,
    /// Texture noise color.
    texture_noise_color: AtomicU32,
    /// Smoothed texture noise color.
    texture_noise_color_smooth: AtomicU32,
    /// Texture wet mix.
    texture_wet: AtomicU32,
    /// Smoothed texture wet mix.
    texture_wet_smooth: AtomicU32,
    /// Texture post gain.
    texture_post_gain: AtomicU32,
    /// Smoothed texture post gain.
    texture_post_gain_smooth: AtomicU32,
    /// Texture noise envelope.
    texture_noise_env: AtomicU32,
    /// Texture noise RNG state.
    texture_noise_rng: AtomicU32,
    /// Texture noise filter state per channel.
    texture_noise_lp: [AtomicU32; 2],
    /// Texture tilt filter state per channel.
    texture_tilt_lp: [AtomicU32; 2],
    /// Texture crush phase.
    texture_crush_phase: AtomicU32,
    /// Texture crush hold value per channel.
    texture_crush_hold: [AtomicU32; 2],
    /// Reflect device enabled.
    reflect_enabled: AtomicBool,
    /// Reflect freeze toggle.
    reflect_freeze: AtomicBool,
    /// Reflect delay mix.
    reflect_delay: AtomicU32,
    /// Smoothed reflect delay mix.
    reflect_delay_smooth: AtomicU32,
    /// Reflect time (normalized).
    reflect_time: AtomicU32,
    /// Smoothed reflect time.
    reflect_time_smooth: AtomicU32,
    /// Reflect time mode (0 = straight, 1 = dotted, 2 = triplet, 3 = free).
    reflect_time_mode: AtomicU32,
    /// Reflect reverb mix.
    reflect_reverb: AtomicU32,
    /// Smoothed reflect reverb mix.
    reflect_reverb_smooth: AtomicU32,
    /// Reflect size.
    reflect_size: AtomicU32,
    /// Smoothed reflect size.
    reflect_size_smooth: AtomicU32,
    /// Reflect feedback.
    reflect_feedback: AtomicU32,
    /// Smoothed reflect feedback.
    reflect_feedback_smooth: AtomicU32,
    /// Reflect spread.
    reflect_spread: AtomicU32,
    /// Smoothed reflect spread.
    reflect_spread_smooth: AtomicU32,
    /// Reflect damp.
    reflect_damp: AtomicU32,
    /// Smoothed reflect damp.
    reflect_damp_smooth: AtomicU32,
    /// Reflect decay.
    reflect_decay: AtomicU32,
    /// Smoothed reflect decay.
    reflect_decay_smooth: AtomicU32,
    /// Reflect post gain.
    reflect_post_gain: AtomicU32,
    /// Smoothed reflect post gain.
    reflect_post_gain_smooth: AtomicU32,
    /// Reflect clear flag.
    reflect_clear: AtomicBool,
    /// Reflect delay buffer (stereo).
    reflect_delay_buffer: Arc<Mutex<[Vec<f32>; 2]>>,
    /// Reflect delay write position.
    reflect_delay_write_pos: AtomicU32,
    /// Reflect reverb comb buffers.
    reflect_reverb_comb_buffers: Arc<Mutex<[[Vec<f32>; 4]; 2]>>,
    /// Reflect reverb comb positions.
    reflect_reverb_comb_pos: [AtomicU32; 8],
    /// Reflect reverb allpass buffers.
    reflect_reverb_ap_buffers: Arc<Mutex<[[Vec<f32>; 2]; 2]>>,
    /// Reflect reverb allpass positions.
    reflect_reverb_ap_pos: [AtomicU32; 4],
    /// Reflect delay feedback damp state per channel.
    reflect_damp_state_delay: [AtomicU32; 2],
    /// Reflect reverb feedback damp state per channel.
    reflect_damp_state_reverb: [AtomicU32; 2],
    /// Animate slot types (0 = wavetable, 1 = sample).
    animate_slot_types: [AtomicU32; 4],
    /// Animate slot wavetable indices.
    animate_slot_wavetables: [AtomicU32; 4],
    /// Animate slot sample indices.
    animate_slot_samples: [AtomicU32; 4],
    /// Animate slot coarse pitch.
    animate_slot_coarse: [AtomicU32; 4],
    /// Animate slot fine pitch.
    animate_slot_fine: [AtomicU32; 4],
    /// Animate slot level.
    animate_slot_level: [AtomicU32; 4],
    /// Smoothed animate slot level.
    animate_slot_level_smooth: [AtomicU32; 4],
    /// Animate slot pan.
    animate_slot_pan: [AtomicU32; 4],
    /// Smoothed animate slot pan.
    animate_slot_pan_smooth: [AtomicU32; 4],
    /// Animate wavetable LFO amount.
    animate_slot_wt_lfo_amount: [AtomicU32; 4],
    /// Animate wavetable LFO shape.
    animate_slot_wt_lfo_shape: [AtomicU32; 4],
    /// Animate wavetable LFO rate.
    animate_slot_wt_lfo_rate: [AtomicU32; 4],
    /// Animate wavetable LFO sync.
    animate_slot_wt_lfo_sync: [AtomicBool; 4],
    /// Animate wavetable LFO division.
    animate_slot_wt_lfo_division: [AtomicU32; 4],
    /// Animate wavetable LFO phase.
    animate_slot_wt_lfo_phase: [AtomicU32; 4],
    /// Animate wavetable LFO sample-and-hold value.
    animate_slot_wt_lfo_snh: [AtomicU32; 4],
    /// Animate sample start (normalized 0..1).
    animate_slot_sample_start: [AtomicU32; 4],
    /// Animate sample loop start (normalized 0..1).
    animate_slot_loop_start: [AtomicU32; 4],
    /// Animate sample loop end (normalized 0..1).
    animate_slot_loop_end: [AtomicU32; 4],
    /// Animate slot filter type (0 = lp24, 1 = lp12, 2 = hp, 3 = bp).
    animate_slot_filter_type: [AtomicU32; 4],
    /// Animate slot filter cutoff (normalized 0..1).
    animate_slot_filter_cutoff: [AtomicU32; 4],
    /// Animate slot filter resonance (normalized 0..1).
    animate_slot_filter_resonance: [AtomicU32; 4],
    /// Animate slot filter state v1 (per voice).
    animate_slot_filter_v1: [[AtomicU32; 4]; 10],
    /// Animate slot filter state v2 (per voice).
    animate_slot_filter_v2: [[AtomicU32; 4]; 10],
    /// Animate slot filter state v1 stage 2 (per voice).
    animate_slot_filter_v1_stage2: [[AtomicU32; 4]; 10],
    /// Animate slot filter state v2 stage 2 (per voice).
    animate_slot_filter_v2_stage2: [[AtomicU32; 4]; 10],
    /// Animate vector position X (0..1).
    animate_vector_x: AtomicU32,
    /// Animate vector position Y (0..1).
    animate_vector_y: AtomicU32,
    /// Smoothed animate vector position X.
    animate_vector_x_smooth: AtomicU32,
    /// Smoothed animate vector position Y.
    animate_vector_y_smooth: AtomicU32,
    /// Animate vector LFO X waveform (0 = sine, 1 = triangle, 2 = square, 3 = saw, 4 = sample&hold).
    animate_lfo_x_waveform: AtomicU32,
    /// Animate vector LFO X sync to BPM.
    animate_lfo_x_sync: AtomicBool,
    /// Animate vector LFO X tempo division index.
    animate_lfo_x_division: AtomicU32,
    /// Animate vector LFO X rate (normalized 0..1, free mode).
    animate_lfo_x_rate: AtomicU32,
    /// Animate vector LFO X amount (normalized 0..1).
    animate_lfo_x_amount: AtomicU32,
    /// Animate vector LFO X phase (0..1).
    animate_lfo_x_phase: AtomicU32,
    /// Animate vector LFO X sample-and-hold value (-1..1).
    animate_lfo_x_snh: AtomicU32,
    /// Animate vector LFO Y waveform (0 = sine, 1 = triangle, 2 = square, 3 = saw, 4 = sample&hold).
    animate_lfo_y_waveform: AtomicU32,
    /// Animate vector LFO Y sync to BPM.
    animate_lfo_y_sync: AtomicBool,
    /// Animate vector LFO Y tempo division index.
    animate_lfo_y_division: AtomicU32,
    /// Animate vector LFO Y rate (normalized 0..1, free mode).
    animate_lfo_y_rate: AtomicU32,
    /// Animate vector LFO Y amount (normalized 0..1).
    animate_lfo_y_amount: AtomicU32,
    /// Animate vector LFO Y phase (0..1).
    animate_lfo_y_phase: AtomicU32,
    /// Animate vector LFO Y sample-and-hold value (-1..1).
    animate_lfo_y_snh: AtomicU32,
    /// Animate LFO RNG state.
    animate_lfo_rng_state: AtomicU32,
    /// Animate sequencer grid (10 rows * 16 steps).
    animate_sequencer_grid: Arc<[AtomicBool; 160]>,
    /// Animate sequencer current step.
    animate_sequencer_step: AtomicI32,
    /// Animate sequencer phase in samples.
    animate_sequencer_phase: AtomicU32,
    /// Animate slot oscillator phases (0..1) for each voice.
    animate_slot_phases: [[AtomicU32; 4]; 10],
    /// Animate slot sample playback positions (in samples) for each voice.
    animate_slot_sample_pos: [[AtomicU32; 4]; 10],
    /// Animate amp envelope stage (0 = idle, 1 = attack, 2 = decay, 3 = sustain, 4 = release) for each voice.
    animate_amp_stage: [AtomicU32; 10],
    /// Animate amp envelope level (0..1) for each voice.
    animate_amp_level: [AtomicU32; 10],
    /// Animate slot A attack time in seconds.
    animate_slot_a_attack: AtomicU32,
    /// Animate slot A decay time in seconds.
    animate_slot_a_decay: AtomicU32,
    /// Animate slot A sustain level (0..1).
    animate_slot_a_sustain: AtomicU32,
    /// Animate slot A release time in seconds.
    animate_slot_a_release: AtomicU32,
    /// Animate slot A amp envelope stage per voice.
    animate_slot_a_amp_stage: [AtomicU32; 10],
    /// Animate slot A amp envelope level per voice.
    animate_slot_a_amp_level: [AtomicU32; 10],
    /// Animate keybed trigger note (MIDI note).
    animate_keybed_note: AtomicI32,
    /// Animate keybed trigger flag.
    animate_keybed_trigger: AtomicBool,
    /// Animate keybed hold (sustain).
    animate_keybed_hold: AtomicBool,
    /// Animate keybed amp envelope stage.
    animate_keybed_amp_stage: AtomicU32,
    /// Animate keybed amp envelope level.
    animate_keybed_amp_level: AtomicU32,
    /// Animate keybed slot A amp envelope stage.
    animate_keybed_slot_a_amp_stage: AtomicU32,
    /// Animate keybed slot A amp envelope level.
    animate_keybed_slot_a_amp_level: AtomicU32,
    /// Animate keybed slot oscillator phases.
    animate_keybed_slot_phases: [AtomicU32; 4],
    /// Animate keybed slot sample playback positions.
    animate_keybed_slot_sample_pos: [AtomicU32; 4],
    /// Animate keybed filter state v1 per slot.
    animate_keybed_filter_v1: [AtomicU32; 4],
    /// Animate keybed filter state v2 per slot.
    animate_keybed_filter_v2: [AtomicU32; 4],
    /// Animate keybed filter state v1 stage 2 per slot.
    animate_keybed_filter_v1_stage2: [AtomicU32; 4],
    /// Animate keybed filter state v2 stage 2 per slot.
    animate_keybed_filter_v2_stage2: [AtomicU32; 4],
    /// SynDRM kick pitch (normalized 0..1).
    kick_pitch: AtomicU32,
    /// SynDRM kick decay (normalized 0..1).
    kick_decay: AtomicU32,
    /// SynDRM kick attack (normalized 0..1).
    kick_attack: AtomicU32,
    /// SynDRM kick pitch envelope amount (normalized 0..1).
    kick_pitch_env_amount: AtomicU32,
    /// SynDRM kick drive (normalized 0..1).
    kick_drive: AtomicU32,
    /// SynDRM kick output level (normalized 0..1).
    kick_level: AtomicU32,
    /// SynDRM kick filter type (0 = Moog LP, 1 = LP, 2 = HP, 3 = BP).
    kick_filter_type: AtomicU32,
    /// SynDRM kick filter cutoff (normalized 0..1).
    kick_filter_cutoff: AtomicU32,
    /// SynDRM kick filter resonance (normalized 0..1).
    kick_filter_resonance: AtomicU32,
    /// SynDRM kick filter pre-drive toggle.
    kick_filter_pre_drive: AtomicBool,
    /// SynDRM kick cut group (0 = none, 1..14).
    kick_cut_group: AtomicU32,
    /// SynDRM kick cut by group (0 = none, 1..14).
    kick_cut_by: AtomicU32,
    /// SynDRM kick trigger probability (0..1).
    kick_prob: AtomicU32,
    /// SynDRM kick lane enabled.
    kick_lane_enabled: AtomicBool,
    /// SynDRM kick sequencer grid (128 steps).
    kick_sequencer_grid: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM kick sequencer current step.
    kick_sequencer_step: AtomicI32,
    /// SynDRM kick sequencer phase in samples.
    kick_sequencer_phase: AtomicU32,
    /// SynDRM kick oscillator phase (0..1).
    kick_phase: AtomicU32,
    /// SynDRM kick amplitude envelope (0..1).
    kick_env: AtomicU32,
    /// SynDRM kick pitch envelope (0..1).
    kick_pitch_env: AtomicU32,
    /// SynDRM kick attack remaining samples.
    /// SynDRM snare tone (normalized 0..1).
    snare_tone: AtomicU32,
    /// SynDRM snare decay (normalized 0..1).
    snare_decay: AtomicU32,
    /// SynDRM snare snappy/noise mix (normalized 0..1).
    snare_snappy: AtomicU32,
    /// SynDRM snare attack (normalized 0..1).
    snare_attack: AtomicU32,
    /// SynDRM snare drive (normalized 0..1).
    snare_drive: AtomicU32,
    /// SynDRM snare output level (normalized 0..1).
    snare_level: AtomicU32,
    /// SynDRM snare filter type (0 = Moog LP, 1 = LP, 2 = HP, 3 = BP).
    snare_filter_type: AtomicU32,
    /// SynDRM snare filter cutoff (normalized 0..1).
    snare_filter_cutoff: AtomicU32,
    /// SynDRM snare filter resonance (normalized 0..1).
    snare_filter_resonance: AtomicU32,
    /// SynDRM snare filter pre-drive toggle.
    snare_filter_pre_drive: AtomicBool,
    /// SynDRM snare cut group (0 = none, 1..14).
    snare_cut_group: AtomicU32,
    /// SynDRM snare cut by group (0 = none, 1..14).
    snare_cut_by: AtomicU32,
    /// SynDRM snare trigger probability (0..1).
    snare_prob: AtomicU32,
    /// SynDRM snare lane enabled.
    snare_lane_enabled: AtomicBool,
    /// SynDRM snare sequencer grid (128 steps).
    snare_sequencer_grid: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM snare sequencer current step.
    snare_sequencer_step: AtomicI32,
    /// SynDRM snare sequencer phase in samples.
    snare_sequencer_phase: AtomicU32,
    /// SynDRM snare oscillator phase (0..1).
    snare_phase: AtomicU32,
    /// SynDRM snare tone envelope (0..1).
    snare_env: AtomicU32,
    /// SynDRM snare noise envelope (0..1).
    snare_noise_env: AtomicU32,
    /// SynDRM snare attack remaining samples.
    snare_attack_remaining: AtomicU32,
    /// SynDRM snare noise RNG state.
    snare_noise_rng: AtomicU32,
    /// SynDRM clap pitch (normalized 0..1).
    clap_pitch: AtomicU32,
    /// SynDRM clap decay (normalized 0..1).
    clap_decay: AtomicU32,
    /// SynDRM clap tone (normalized 0..1).
    clap_tone: AtomicU32,
    /// SynDRM clap drive (normalized 0..1).
    clap_drive: AtomicU32,
    /// SynDRM clap output level (normalized 0..1).
    clap_level: AtomicU32,
    /// SynDRM clap filter type (0 = Moog LP, 1 = LP, 2 = HP, 3 = BP).
    clap_filter_type: AtomicU32,
    /// SynDRM clap filter cutoff (normalized 0..1).
    clap_filter_cutoff: AtomicU32,
    /// SynDRM clap filter resonance (normalized 0..1).
    clap_filter_resonance: AtomicU32,
    /// SynDRM clap filter pre-drive toggle.
    clap_filter_pre_drive: AtomicBool,
    /// SynDRM clap cut group (0 = none, 1..14).
    clap_cut_group: AtomicU32,
    /// SynDRM clap cut by group (0 = none, 1..14).
    clap_cut_by: AtomicU32,
    /// SynDRM clap trigger probability (0..1).
    clap_prob: AtomicU32,
    /// SynDRM clap lane enabled.
    clap_lane_enabled: AtomicBool,
    /// SynDRM clap sequencer grid (128 steps).
    clap_sequencer_grid: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM clap sequencer current step.
    clap_sequencer_step: AtomicI32,
    /// SynDRM clap sequencer phase in samples.
    clap_sequencer_phase: AtomicU32,
    /// SynDRM clap envelope (0..1).
    clap_env: AtomicU32,
    /// SynDRM clap phase (samples).
    clap_phase: AtomicU32,
    /// SynDRM hat pitch (normalized 0..1).
    hat_pitch: AtomicU32,
    /// SynDRM hat decay (normalized 0..1).
    hat_decay: AtomicU32,
    /// SynDRM hat tone (normalized 0..1).
    hat_tone: AtomicU32,
    /// SynDRM hat drive (normalized 0..1).
    hat_drive: AtomicU32,
    /// SynDRM hat output level (normalized 0..1).
    hat_level: AtomicU32,
    /// SynDRM hat filter type (0 = Moog LP, 1 = LP, 2 = HP, 3 = BP).
    hat_filter_type: AtomicU32,
    /// SynDRM hat filter cutoff (normalized 0..1).
    hat_filter_cutoff: AtomicU32,
    /// SynDRM hat filter resonance (normalized 0..1).
    hat_filter_resonance: AtomicU32,
    /// SynDRM hat filter pre-drive toggle.
    hat_filter_pre_drive: AtomicBool,
    /// SynDRM hat cut group (0 = none, 1..14).
    hat_cut_group: AtomicU32,
    /// SynDRM hat cut by group (0 = none, 1..14).
    hat_cut_by: AtomicU32,
    /// SynDRM hat trigger probability (0..1).
    hat_prob: AtomicU32,
    /// SynDRM hat lane enabled.
    hat_lane_enabled: AtomicBool,
    /// SynDRM hat sequencer grid (128 steps).
    hat_sequencer_grid: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM hat sequencer current step.
    hat_sequencer_step: AtomicI32,
    /// SynDRM hat sequencer phase in samples.
    hat_sequencer_phase: AtomicU32,
    /// SynDRM hat oscillator phase (0..1).
    hat_phase: AtomicU32,
    /// SynDRM hat inharmonic oscillator phases (0..1).
    hat_phases: Arc<[AtomicU32; 6]>,
    /// SynDRM hat modulator phases (0..1).
    hat_mod_phases: Arc<[AtomicU32; 6]>,
    /// SynDRM hat amplitude envelope (0..1).
    hat_env: AtomicU32,
    /// SynDRM hat attack remaining samples.
    hat_attack_remaining: AtomicU32,
    /// SynDRM hat internal highpass filter state (x prev).
    hat_hp_x_prev: AtomicU32,
    /// SynDRM hat internal highpass filter state (y prev).
    hat_hp_y_prev: AtomicU32,
    /// SynDRM perc1 pitch (normalized 0..1).
    perc1_pitch: AtomicU32,
    /// SynDRM perc1 decay (normalized 0..1).
    perc1_decay: AtomicU32,
    /// SynDRM perc1 tone (normalized 0..1).
    perc1_tone: AtomicU32,
    /// SynDRM perc1 drive (normalized 0..1).
    perc1_drive: AtomicU32,
    /// SynDRM perc1 output level (normalized 0..1).
    perc1_level: AtomicU32,
    /// SynDRM perc1 filter type (0 = Moog LP, 1 = LP, 2 = HP, 3 = BP).
    perc1_filter_type: AtomicU32,
    /// SynDRM perc1 filter cutoff (normalized 0..1).
    perc1_filter_cutoff: AtomicU32,
    /// SynDRM perc1 filter resonance (normalized 0..1).
    perc1_filter_resonance: AtomicU32,
    /// SynDRM perc1 filter pre-drive toggle.
    perc1_filter_pre_drive: AtomicBool,
    /// SynDRM perc1 cut group (0 = none, 1..14).
    perc1_cut_group: AtomicU32,
    /// SynDRM perc1 cut by group (0 = none, 1..14).
    perc1_cut_by: AtomicU32,
    /// SynDRM perc1 trigger probability (0..1).
    perc1_prob: AtomicU32,
    /// SynDRM perc1 lane enabled.
    perc1_lane_enabled: AtomicBool,
    /// SynDRM perc1 sequencer grid (128 steps).
    perc1_sequencer_grid: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM perc1 sequencer current step.
    perc1_sequencer_step: AtomicI32,
    /// SynDRM perc1 sequencer phase in samples.
    perc1_sequencer_phase: AtomicU32,
    /// SynDRM perc1 excitation remaining samples.
    perc1_attack_remaining: AtomicU32,
    /// SynDRM perc2 pitch (normalized 0..1).
    perc2_pitch: AtomicU32,
    /// SynDRM perc2 decay (normalized 0..1).
    perc2_decay: AtomicU32,
    /// SynDRM perc2 tone (normalized 0..1).
    perc2_tone: AtomicU32,
    /// SynDRM perc2 drive (normalized 0..1).
    perc2_drive: AtomicU32,
    /// SynDRM perc2 output level (normalized 0..1).
    perc2_level: AtomicU32,
    /// SynDRM perc2 filter type (0 = Moog LP, 1 = LP, 2 = HP, 3 = BP).
    perc2_filter_type: AtomicU32,
    /// SynDRM perc2 filter cutoff (normalized 0..1).
    perc2_filter_cutoff: AtomicU32,
    /// SynDRM perc2 filter resonance (normalized 0..1).
    perc2_filter_resonance: AtomicU32,
    /// SynDRM perc2 filter pre-drive toggle.
    perc2_filter_pre_drive: AtomicBool,
    /// SynDRM perc2 cut group (0 = none, 1..14).
    perc2_cut_group: AtomicU32,
    /// SynDRM perc2 cut by group (0 = none, 1..14).
    perc2_cut_by: AtomicU32,
    /// SynDRM perc2 trigger probability (0..1).
    perc2_prob: AtomicU32,
    /// SynDRM perc2 lane enabled.
    perc2_lane_enabled: AtomicBool,
    /// SynDRM perc2 sequencer grid (128 steps).
    perc2_sequencer_grid: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM perc2 sequencer current step.
    perc2_sequencer_step: AtomicI32,
    /// SynDRM perc2 sequencer phase in samples.
    perc2_sequencer_phase: AtomicU32,
    /// SynDRM perc2 envelope (0..1).
    perc2_env: AtomicU32,
    /// SynDRM perc2 carrier phase (0..1).
    perc2_carrier_phase: AtomicU32,
    /// SynDRM perc2 modulator phase (0..1).
    perc2_mod_phase: AtomicU32,
    /// SynDRM crash pitch (normalized 0..1).
    crash_pitch: AtomicU32,
    /// SynDRM crash decay (normalized 0..1).
    crash_decay: AtomicU32,
    /// SynDRM crash tone (normalized 0..1).
    crash_tone: AtomicU32,
    /// SynDRM crash drive (normalized 0..1).
    crash_drive: AtomicU32,
    /// SynDRM crash output level (normalized 0..1).
    crash_level: AtomicU32,
    /// SynDRM crash filter type (0 = Moog LP, 1 = LP, 2 = HP, 3 = BP).
    crash_filter_type: AtomicU32,
    /// SynDRM crash filter cutoff (normalized 0..1).
    crash_filter_cutoff: AtomicU32,
    /// SynDRM crash filter resonance (normalized 0..1).
    crash_filter_resonance: AtomicU32,
    /// SynDRM crash filter pre-drive toggle.
    crash_filter_pre_drive: AtomicBool,
    /// SynDRM crash cut group (0 = none, 1..14).
    crash_cut_group: AtomicU32,
    /// SynDRM crash cut by group (0 = none, 1..14).
    crash_cut_by: AtomicU32,
    /// SynDRM crash trigger probability (0..1).
    crash_prob: AtomicU32,
    /// SynDRM crash lane enabled.
    crash_lane_enabled: AtomicBool,
    /// SynDRM crash sequencer grid (128 steps).
    crash_sequencer_grid: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM crash sequencer current step.
    crash_sequencer_step: AtomicI32,
    /// SynDRM crash sequencer phase in samples.
    crash_sequencer_phase: AtomicU32,
    /// SynDRM crash oscillator phase (0..1).
    crash_phase: AtomicU32,
    /// SynDRM crash inharmonic oscillator phases (0..1).
    crash_phases: Arc<[AtomicU32; 6]>,
    /// SynDRM crash modulator phases (0..1).
    crash_mod_phases: Arc<[AtomicU32; 6]>,
    /// SynDRM crash amplitude envelope (0..1).
    crash_env: AtomicU32,
    /// SynDRM crash attack remaining samples.
    crash_attack_remaining: AtomicU32,
    /// SynDRM crash internal highpass filter state (x prev).
    crash_hp_x_prev: AtomicU32,
    /// SynDRM crash internal highpass filter state (y prev).
    crash_hp_y_prev: AtomicU32,
    /// SynDRM sample channel pitch (normalized 0..1).
    samp_pitch: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel attack (normalized 0..1).
    samp_attack: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel decay (normalized 0..1).
    samp_decay: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel drive (normalized 0..1).
    samp_drive: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel output level (normalized 0..1).
    samp_level: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel filter type (0 = Moog LP, 1 = LP, 2 = HP, 3 = BP).
    samp_filter_type: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel filter cutoff (normalized 0..1).
    samp_filter_cutoff: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel filter resonance (normalized 0..1).
    samp_filter_resonance: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel filter pre-drive toggle.
    samp_filter_pre_drive: [AtomicBool; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel cut group (0 = none, 1..14).
    samp_cut_group: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel cut by group (0 = none, 1..14).
    samp_cut_by: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel trigger probability (0..1).
    samp_prob: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel lane enabled.
    samp_lane_enabled: [AtomicBool; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel sequencer grid (128 steps).
    samp_sequencer_grid: [Arc<[AtomicBool; SYNDRM_STEPS]>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel sequencer current step.
    samp_sequencer_step: [AtomicI32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel sequencer phase in samples.
    samp_sequencer_phase: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel playback position (samples).
    samp_playhead: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel envelope level.
    samp_env: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel attack remaining samples.
    samp_attack_remaining: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel decay remaining samples.
    samp_decay_remaining: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel loaded sample buffer.
    samp_samples: [Arc<Mutex<Option<Arc<Vec<Vec<f32>>>>>>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel sample path.
    samp_sample_path: [Arc<Mutex<Option<String>>>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel sample rate.
    samp_sample_rate: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample channel sample length in samples.
    samp_sample_len: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    kick_attack_remaining: AtomicU32,
    /// SynDRM sequencer page (0..7).
    syndrm_page: AtomicU32,
    /// SynDRM step editor lane (0 = kick, 1 = snare).
    syndrm_edit_lane: AtomicU32,
    /// SynDRM step editor step index (0..127).
    syndrm_edit_step: AtomicU32,
    /// SynDRM step hold mode (true = hold override).
    syndrm_step_hold: AtomicBool,
    /// SynDRM randomize amount (0..1).
    syndrm_randomize_amount: AtomicU32,
    /// SynDRM copy/paste buffer.
    syndrm_copy_buffer: Arc<Mutex<SynDRMCopyBuffer>>,
    /// FMMI copy/paste buffer.
    fmmi_copy_buffer: Arc<Mutex<FMMICopyBuffer>>,
    /// SynDRM RNG state for sequencer randomization.
    syndrm_rng_state: AtomicU32,
    /// SynDRM kick step override enabled.
    kick_step_override_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM kick step pitch override.
    kick_step_pitch: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM kick step decay override.
    kick_step_decay: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM kick step attack override.
    kick_step_attack: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM kick step drive override.
    kick_step_drive: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM kick step level override.
    kick_step_level: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM kick step filter type override.
    kick_step_filter_type: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM kick step filter cutoff override.
    kick_step_filter_cutoff: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM kick step filter resonance override.
    kick_step_filter_resonance: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM kick step retrig enabled.
    kick_step_retrig_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM kick step retrig division (2 or 4).
    kick_step_retrig_division: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM snare step override enabled.
    snare_step_override_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM snare step tone override.
    snare_step_tone: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM snare step decay override.
    snare_step_decay: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM snare step snappy override.
    snare_step_snappy: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM snare step attack override.
    snare_step_attack: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM snare step drive override.
    snare_step_drive: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM snare step level override.
    snare_step_level: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM snare step filter type override.
    snare_step_filter_type: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM snare step filter cutoff override.
    snare_step_filter_cutoff: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM snare step filter resonance override.
    snare_step_filter_resonance: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM snare step retrig enabled.
    snare_step_retrig_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM snare step retrig division (2 or 4).
    snare_step_retrig_division: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM clap step override enabled.
    clap_step_override_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM clap step pitch override.
    clap_step_pitch: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM clap step decay override.
    clap_step_decay: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM clap step tone override.
    clap_step_tone: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM clap step drive override.
    clap_step_drive: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM clap step level override.
    clap_step_level: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM clap step filter type override.
    clap_step_filter_type: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM clap step filter cutoff override.
    clap_step_filter_cutoff: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM clap step filter resonance override.
    clap_step_filter_resonance: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM clap step retrig enabled.
    clap_step_retrig_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM clap step retrig division (2 or 4).
    clap_step_retrig_division: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM hat step override enabled.
    hat_step_override_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM hat step pitch override.
    hat_step_pitch: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM hat step decay override.
    hat_step_decay: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM hat step tone override.
    hat_step_tone: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM hat step drive override.
    hat_step_drive: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM hat step level override.
    hat_step_level: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM hat step filter type override.
    hat_step_filter_type: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM hat step filter cutoff override.
    hat_step_filter_cutoff: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM hat step filter resonance override.
    hat_step_filter_resonance: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM hat step retrig enabled.
    hat_step_retrig_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM hat step retrig division (2 or 4).
    hat_step_retrig_division: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc1 step override enabled.
    perc1_step_override_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM perc1 step pitch override.
    perc1_step_pitch: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc1 step decay override.
    perc1_step_decay: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc1 step tone override.
    perc1_step_tone: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc1 step drive override.
    perc1_step_drive: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc1 step level override.
    perc1_step_level: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc1 step filter type override.
    perc1_step_filter_type: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc1 step filter cutoff override.
    perc1_step_filter_cutoff: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc1 step filter resonance override.
    perc1_step_filter_resonance: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc1 step retrig enabled.
    perc1_step_retrig_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM perc1 step retrig division (2 or 4).
    perc1_step_retrig_division: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc2 step override enabled.
    perc2_step_override_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM perc2 step pitch override.
    perc2_step_pitch: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc2 step decay override.
    perc2_step_decay: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc2 step tone override.
    perc2_step_tone: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc2 step drive override.
    perc2_step_drive: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc2 step level override.
    perc2_step_level: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc2 step filter type override.
    perc2_step_filter_type: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc2 step filter cutoff override.
    perc2_step_filter_cutoff: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc2 step filter resonance override.
    perc2_step_filter_resonance: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM perc2 step retrig enabled.
    perc2_step_retrig_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM perc2 step retrig division (2 or 4).
    perc2_step_retrig_division: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM crash step override enabled.
    crash_step_override_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM crash step pitch override.
    crash_step_pitch: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM crash step decay override.
    crash_step_decay: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM crash step tone override.
    crash_step_tone: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM crash step drive override.
    crash_step_drive: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM crash step level override.
    crash_step_level: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM crash step filter type override.
    crash_step_filter_type: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM crash step filter cutoff override.
    crash_step_filter_cutoff: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM crash step filter resonance override.
    crash_step_filter_resonance: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM crash step retrig enabled.
    crash_step_retrig_enabled: Arc<[AtomicBool; SYNDRM_STEPS]>,
    /// SynDRM crash step retrig division (2 or 4).
    crash_step_retrig_division: Arc<[AtomicU32; SYNDRM_STEPS]>,
    /// SynDRM sample step override enabled.
    samp_step_override_enabled: [Arc<[AtomicBool; SYNDRM_STEPS]>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample step pitch override.
    samp_step_pitch: [Arc<[AtomicU32; SYNDRM_STEPS]>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample step attack override.
    samp_step_attack: [Arc<[AtomicU32; SYNDRM_STEPS]>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample step decay override.
    samp_step_decay: [Arc<[AtomicU32; SYNDRM_STEPS]>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample step drive override.
    samp_step_drive: [Arc<[AtomicU32; SYNDRM_STEPS]>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample step level override.
    samp_step_level: [Arc<[AtomicU32; SYNDRM_STEPS]>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample step filter type override.
    samp_step_filter_type: [Arc<[AtomicU32; SYNDRM_STEPS]>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample step filter cutoff override.
    samp_step_filter_cutoff: [Arc<[AtomicU32; SYNDRM_STEPS]>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample step filter resonance override.
    samp_step_filter_resonance: [Arc<[AtomicU32; SYNDRM_STEPS]>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample step retrig enabled.
    samp_step_retrig_enabled: [Arc<[AtomicBool; SYNDRM_STEPS]>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample step retrig division (2 or 4).
    samp_step_retrig_division: [Arc<[AtomicU32; SYNDRM_STEPS]>; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM kick retrig remaining count within step.
    kick_retrig_remaining: AtomicU32,
    /// SynDRM kick retrig timer in samples.
    kick_retrig_timer: AtomicU32,
    /// SynDRM snare retrig remaining count within step.
    snare_retrig_remaining: AtomicU32,
    /// SynDRM snare retrig timer in samples.
    snare_retrig_timer: AtomicU32,
    /// SynDRM clap retrig remaining count within step.
    clap_retrig_remaining: AtomicU32,
    /// SynDRM clap retrig timer in samples.
    clap_retrig_timer: AtomicU32,
    /// SynDRM hat retrig remaining count within step.
    hat_retrig_remaining: AtomicU32,
    /// SynDRM hat retrig timer in samples.
    hat_retrig_timer: AtomicU32,
    /// SynDRM perc1 retrig remaining count within step.
    perc1_retrig_remaining: AtomicU32,
    /// SynDRM perc1 retrig timer in samples.
    perc1_retrig_timer: AtomicU32,
    /// SynDRM perc2 retrig remaining count within step.
    perc2_retrig_remaining: AtomicU32,
    /// SynDRM perc2 retrig timer in samples.
    perc2_retrig_timer: AtomicU32,
    /// SynDRM crash retrig remaining count within step.
    crash_retrig_remaining: AtomicU32,
    /// SynDRM crash retrig timer in samples.
    crash_retrig_timer: AtomicU32,
    /// SynDRM sample retrig remaining count within step.
    samp_retrig_remaining: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// SynDRM sample retrig timer in samples.
    samp_retrig_timer: [AtomicU32; SYNDRM_SAMPLE_CHANNELS],
    /// FMMI carrier waveform (0 = sine, 1 = triangle, 2 = saw, 3 = square).
    fmmi_car_wave: AtomicU32,
    /// FMMI carrier frequency (Hz).
    fmmi_car_freq: AtomicU32,
    /// FMMI carrier detune (cents).
    fmmi_car_detune: AtomicU32,
    /// FMMI modulator waveform (0 = sine, 1 = triangle, 2 = saw, 3 = square).
    fmmi_mod_wave: AtomicU32,
    /// FMMI modulator mode (0 = Hz, 1 = ratio).
    fmmi_mod_mode: AtomicU32,
    /// FMMI modulator value (Hz or ratio).
    fmmi_mod_value: AtomicU32,
    /// FMMI modulator detune (cents).
    fmmi_mod_detune: AtomicU32,
    /// FMMI modulation index (Hz).
    fmmi_index: AtomicU32,
    /// FMMI feedback amount (Hz).
    fmmi_feedback: AtomicU32,
    /// FMMI drive amount (0..1).
    fmmi_drive: AtomicU32,
    /// FMMI output level.
    fmmi_out_level: AtomicU32,
    /// FMMI amp envelope attack (0..127 UI value).
    fmmi_amp_attack: AtomicU32,
    /// FMMI amp envelope decay (0..127 UI value).
    fmmi_amp_decay: AtomicU32,
    /// FMMI amp envelope sustain (0..127 UI value).
    fmmi_amp_sustain: AtomicU32,
    /// FMMI amp envelope release (0..127 UI value).
    fmmi_amp_release: AtomicU32,
    /// FMMI default gate length in ms (-1 = step length).
    fmmi_gate_length: AtomicU32,
    /// FMMI sequencer note trigger probability (0..1).
    fmmi_prob: AtomicU32,
    /// FMMI poly mode enabled.
    fmmi_poly_enabled: AtomicBool,
    /// FMMI sequencer grid (128 steps).
    fmmi_sequencer_grid: Arc<[AtomicBool; FMMI_STEPS]>,
    /// FMMI sequencer current step.
    fmmi_sequencer_step: AtomicI32,
    /// FMMI sequencer phase in samples.
    fmmi_sequencer_phase: AtomicU32,
    /// FMMI sequencer page (0..7).
    fmmi_page: AtomicU32,
    /// FMMI step editor step index (0..127).
    fmmi_edit_step: AtomicU32,
    /// FMMI RNG state.
    fmmi_rng_state: AtomicU32,
    /// FMMI per-step note (MIDI note, -1 = global).
    fmmi_step_note: Arc<[AtomicI32; FMMI_STEPS]>,
    /// FMMI per-step carrier wave (-1 = global, 0..3 override).
    fmmi_step_car_wave: Arc<[AtomicI32; FMMI_STEPS]>,
    /// FMMI per-step mod wave (-1 = global, 0..3 override).
    fmmi_step_mod_wave: Arc<[AtomicI32; FMMI_STEPS]>,
    /// FMMI per-step mod mode (-1 = global, 0 Hz, 1 ratio).
    fmmi_step_mod_mode: Arc<[AtomicI32; FMMI_STEPS]>,
    /// FMMI per-step carrier frequency (-1 = global).
    fmmi_step_car_freq: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI per-step carrier detune (-1 = global).
    fmmi_step_car_detune: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI per-step mod value (-1 = global).
    fmmi_step_mod_value: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI per-step mod detune (-1 = global).
    fmmi_step_mod_detune: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI per-step index (-1 = global).
    fmmi_step_index: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI per-step feedback (-1 = global).
    fmmi_step_feedback: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI per-step drive (-1 = global).
    fmmi_step_drive: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI per-step output level (-1 = global).
    fmmi_step_out_level: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI per-step amp attack (-1 = global).
    fmmi_step_amp_attack: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI per-step amp decay (-1 = global).
    fmmi_step_amp_decay: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI per-step amp sustain (-1 = global).
    fmmi_step_amp_sustain: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI per-step amp release (-1 = global).
    fmmi_step_amp_release: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI per-step gate length in ms (-1 = global).
    fmmi_step_gate_length: Arc<[AtomicU32; FMMI_STEPS]>,
    /// FMMI randomize toggles per step parameter.
    fmmi_rand_note_enabled: AtomicBool,
    fmmi_rand_car_wave_enabled: AtomicBool,
    fmmi_rand_mod_wave_enabled: AtomicBool,
    fmmi_rand_mod_mode_enabled: AtomicBool,
    fmmi_rand_car_freq_enabled: AtomicBool,
    fmmi_rand_car_detune_enabled: AtomicBool,
    fmmi_rand_mod_value_enabled: AtomicBool,
    fmmi_rand_mod_detune_enabled: AtomicBool,
    fmmi_rand_index_enabled: AtomicBool,
    fmmi_rand_feedback_enabled: AtomicBool,
    fmmi_rand_drive_enabled: AtomicBool,
    fmmi_rand_out_level_enabled: AtomicBool,
    fmmi_rand_amp_attack_enabled: AtomicBool,
    fmmi_rand_amp_decay_enabled: AtomicBool,
    fmmi_rand_amp_sustain_enabled: AtomicBool,
    fmmi_rand_amp_release_enabled: AtomicBool,
    fmmi_rand_gate_length_enabled: AtomicBool,
    /// FMMI randomize amount (0..1).
    fmmi_randomize_amount: AtomicU32,
    /// FMMI randomize steps amount (0..1).
    fmmi_randomize_steps_amount: AtomicU32,
    /// FMMI scale index for note randomization/highlight.
    fmmi_scale_index: AtomicU32,
    /// FMMI keybed trigger note (MIDI).
    fmmi_keybed_note: AtomicI32,
    /// FMMI keybed trigger flag.
    fmmi_keybed_trigger: AtomicBool,
    /// FMMI current carrier frequency (Hz).
    fmmi_current_car_freq: AtomicU32,
    /// FMMI current carrier detune.
    fmmi_current_car_detune: AtomicU32,
    /// FMMI current mod value (Hz or ratio).
    fmmi_current_mod_value: AtomicU32,
    /// FMMI current mod detune.
    fmmi_current_mod_detune: AtomicU32,
    /// FMMI current index.
    fmmi_current_index: AtomicU32,
    /// FMMI current feedback.
    fmmi_current_feedback: AtomicU32,
    /// FMMI current drive.
    fmmi_current_drive: AtomicU32,
    /// FMMI current output level.
    fmmi_current_out_level: AtomicU32,
    /// FMMI carrier oscillator phase.
    fmmi_car_phase: AtomicU32,
    /// FMMI modulator oscillator phase.
    fmmi_mod_phase: AtomicU32,
    /// FMMI gate envelope level.
    fmmi_gate_level: AtomicU32,
    /// FMMI gate envelope stage (0 idle, 1 attack, 2 decay, 3 sustain, 4 release).
    fmmi_gate_stage: AtomicU32,
    /// FMMI gate envelope position in samples.
    fmmi_gate_pos: AtomicU32,
    /// FMMI gate hold remaining samples.
    fmmi_gate_hold: AtomicU32,
    /// FMMI last carrier sample (for feedback).
    fmmi_last_carrier: AtomicU32,
    /// MonoMI oscillator waveforms (0 = sine, 1 = triangle, 2 = saw, 3 = square/PWM).
    monomi_osc_wave: [AtomicU32; 3],
    /// MonoMI oscillator octaves (0=8', 1=16', 2=32').
    monomi_osc_octave: [AtomicU32; 3],
    /// MonoMI oscillator detune (cents).
    monomi_osc_detune: [AtomicU32; 3],
    /// MonoMI oscillator mix (0..1).
    monomi_osc_mix: [AtomicU32; 3],
    /// MonoMI oscillator PWM (0.05..0.95).
    monomi_osc_pwm: [AtomicU32; 3],
    /// MonoMI filter cutoff (Hz).
    monomi_cutoff: AtomicU32,
    /// MonoMI filter resonance (Q).
    monomi_resonance: AtomicU32,
    /// MonoMI filter morph (0..1).
    monomi_filter_morph: AtomicU32,
    /// MonoMI filter mode (0=LP24,1=LP12,2=HP).
    monomi_filter_mode: AtomicU32,
    /// MonoMI output volume.
    monomi_volume: AtomicU32,
    /// MonoMI amp envelope attack (steps).
    monomi_amp_attack: AtomicU32,
    /// MonoMI amp envelope decay (steps).
    monomi_amp_decay: AtomicU32,
    /// MonoMI amp envelope sustain (steps 0..128).
    monomi_amp_sustain: AtomicU32,
    /// MonoMI amp envelope release (steps).
    monomi_amp_release: AtomicU32,
    /// MonoMI filter envelope attack (steps).
    monomi_filter_attack: AtomicU32,
    /// MonoMI filter envelope decay (steps).
    monomi_filter_decay: AtomicU32,
    /// MonoMI filter envelope sustain (steps).
    monomi_filter_sustain: AtomicU32,
    /// MonoMI filter envelope release (steps).
    monomi_filter_release: AtomicU32,
    /// MonoMI filter envelope intensity (octaves).
    monomi_filter_intensity: AtomicU32,
    /// MonoMI filter envelope polarity (-1 or 1).
    monomi_filter_polarity: AtomicU32,
    /// MonoMI filter saturation amount (0..1).
    monomi_filter_saturation: AtomicU32,
    /// MonoMI filter saturation env follower amount (0..1).
    monomi_filter_sat_env: AtomicU32,
    /// MonoMI filter saturation placement (true=pre-filter, false=post-filter).
    monomi_filter_sat_pre: AtomicBool,
    /// MonoMI mix compressor mode (0=gentle,1=hard,2=limiter).
    monomi_mix_comp_mode: AtomicU32,
    /// MonoMI glide (ms).
    monomi_glide: AtomicU32,
    /// MonoMI sequencer note trigger probability (0..1).
    monomi_prob: AtomicU32,
    /// MonoMI scale index for randomization/highlight.
    monomi_scale_index: AtomicU32,
    /// MonoMI keybed trigger note (MIDI).
    monomi_keybed_note: AtomicI32,
    /// MonoMI keybed trigger flag.
    monomi_keybed_trigger: AtomicBool,
    /// MonoMI LFO shapes.
    monomi_lfo_shape: [AtomicU32; 3],
    /// MonoMI LFO targets.
    monomi_lfo_target: [AtomicU32; 3],
    /// MonoMI LFO amounts (0..1).
    monomi_lfo_amount: [AtomicU32; 3],
    /// MonoMI LFO rate (Hz).
    monomi_lfo_rate: [AtomicU32; 3],
    /// MonoMI LFO sync to BPM.
    monomi_lfo_sync: [AtomicBool; 3],
    /// MonoMI LFO step divisions (1..128).
    monomi_lfo_steps: [AtomicU32; 3],
    /// MonoMI sequencer grid.
    monomi_sequencer_grid: Arc<[AtomicBool; MONOMI_STEPS]>,
    /// MonoMI sequencer current step.
    monomi_sequencer_step: AtomicI32,
    /// MonoMI sequencer phase in samples.
    monomi_sequencer_phase: AtomicU32,
    /// MonoMI sequencer page.
    monomi_page: AtomicU32,
    /// MonoMI step editor index.
    monomi_edit_step: AtomicU32,
    /// MonoMI RNG state.
    monomi_rng_state: AtomicU32,
    /// MonoMI per-step note (MIDI note, -1 = scale).
    monomi_step_note: Arc<[AtomicI32; MONOMI_STEPS]>,
    /// MonoMI per-step cutoff (-1 = global).
    monomi_step_cutoff: Arc<[AtomicU32; MONOMI_STEPS]>,
    /// MonoMI per-step resonance (-1 = global).
    monomi_step_resonance: Arc<[AtomicU32; MONOMI_STEPS]>,
    /// MonoMI per-step amp attack (-1 = global).
    monomi_step_env_attack: Arc<[AtomicU32; MONOMI_STEPS]>,
    /// MonoMI per-step amp decay (-1 = global).
    monomi_step_env_decay: Arc<[AtomicU32; MONOMI_STEPS]>,
    /// MonoMI per-step amp sustain (-1 = global).
    monomi_step_env_sustain: Arc<[AtomicU32; MONOMI_STEPS]>,
    /// MonoMI per-step amp release (-1 = global).
    monomi_step_env_release: Arc<[AtomicU32; MONOMI_STEPS]>,
    /// MonoMI per-step gate length in steps (-1 = global).
    monomi_step_gate: Arc<[AtomicU32; MONOMI_STEPS]>,
    /// MonoMI per-step filter morph (-1 = global).
    monomi_step_filter_morph: Arc<[AtomicU32; MONOMI_STEPS]>,
    /// MonoMI per-step glide (ms) (-1 = global).
    monomi_step_glide: Arc<[AtomicU32; MONOMI_STEPS]>,
    /// MonoMI per-step osc mixes (-1 = global).
    monomi_step_osc_mix: [Arc<[AtomicU32; MONOMI_STEPS]>; 3],
    /// MonoMI per-step osc detune (-1 = global).
    monomi_step_osc_detune: [Arc<[AtomicU32; MONOMI_STEPS]>; 3],
    /// MonoMI per-step osc PWM (-1 = global).
    monomi_step_osc_pwm: [Arc<[AtomicU32; MONOMI_STEPS]>; 3],
    /// MonoMI randomize toggles per step parameter.
    monomi_rand_cutoff: AtomicBool,
    monomi_rand_resonance: AtomicBool,
    monomi_rand_env_attack: AtomicBool,
    monomi_rand_env_decay: AtomicBool,
    monomi_rand_env_sustain: AtomicBool,
    monomi_rand_env_release: AtomicBool,
    monomi_rand_gate: AtomicBool,
    monomi_rand_filter_morph: AtomicBool,
    monomi_rand_glide: AtomicBool,
    monomi_rand_osc_mix: [AtomicBool; 3],
    monomi_rand_osc_detune: [AtomicBool; 3],
    monomi_rand_osc_pwm: [AtomicBool; 3],
    /// MonoMI randomize amount (0..1).
    monomi_randomize_amount: AtomicU32,
    /// Void Seed base frequency.
    void_base_freq: AtomicU32,
    /// Smoothed void base frequency.
    void_base_freq_smooth: AtomicU32,
    /// Void Seed chaos depth (X).
    void_chaos_depth: AtomicU32,
    /// Smoothed void chaos depth.
    void_chaos_depth_smooth: AtomicU32,
    /// Void Seed entropy (Y).
    void_entropy: AtomicU32,
    /// Smoothed void entropy.
    void_entropy_smooth: AtomicU32,
    /// Whether the void seed engine is enabled and active.
    void_enabled: AtomicBool,
    /// Void Seed feedback.
    void_feedback: AtomicU32,
    /// Smoothed void feedback.
    void_feedback_smooth: AtomicU32,
    /// Void Seed diffusion (wet).
    void_diffusion: AtomicU32,
    /// Smoothed void diffusion.
    void_diffusion_smooth: AtomicU32,
    /// Void Seed modulation rate.
    void_mod_rate: AtomicU32,
    /// Smoothed void modulation rate.
    void_mod_rate_smooth: AtomicU32,
    /// Void Seed level.
    void_level: AtomicU32,
    /// Smoothed void level.
    void_level_smooth: AtomicU32,
    /// Void Seed pan (0..1).
    void_pan: AtomicU32,
    /// Smoothed void pan.
    void_pan_smooth: AtomicU32,
    /// Void Seed stereo width (0..1).
    void_width: AtomicU32,
    /// Smoothed void stereo width.
    void_width_smooth: AtomicU32,
    /// Void Seed moog filter cutoff (0..1).
    void_filter_cutoff: AtomicU32,
    /// Smoothed void filter cutoff.
    void_filter_cutoff_smooth: AtomicU32,
    /// Void Seed moog filter resonance (0..1).
    void_filter_resonance: AtomicU32,
    /// Smoothed void filter resonance.
    void_filter_resonance_smooth: AtomicU32,
    /// Void Seed overdrive amount (0..1).
    void_drive: AtomicU32,
    /// Smoothed void drive.
    void_drive_smooth: AtomicU32,
    /// Void Seed filter pre-drive toggle.
    void_filter_pre_drive: AtomicBool,
    /// Void Seed close decay time in seconds.
    void_close_decay: AtomicU32,
    /// Void Seed oscillator phases.
    void_osc_phases: [AtomicU32; 12],
    /// Void Seed detune LFO phases.
    void_lfo_phases: [AtomicU32; 12],
    /// Void Seed detune LFO frequencies.
    void_lfo_freqs: [AtomicU32; 12],
    /// Void Seed chaos LFO phase.
    void_lfo_chaos_phase: AtomicU32,
    /// Void Seed filter state v1.
    void_filter_v1: [AtomicU32; 2],
    /// Void Seed filter state v2.
    void_filter_v2: [AtomicU32; 2],
    /// Void Seed internal gain (for ramping).
    void_internal_gain: AtomicU32,
    /// Void Seed delay buffer.
    void_delay_buffer: Arc<Mutex<[Vec<f32>; 2]>>,
    /// Void Seed delay write position.
    void_delay_write_pos: AtomicU32,
    /// Engine type loaded for this track (0 = none, 1 = tape, 2 = animate, 3 = syndrm, 4 = voidseed, 5 = fmmi).
    engine_type: AtomicU32,
    /// Logs one debug line per playback start to confirm audio thread output.
    debug_logged: AtomicBool,
    /// Sample rate of the loaded/recorded audio.
    sample_rate: AtomicU32,
}

impl Default for Track {
    fn default() -> Self {
        Self {
            samples: Arc::new(Mutex::new(vec![vec![]; 2])),
            sample_path: Arc::new(Mutex::new(None)),
            waveform_summary: Arc::new(Mutex::new(vec![0.0; WAVEFORM_SUMMARY_SIZE])),
            video_cache: Arc::new(Mutex::new(None)),
            video_enabled: AtomicBool::new(false),
            video_width: AtomicU32::new(0),
            video_height: AtomicU32::new(0),
            video_fps: AtomicU32::new(0.0f32.to_bits()),
            video_cache_id: AtomicU32::new(0),
            is_recording: AtomicBool::new(false),
            pending_play: AtomicBool::new(false),
            pending_record: AtomicBool::new(false),
            count_in_remaining: AtomicU32::new(0),
            record_pos: AtomicU32::new(0.0f32.to_bits()),
            is_playing: AtomicBool::new(false),
            play_pos: AtomicU32::new(0.0f32.to_bits()),
            level: AtomicU32::new(1.0f32.to_bits()),
            level_smooth: AtomicU32::new(1.0f32.to_bits()),
            meter_left: AtomicU32::new(0.0f32.to_bits()),
            meter_right: AtomicU32::new(0.0f32.to_bits()),
            is_muted: AtomicBool::new(false),
            tape_speed: AtomicU32::new(1.0f32.to_bits()),
            tape_speed_smooth: AtomicU32::new(1.0f32.to_bits()),
            tape_tempo: AtomicU32::new(120.0f32.to_bits()),
            tape_rate_mode: AtomicU32::new(0),
            tape_sync_requested: AtomicBool::new(false),
            tape_rotate: AtomicU32::new(0.0f32.to_bits()),
            tape_rotate_smooth: AtomicU32::new(0.0f32.to_bits()),
            tape_glide: AtomicU32::new(0.0f32.to_bits()),
            tape_glide_smooth: AtomicU32::new(0.0f32.to_bits()),
            tape_sos: AtomicU32::new(0.0f32.to_bits()),
            tape_reverse: AtomicBool::new(false),
            tape_freeze: AtomicBool::new(false),
            tape_keylock: AtomicBool::new(false),
            keylock_phase: AtomicU32::new(0.0f32.to_bits()),
            keylock_grain_a: AtomicU32::new(0.0f32.to_bits()),
            keylock_grain_b: AtomicU32::new(0.0f32.to_bits()),
            tape_monitor: AtomicBool::new(false),
            tape_overdub: AtomicBool::new(false),
            loop_start: AtomicU32::new(0.0f32.to_bits()),
            loop_start_smooth: AtomicU32::new(0.0f32.to_bits()),
            trigger_start: AtomicU32::new(0.0f32.to_bits()),
            loop_length: AtomicU32::new(1.0f32.to_bits()),
            loop_length_smooth: AtomicU32::new(1.0f32.to_bits()),
            loop_xfade: AtomicU32::new(0.0f32.to_bits()),
            loop_xfade_smooth: AtomicU32::new(0.0f32.to_bits()),
            loop_enabled: AtomicBool::new(true),
            loop_mode: AtomicU32::new(0),
            loop_dir: AtomicI32::new(1),
            loop_start_last: AtomicU32::new(0),
            granular_type: AtomicU32::new(0),
            mosaic_pitch: AtomicU32::new(0.0f32.to_bits()),
            mosaic_pitch_smooth: AtomicU32::new(0.0f32.to_bits()),
            mosaic_rate: AtomicU32::new(0.5f32.to_bits()),
            mosaic_rate_smooth: AtomicU32::new(0.5f32.to_bits()),
            mosaic_size: AtomicU32::new(0.5f32.to_bits()),
            mosaic_size_smooth: AtomicU32::new(0.5f32.to_bits()),
            mosaic_contour: AtomicU32::new(0.5f32.to_bits()),
            mosaic_contour_smooth: AtomicU32::new(0.5f32.to_bits()),
            mosaic_warp: AtomicU32::new(0.0f32.to_bits()),
            mosaic_warp_smooth: AtomicU32::new(0.0f32.to_bits()),
            mosaic_spray: AtomicU32::new(0.0f32.to_bits()),
            mosaic_spray_smooth: AtomicU32::new(0.0f32.to_bits()),
            mosaic_pattern: AtomicU32::new(0.0f32.to_bits()),
            mosaic_pattern_smooth: AtomicU32::new(0.0f32.to_bits()),
            mosaic_wet: AtomicU32::new(0.0f32.to_bits()),
            mosaic_wet_smooth: AtomicU32::new(0.0f32.to_bits()),
            mosaic_spatial: AtomicU32::new(0.0f32.to_bits()),
            mosaic_spatial_smooth: AtomicU32::new(0.0f32.to_bits()),
            mosaic_detune: AtomicU32::new(0.0f32.to_bits()),
            mosaic_detune_smooth: AtomicU32::new(0.0f32.to_bits()),
            mosaic_rand_rate: AtomicU32::new(0.0f32.to_bits()),
            mosaic_rand_rate_smooth: AtomicU32::new(0.0f32.to_bits()),
            mosaic_rand_size: AtomicU32::new(0.0f32.to_bits()),
            mosaic_rand_size_smooth: AtomicU32::new(0.0f32.to_bits()),
            mosaic_sos: AtomicU32::new(0.0f32.to_bits()),
            mosaic_sos_smooth: AtomicU32::new(0.0f32.to_bits()),
            mosaic_post_gain: AtomicU32::new(0.5f32.to_bits()),
            mosaic_post_gain_smooth: AtomicU32::new(0.5f32.to_bits()),
            mosaic_enabled: AtomicBool::new(true),
            mosaic_loop_lock: AtomicBool::new(false),
            mosaic_buffer: Arc::new(Mutex::new(vec![
                vec![0.0; MOSAIC_BUFFER_SAMPLES];
                MOSAIC_BUFFER_CHANNELS
            ])),
            mosaic_write_pos: AtomicU32::new(0),
            mosaic_grain_active: std::array::from_fn(|_| AtomicBool::new(false)),
            mosaic_grain_start: std::array::from_fn(|_| AtomicU32::new(0)),
            mosaic_grain_pos: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            mosaic_grain_len: std::array::from_fn(|_| AtomicU32::new(0)),
            mosaic_grain_pitch: std::array::from_fn(|_| AtomicU32::new(1.0f32.to_bits())),
            mosaic_grain_pan: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            mosaic_spawn_phase: AtomicU32::new(0.0f32.to_bits()),
            mosaic_last_grain_start: AtomicU32::new(0),
            mosaic_last_grain_len: AtomicU32::new(0),
            mosaic_rng_state: AtomicU32::new(0x1234_abcd),
            mosaic_grain_markers: std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits())),
            mosaic_grain_marker_write: AtomicU32::new(0),
            ring_cutoff: AtomicU32::new(0.5f32.to_bits()),
            ring_cutoff_smooth: AtomicU32::new(0.5f32.to_bits()),
            ring_resonance: AtomicU32::new(0.0f32.to_bits()),
            ring_resonance_smooth: AtomicU32::new(0.0f32.to_bits()),
            ring_decay: AtomicU32::new(0.0f32.to_bits()),
            ring_decay_smooth: AtomicU32::new(0.0f32.to_bits()),
            ring_decay_mode: AtomicU32::new(0),
            ring_pitch: AtomicU32::new(0.5f32.to_bits()),
            ring_pitch_smooth: AtomicU32::new(0.5f32.to_bits()),
            ring_tone: AtomicU32::new(0.5f32.to_bits()),
            ring_tone_smooth: AtomicU32::new(0.5f32.to_bits()),
            ring_tilt: AtomicU32::new(0.5f32.to_bits()),
            ring_tilt_smooth: AtomicU32::new(0.5f32.to_bits()),
            ring_slope: AtomicU32::new(0.5f32.to_bits()),
            ring_slope_smooth: AtomicU32::new(0.5f32.to_bits()),
            ring_wet: AtomicU32::new(0.0f32.to_bits()),
            ring_wet_smooth: AtomicU32::new(0.0f32.to_bits()),
            ring_detune: AtomicU32::new(0.0f32.to_bits()),
            ring_detune_smooth: AtomicU32::new(0.0f32.to_bits()),
            ring_waves: AtomicU32::new(0.0f32.to_bits()),
            ring_waves_smooth: AtomicU32::new(0.0f32.to_bits()),
            ring_waves_rate: AtomicU32::new(0.5f32.to_bits()),
            ring_waves_rate_smooth: AtomicU32::new(0.5f32.to_bits()),
            ring_waves_rate_mode: AtomicU32::new(0),
            ring_waves_phase: AtomicU32::new(0.0f32.to_bits()),
            ring_noise: AtomicU32::new(0.0f32.to_bits()),
            ring_noise_smooth: AtomicU32::new(0.0f32.to_bits()),
            ring_noise_rate: AtomicU32::new(0.5f32.to_bits()),
            ring_noise_rate_smooth: AtomicU32::new(0.5f32.to_bits()),
            ring_noise_rate_mode: AtomicU32::new(0),
            ring_noise_phase: AtomicU32::new(0.0f32.to_bits()),
            ring_noise_value: AtomicU32::new(0.0f32.to_bits()),
            ring_noise_rng: AtomicU32::new(0x1357_2468),
            ring_scale: AtomicU32::new(0),
            ring_detune_phase: AtomicU32::new(0.0f32.to_bits()),
            ring_enabled: AtomicBool::new(false),
            ring_pre_post: AtomicBool::new(true),
            ring_low: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            ring_band: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            g8_enabled: AtomicBool::new(false),
            g8_rate_index: AtomicU32::new(0),
            g8_steps: Arc::new(std::array::from_fn(|_| AtomicU32::new(1.0f32.to_bits()))),
            g8_gain_smooth: AtomicU32::new(1.0f32.to_bits()),
            modul8_enabled: AtomicBool::new(false),
            modul8_wave: std::array::from_fn(|_| AtomicU32::new(0)),
            modul8_rate: std::array::from_fn(|_| AtomicU32::new(1.0f32.to_bits())),
            modul8_sync: std::array::from_fn(|_| AtomicBool::new(true)),
            modul8_division: std::array::from_fn(|_| AtomicU32::new(0)),
            modul8_amount: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            modul8_bias: std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits())),
            modul8_target: std::array::from_fn(|_| AtomicU32::new(0)),
            modul8_phase: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            modul8_snh: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            modul8_base_value: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            modul8_base_target: std::array::from_fn(|_| AtomicU32::new(u32::MAX)),
            modul8_rng_state: AtomicU32::new(0x89ab_cdef),
            texture_enabled: AtomicBool::new(false),
            texture_gate: AtomicBool::new(false),
            texture_drive: AtomicU32::new(0.0f32.to_bits()),
            texture_drive_smooth: AtomicU32::new(0.0f32.to_bits()),
            texture_compress: AtomicU32::new(0.0f32.to_bits()),
            texture_compress_smooth: AtomicU32::new(0.0f32.to_bits()),
            texture_crush: AtomicU32::new(0.0f32.to_bits()),
            texture_crush_smooth: AtomicU32::new(0.0f32.to_bits()),
            texture_tilt: AtomicU32::new(0.5f32.to_bits()),
            texture_tilt_smooth: AtomicU32::new(0.5f32.to_bits()),
            texture_noise: AtomicU32::new(0.0f32.to_bits()),
            texture_noise_smooth: AtomicU32::new(0.0f32.to_bits()),
            texture_noise_decay: AtomicU32::new(0.0f32.to_bits()),
            texture_noise_decay_smooth: AtomicU32::new(0.0f32.to_bits()),
            texture_noise_color: AtomicU32::new(0.5f32.to_bits()),
            texture_noise_color_smooth: AtomicU32::new(0.5f32.to_bits()),
            texture_wet: AtomicU32::new(0.0f32.to_bits()),
            texture_wet_smooth: AtomicU32::new(0.0f32.to_bits()),
            texture_post_gain: AtomicU32::new(0.5f32.to_bits()),
            texture_post_gain_smooth: AtomicU32::new(0.5f32.to_bits()),
            texture_noise_env: AtomicU32::new(0.0f32.to_bits()),
            texture_noise_rng: AtomicU32::new(0x2468_1357),
            texture_noise_lp: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            texture_tilt_lp: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            texture_crush_phase: AtomicU32::new(0),
            texture_crush_hold: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            reflect_enabled: AtomicBool::new(false),
            reflect_freeze: AtomicBool::new(false),
            reflect_delay: AtomicU32::new(0.0f32.to_bits()),
            reflect_delay_smooth: AtomicU32::new(0.0f32.to_bits()),
            reflect_time: AtomicU32::new(0.5f32.to_bits()),
            reflect_time_smooth: AtomicU32::new(0.5f32.to_bits()),
            reflect_time_mode: AtomicU32::new(0),
            reflect_reverb: AtomicU32::new(0.0f32.to_bits()),
            reflect_reverb_smooth: AtomicU32::new(0.0f32.to_bits()),
            reflect_size: AtomicU32::new(0.5f32.to_bits()),
            reflect_size_smooth: AtomicU32::new(0.5f32.to_bits()),
            reflect_feedback: AtomicU32::new(0.0f32.to_bits()),
            reflect_feedback_smooth: AtomicU32::new(0.0f32.to_bits()),
            reflect_spread: AtomicU32::new(0.0f32.to_bits()),
            reflect_spread_smooth: AtomicU32::new(0.0f32.to_bits()),
            reflect_damp: AtomicU32::new(0.5f32.to_bits()),
            reflect_damp_smooth: AtomicU32::new(0.5f32.to_bits()),
            reflect_decay: AtomicU32::new(0.5f32.to_bits()),
            reflect_decay_smooth: AtomicU32::new(0.5f32.to_bits()),
            reflect_post_gain: AtomicU32::new(0.5f32.to_bits()),
            reflect_post_gain_smooth: AtomicU32::new(0.5f32.to_bits()),
            reflect_clear: AtomicBool::new(false),
            reflect_delay_buffer: Arc::new(Mutex::new([
                vec![0.0; REFLECT_MAX_DELAY_SAMPLES],
                vec![0.0; REFLECT_MAX_DELAY_SAMPLES],
            ])),
            reflect_delay_write_pos: AtomicU32::new(0),
            reflect_reverb_comb_buffers: Arc::new(Mutex::new(std::array::from_fn(|_| {
                std::array::from_fn(|i| {
                    vec![0.0; reflect_comb_max_len(REFLECT_REVERB_COMB_BASE[i])]
                })
            }))),
            reflect_reverb_comb_pos: std::array::from_fn(|_| AtomicU32::new(0)),
            reflect_reverb_ap_buffers: Arc::new(Mutex::new(std::array::from_fn(|_| {
                std::array::from_fn(|i| {
                    vec![0.0; reflect_ap_max_len(REFLECT_REVERB_AP_BASE[i])]
                })
            }))),
            reflect_reverb_ap_pos: std::array::from_fn(|_| AtomicU32::new(0)),
            reflect_damp_state_delay: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            reflect_damp_state_reverb: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_slot_types: std::array::from_fn(|_| AtomicU32::new(0)),
            animate_slot_wavetables: std::array::from_fn(|_| AtomicU32::new(0)),
            animate_slot_samples: std::array::from_fn(|_| AtomicU32::new(0)),
            animate_slot_coarse: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_slot_fine: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_slot_level: std::array::from_fn(|_| AtomicU32::new(1.0f32.to_bits())),
            animate_slot_level_smooth: std::array::from_fn(|_| AtomicU32::new(1.0f32.to_bits())),
            animate_slot_pan: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_slot_pan_smooth: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_slot_wt_lfo_amount: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_slot_wt_lfo_shape: std::array::from_fn(|_| AtomicU32::new(0)),
            animate_slot_wt_lfo_rate: std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits())),
            animate_slot_wt_lfo_sync: std::array::from_fn(|_| AtomicBool::new(false)),
            animate_slot_wt_lfo_division: std::array::from_fn(|_| AtomicU32::new(0)),
            animate_slot_wt_lfo_phase: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_slot_wt_lfo_snh: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_slot_sample_start: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_slot_loop_start: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_slot_loop_end: std::array::from_fn(|_| AtomicU32::new(1.0f32.to_bits())),
            animate_slot_filter_type: std::array::from_fn(|_| AtomicU32::new(0)),
            animate_slot_filter_cutoff: std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits())),
            animate_slot_filter_resonance: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_slot_filter_v1: std::array::from_fn(|_| {
                std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))
            }),
            animate_slot_filter_v2: std::array::from_fn(|_| {
                std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))
            }),
            animate_slot_filter_v1_stage2: std::array::from_fn(|_| {
                std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))
            }),
            animate_slot_filter_v2_stage2: std::array::from_fn(|_| {
                std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))
            }),
            animate_vector_x: AtomicU32::new(0.5f32.to_bits()),
            animate_vector_y: AtomicU32::new(0.5f32.to_bits()),
            animate_vector_x_smooth: AtomicU32::new(0.5f32.to_bits()),
            animate_vector_y_smooth: AtomicU32::new(0.5f32.to_bits()),
            animate_lfo_x_waveform: AtomicU32::new(0),
            animate_lfo_x_sync: AtomicBool::new(false),
            animate_lfo_x_division: AtomicU32::new(0),
            animate_lfo_x_rate: AtomicU32::new(0.5f32.to_bits()),
            animate_lfo_x_amount: AtomicU32::new(0.0f32.to_bits()),
            animate_lfo_x_phase: AtomicU32::new(0.0f32.to_bits()),
            animate_lfo_x_snh: AtomicU32::new(0.0f32.to_bits()),
            animate_lfo_y_waveform: AtomicU32::new(0),
            animate_lfo_y_sync: AtomicBool::new(false),
            animate_lfo_y_division: AtomicU32::new(0),
            animate_lfo_y_rate: AtomicU32::new(0.5f32.to_bits()),
            animate_lfo_y_amount: AtomicU32::new(0.0f32.to_bits()),
            animate_lfo_y_phase: AtomicU32::new(0.0f32.to_bits()),
            animate_lfo_y_snh: AtomicU32::new(0.0f32.to_bits()),
            animate_lfo_rng_state: AtomicU32::new(0x2468_ace1),
            animate_sequencer_grid: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            animate_sequencer_step: AtomicI32::new(-1),
            animate_sequencer_phase: AtomicU32::new(0),
            animate_slot_phases: std::array::from_fn(|_| std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            animate_slot_sample_pos: std::array::from_fn(|_| std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            animate_amp_stage: std::array::from_fn(|_| AtomicU32::new(0)),
            animate_amp_level: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_slot_a_attack: AtomicU32::new(0.01f32.to_bits()),
            animate_slot_a_decay: AtomicU32::new(0.1f32.to_bits()),
            animate_slot_a_sustain: AtomicU32::new(0.8f32.to_bits()),
            animate_slot_a_release: AtomicU32::new(0.3f32.to_bits()),
            animate_slot_a_amp_stage: std::array::from_fn(|_| AtomicU32::new(0)),
            animate_slot_a_amp_level: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_keybed_note: AtomicI32::new(60),
            animate_keybed_trigger: AtomicBool::new(false),
            animate_keybed_hold: AtomicBool::new(false),
            animate_keybed_amp_stage: AtomicU32::new(0),
            animate_keybed_amp_level: AtomicU32::new(0.0f32.to_bits()),
            animate_keybed_slot_a_amp_stage: AtomicU32::new(0),
            animate_keybed_slot_a_amp_level: AtomicU32::new(0.0f32.to_bits()),
            animate_keybed_slot_phases: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_keybed_slot_sample_pos: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_keybed_filter_v1: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_keybed_filter_v2: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_keybed_filter_v1_stage2: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            animate_keybed_filter_v2_stage2: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            kick_pitch: AtomicU32::new(0.5f32.to_bits()),
            kick_decay: AtomicU32::new(0.5f32.to_bits()),
            kick_attack: AtomicU32::new(0.0f32.to_bits()),
            kick_pitch_env_amount: AtomicU32::new(0.0f32.to_bits()),
            kick_drive: AtomicU32::new(0.0f32.to_bits()),
            kick_level: AtomicU32::new(1.0f32.to_bits()),
            kick_filter_type: AtomicU32::new(0),
            kick_filter_cutoff: AtomicU32::new(0.6f32.to_bits()),
            kick_filter_resonance: AtomicU32::new(0.2f32.to_bits()),
            kick_filter_pre_drive: AtomicBool::new(true),
            kick_cut_group: AtomicU32::new(0),
            kick_cut_by: AtomicU32::new(0),
            kick_prob: AtomicU32::new(1.0f32.to_bits()),
            kick_lane_enabled: AtomicBool::new(true),
            kick_sequencer_grid: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            kick_sequencer_step: AtomicI32::new(-1),
            kick_sequencer_phase: AtomicU32::new(0),
            kick_phase: AtomicU32::new(0.0f32.to_bits()),
            kick_env: AtomicU32::new(0.0f32.to_bits()),
            kick_pitch_env: AtomicU32::new(0.0f32.to_bits()),
            kick_attack_remaining: AtomicU32::new(0),
            snare_tone: AtomicU32::new(0.5f32.to_bits()),
            snare_decay: AtomicU32::new(0.4f32.to_bits()),
            snare_snappy: AtomicU32::new(0.6f32.to_bits()),
            snare_attack: AtomicU32::new(0.0f32.to_bits()),
            snare_drive: AtomicU32::new(0.0f32.to_bits()),
            snare_level: AtomicU32::new(0.8f32.to_bits()),
            snare_filter_type: AtomicU32::new(0),
            snare_filter_cutoff: AtomicU32::new(0.6f32.to_bits()),
            snare_filter_resonance: AtomicU32::new(0.2f32.to_bits()),
            snare_filter_pre_drive: AtomicBool::new(true),
            snare_cut_group: AtomicU32::new(0),
            snare_cut_by: AtomicU32::new(0),
            snare_prob: AtomicU32::new(1.0f32.to_bits()),
            snare_lane_enabled: AtomicBool::new(true),
            snare_sequencer_grid: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            snare_sequencer_step: AtomicI32::new(-1),
            snare_sequencer_phase: AtomicU32::new(0),
            snare_phase: AtomicU32::new(0.0f32.to_bits()),
            snare_env: AtomicU32::new(0.0f32.to_bits()),
            snare_noise_env: AtomicU32::new(0.0f32.to_bits()),
            snare_attack_remaining: AtomicU32::new(0),
            snare_noise_rng: AtomicU32::new(0xdead_beef),
            clap_pitch: AtomicU32::new(0.5f32.to_bits()),
            clap_decay: AtomicU32::new(0.25f32.to_bits()),
            clap_tone: AtomicU32::new(0.5f32.to_bits()),
            clap_drive: AtomicU32::new(0.0f32.to_bits()),
            clap_level: AtomicU32::new(0.8f32.to_bits()),
            clap_filter_type: AtomicU32::new(0),
            clap_filter_cutoff: AtomicU32::new(0.6f32.to_bits()),
            clap_filter_resonance: AtomicU32::new(0.2f32.to_bits()),
            clap_filter_pre_drive: AtomicBool::new(true),
            clap_cut_group: AtomicU32::new(0),
            clap_cut_by: AtomicU32::new(0),
            clap_prob: AtomicU32::new(1.0f32.to_bits()),
            clap_lane_enabled: AtomicBool::new(true),
            clap_sequencer_grid: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            clap_sequencer_step: AtomicI32::new(-1),
            clap_sequencer_phase: AtomicU32::new(0),
            clap_env: AtomicU32::new(0.0f32.to_bits()),
            clap_phase: AtomicU32::new(0),
            hat_pitch: AtomicU32::new(0.664f32.to_bits()),
            hat_decay: AtomicU32::new(0.048f32.to_bits()),
            hat_tone: AtomicU32::new(0.5f32.to_bits()),
            hat_drive: AtomicU32::new(0.0f32.to_bits()),
            hat_level: AtomicU32::new(1.0f32.to_bits()),
            hat_filter_type: AtomicU32::new(1),
            hat_filter_cutoff: AtomicU32::new(1.0f32.to_bits()),
            hat_filter_resonance: AtomicU32::new(0.667f32.to_bits()),
            hat_filter_pre_drive: AtomicBool::new(true),
            hat_cut_group: AtomicU32::new(0),
            hat_cut_by: AtomicU32::new(0),
            hat_prob: AtomicU32::new(1.0f32.to_bits()),
            hat_lane_enabled: AtomicBool::new(true),
            hat_sequencer_grid: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            hat_sequencer_step: AtomicI32::new(-1),
            hat_sequencer_phase: AtomicU32::new(0),
            hat_phase: AtomicU32::new(0.0f32.to_bits()),
            hat_phases: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            hat_mod_phases: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            hat_env: AtomicU32::new(0.0f32.to_bits()),
            hat_attack_remaining: AtomicU32::new(0),
            hat_hp_x_prev: AtomicU32::new(0.0f32.to_bits()),
            hat_hp_y_prev: AtomicU32::new(0.0f32.to_bits()),
            perc1_pitch: AtomicU32::new(0.5f32.to_bits()),
            perc1_decay: AtomicU32::new(0.5f32.to_bits()),
            perc1_tone: AtomicU32::new(0.5f32.to_bits()),
            perc1_drive: AtomicU32::new(0.0f32.to_bits()),
            perc1_level: AtomicU32::new(0.8f32.to_bits()),
            perc1_filter_type: AtomicU32::new(1),
            perc1_filter_cutoff: AtomicU32::new(0.7f32.to_bits()),
            perc1_filter_resonance: AtomicU32::new(0.2f32.to_bits()),
            perc1_filter_pre_drive: AtomicBool::new(true),
            perc1_cut_group: AtomicU32::new(0),
            perc1_cut_by: AtomicU32::new(0),
            perc1_prob: AtomicU32::new(1.0f32.to_bits()),
            perc1_lane_enabled: AtomicBool::new(true),
            perc1_sequencer_grid: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            perc1_sequencer_step: AtomicI32::new(-1),
            perc1_sequencer_phase: AtomicU32::new(0),
            perc1_attack_remaining: AtomicU32::new(0),
            perc2_pitch: AtomicU32::new(0.5f32.to_bits()),
            perc2_decay: AtomicU32::new(0.25f32.to_bits()),
            perc2_tone: AtomicU32::new(0.65f32.to_bits()),
            perc2_drive: AtomicU32::new(0.0f32.to_bits()),
            perc2_level: AtomicU32::new(0.8f32.to_bits()),
            perc2_filter_type: AtomicU32::new(0),
            perc2_filter_cutoff: AtomicU32::new(0.6f32.to_bits()),
            perc2_filter_resonance: AtomicU32::new(0.2f32.to_bits()),
            perc2_filter_pre_drive: AtomicBool::new(true),
            perc2_cut_group: AtomicU32::new(0),
            perc2_cut_by: AtomicU32::new(0),
            perc2_prob: AtomicU32::new(1.0f32.to_bits()),
            perc2_lane_enabled: AtomicBool::new(true),
            perc2_sequencer_grid: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            perc2_sequencer_step: AtomicI32::new(-1),
            perc2_sequencer_phase: AtomicU32::new(0),
            perc2_env: AtomicU32::new(0.0f32.to_bits()),
            perc2_carrier_phase: AtomicU32::new(0.0f32.to_bits()),
            perc2_mod_phase: AtomicU32::new(0.0f32.to_bits()),
            crash_pitch: AtomicU32::new(0.7f32.to_bits()),
            crash_decay: AtomicU32::new(0.7f32.to_bits()),
            crash_tone: AtomicU32::new(0.5f32.to_bits()),
            crash_drive: AtomicU32::new(0.0f32.to_bits()),
            crash_level: AtomicU32::new(0.8f32.to_bits()),
            crash_filter_type: AtomicU32::new(1),
            crash_filter_cutoff: AtomicU32::new(1.0f32.to_bits()),
            crash_filter_resonance: AtomicU32::new(0.5f32.to_bits()),
            crash_filter_pre_drive: AtomicBool::new(true),
            crash_cut_group: AtomicU32::new(0),
            crash_cut_by: AtomicU32::new(0),
            crash_prob: AtomicU32::new(1.0f32.to_bits()),
            crash_lane_enabled: AtomicBool::new(true),
            crash_sequencer_grid: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            crash_sequencer_step: AtomicI32::new(-1),
            crash_sequencer_phase: AtomicU32::new(0),
            crash_phase: AtomicU32::new(0.0f32.to_bits()),
            crash_phases: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            crash_mod_phases: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            crash_env: AtomicU32::new(0.0f32.to_bits()),
            crash_attack_remaining: AtomicU32::new(0),
            crash_hp_x_prev: AtomicU32::new(0.0f32.to_bits()),
            crash_hp_y_prev: AtomicU32::new(0.0f32.to_bits()),
            samp_pitch: std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits())),
            samp_attack: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            samp_decay: std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits())),
            samp_drive: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            samp_level: std::array::from_fn(|_| AtomicU32::new(0.8f32.to_bits())),
            samp_filter_type: std::array::from_fn(|_| AtomicU32::new(0)),
            samp_filter_cutoff: std::array::from_fn(|_| AtomicU32::new(0.7f32.to_bits())),
            samp_filter_resonance: std::array::from_fn(|_| AtomicU32::new(0.2f32.to_bits())),
            samp_filter_pre_drive: std::array::from_fn(|_| AtomicBool::new(true)),
            samp_cut_group: std::array::from_fn(|_| AtomicU32::new(0)),
            samp_cut_by: std::array::from_fn(|_| AtomicU32::new(0)),
            samp_prob: std::array::from_fn(|_| AtomicU32::new(1.0f32.to_bits())),
            samp_lane_enabled: std::array::from_fn(|_| AtomicBool::new(true)),
            samp_sequencer_grid: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicBool::new(false)))
            }),
            samp_sequencer_step: std::array::from_fn(|_| AtomicI32::new(-1)),
            samp_sequencer_phase: std::array::from_fn(|_| AtomicU32::new(0)),
            samp_playhead: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            samp_env: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            samp_attack_remaining: std::array::from_fn(|_| AtomicU32::new(0)),
            samp_decay_remaining: std::array::from_fn(|_| AtomicU32::new(0)),
            samp_samples: std::array::from_fn(|_| Arc::new(Mutex::new(None))),
            samp_sample_path: std::array::from_fn(|_| Arc::new(Mutex::new(None))),
            samp_sample_rate: std::array::from_fn(|_| AtomicU32::new(0)),
            samp_sample_len: std::array::from_fn(|_| AtomicU32::new(0)),
            syndrm_page: AtomicU32::new(0),
            syndrm_edit_lane: AtomicU32::new(0),
            syndrm_edit_step: AtomicU32::new(0),
            syndrm_step_hold: AtomicBool::new(false),
            syndrm_randomize_amount: AtomicU32::new(1.0f32.to_bits()),
            syndrm_copy_buffer: Arc::new(Mutex::new(SynDRMCopyBuffer::new())),
            fmmi_copy_buffer: Arc::new(Mutex::new(FMMICopyBuffer::new())),
            syndrm_rng_state: AtomicU32::new(0x81c3_5f27),
            kick_step_override_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            kick_step_pitch: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits()))),
            kick_step_decay: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits()))),
            kick_step_attack: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            kick_step_drive: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            kick_step_level: Arc::new(std::array::from_fn(|_| AtomicU32::new(1.0f32.to_bits()))),
            kick_step_filter_type: Arc::new(std::array::from_fn(|_| AtomicU32::new(0))),
            kick_step_filter_cutoff: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.6f32.to_bits()))),
            kick_step_filter_resonance: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.2f32.to_bits()))),
            kick_step_retrig_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            kick_step_retrig_division: Arc::new(std::array::from_fn(|_| AtomicU32::new(2))),
            snare_step_override_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            snare_step_tone: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits()))),
            snare_step_decay: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.4f32.to_bits()))),
            snare_step_snappy: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.6f32.to_bits()))),
            snare_step_attack: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            snare_step_drive: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            snare_step_level: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.8f32.to_bits()))),
            snare_step_filter_type: Arc::new(std::array::from_fn(|_| AtomicU32::new(0))),
            snare_step_filter_cutoff: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.6f32.to_bits()))),
            snare_step_filter_resonance: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.2f32.to_bits()))),
            snare_step_retrig_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            snare_step_retrig_division: Arc::new(std::array::from_fn(|_| AtomicU32::new(2))),
            clap_step_override_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            clap_step_pitch: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits()))),
            clap_step_decay: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.25f32.to_bits()))),
            clap_step_tone: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits()))),
            clap_step_drive: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            clap_step_level: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.8f32.to_bits()))),
            clap_step_filter_type: Arc::new(std::array::from_fn(|_| AtomicU32::new(0))),
            clap_step_filter_cutoff: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.6f32.to_bits()))),
            clap_step_filter_resonance: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.2f32.to_bits()))),
            clap_step_retrig_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            clap_step_retrig_division: Arc::new(std::array::from_fn(|_| AtomicU32::new(2))),
            hat_step_override_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            hat_step_pitch: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.664f32.to_bits()))),
            hat_step_decay: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.048f32.to_bits()))),
            hat_step_tone: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits()))),
            hat_step_drive: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            hat_step_level: Arc::new(std::array::from_fn(|_| AtomicU32::new(1.0f32.to_bits()))),
            hat_step_filter_type: Arc::new(std::array::from_fn(|_| AtomicU32::new(1))),
            hat_step_filter_cutoff: Arc::new(std::array::from_fn(|_| AtomicU32::new(1.0f32.to_bits()))),
            hat_step_filter_resonance: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.667f32.to_bits()))),
            hat_step_retrig_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            hat_step_retrig_division: Arc::new(std::array::from_fn(|_| AtomicU32::new(2))),
            perc1_step_override_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            perc1_step_pitch: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits()))),
            perc1_step_decay: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits()))),
            perc1_step_tone: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits()))),
            perc1_step_drive: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            perc1_step_level: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.8f32.to_bits()))),
            perc1_step_filter_type: Arc::new(std::array::from_fn(|_| AtomicU32::new(1))),
            perc1_step_filter_cutoff: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.7f32.to_bits()))),
            perc1_step_filter_resonance: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.2f32.to_bits()))),
            perc1_step_retrig_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            perc1_step_retrig_division: Arc::new(std::array::from_fn(|_| AtomicU32::new(2))),
            perc2_step_override_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            perc2_step_pitch: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits()))),
            perc2_step_decay: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.25f32.to_bits()))),
            perc2_step_tone: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.65f32.to_bits()))),
            perc2_step_drive: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            perc2_step_level: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.8f32.to_bits()))),
            perc2_step_filter_type: Arc::new(std::array::from_fn(|_| AtomicU32::new(0))),
            perc2_step_filter_cutoff: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.6f32.to_bits()))),
            perc2_step_filter_resonance: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.2f32.to_bits()))),
            perc2_step_retrig_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            perc2_step_retrig_division: Arc::new(std::array::from_fn(|_| AtomicU32::new(2))),
            crash_step_override_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            crash_step_pitch: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.7f32.to_bits()))),
            crash_step_decay: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.7f32.to_bits()))),
            crash_step_tone: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits()))),
            crash_step_drive: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits()))),
            crash_step_level: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.8f32.to_bits()))),
            crash_step_filter_type: Arc::new(std::array::from_fn(|_| AtomicU32::new(1))),
            crash_step_filter_cutoff: Arc::new(std::array::from_fn(|_| AtomicU32::new(1.0f32.to_bits()))),
            crash_step_filter_resonance: Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits()))),
            crash_step_retrig_enabled: Arc::new(std::array::from_fn(|_| AtomicBool::new(false))),
            crash_step_retrig_division: Arc::new(std::array::from_fn(|_| AtomicU32::new(2))),
            samp_step_override_enabled: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicBool::new(false)))
            }),
            samp_step_pitch: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits())))
            }),
            samp_step_attack: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())))
            }),
            samp_step_decay: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits())))
            }),
            samp_step_drive: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())))
            }),
            samp_step_level: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicU32::new(0.8f32.to_bits())))
            }),
            samp_step_filter_type: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicU32::new(0)))
            }),
            samp_step_filter_cutoff: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicU32::new(0.7f32.to_bits())))
            }),
            samp_step_filter_resonance: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicU32::new(0.2f32.to_bits())))
            }),
            samp_step_retrig_enabled: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicBool::new(false)))
            }),
            samp_step_retrig_division: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicU32::new(2)))
            }),
            kick_retrig_remaining: AtomicU32::new(0),
            kick_retrig_timer: AtomicU32::new(0.0f32.to_bits()),
            snare_retrig_remaining: AtomicU32::new(0),
            snare_retrig_timer: AtomicU32::new(0.0f32.to_bits()),
            clap_retrig_remaining: AtomicU32::new(0),
            clap_retrig_timer: AtomicU32::new(0.0f32.to_bits()),
            hat_retrig_remaining: AtomicU32::new(0),
            hat_retrig_timer: AtomicU32::new(0.0f32.to_bits()),
            perc1_retrig_remaining: AtomicU32::new(0),
            perc1_retrig_timer: AtomicU32::new(0.0f32.to_bits()),
            perc2_retrig_remaining: AtomicU32::new(0),
            perc2_retrig_timer: AtomicU32::new(0.0f32.to_bits()),
            crash_retrig_remaining: AtomicU32::new(0),
            crash_retrig_timer: AtomicU32::new(0.0f32.to_bits()),
            samp_retrig_remaining: std::array::from_fn(|_| AtomicU32::new(0)),
            samp_retrig_timer: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            fmmi_car_wave: AtomicU32::new(0),
            fmmi_car_freq: AtomicU32::new(220.0f32.to_bits()),
            fmmi_car_detune: AtomicU32::new(0.0f32.to_bits()),
            fmmi_mod_wave: AtomicU32::new(0),
            fmmi_mod_mode: AtomicU32::new(0),
            fmmi_mod_value: AtomicU32::new(220.0f32.to_bits()),
            fmmi_mod_detune: AtomicU32::new(0.0f32.to_bits()),
            fmmi_index: AtomicU32::new(800.0f32.to_bits()),
            fmmi_feedback: AtomicU32::new(0.0f32.to_bits()),
            fmmi_drive: AtomicU32::new(0.0f32.to_bits()),
            fmmi_out_level: AtomicU32::new(0.5f32.to_bits()),
            fmmi_amp_attack: AtomicU32::new(63.0f32.to_bits()),
            fmmi_amp_decay: AtomicU32::new(63.0f32.to_bits()),
            fmmi_amp_sustain: AtomicU32::new(63.0f32.to_bits()),
            fmmi_amp_release: AtomicU32::new(63.0f32.to_bits()),
            fmmi_gate_length: AtomicU32::new((-1.0f32).to_bits()),
            fmmi_prob: AtomicU32::new(1.0f32.to_bits()),
            fmmi_poly_enabled: AtomicBool::new(false),
            fmmi_sequencer_grid: Arc::new(std::array::from_fn(|idx| {
                AtomicBool::new(idx < FMMI_PAGE_SIZE && idx % 2 == 0)
            })),
            fmmi_sequencer_step: AtomicI32::new(-1),
            fmmi_sequencer_phase: AtomicU32::new(0),
            fmmi_page: AtomicU32::new(0),
            fmmi_edit_step: AtomicU32::new(0),
            fmmi_rng_state: AtomicU32::new(0x5a17_c9e3),
            fmmi_step_note: Arc::new(std::array::from_fn(|_| AtomicI32::new(-1))),
            fmmi_step_car_wave: Arc::new(std::array::from_fn(|_| AtomicI32::new(-1))),
            fmmi_step_mod_wave: Arc::new(std::array::from_fn(|_| AtomicI32::new(-1))),
            fmmi_step_mod_mode: Arc::new(std::array::from_fn(|_| AtomicI32::new(-1))),
            fmmi_step_car_freq: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_step_car_detune: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_step_mod_value: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_step_mod_detune: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_step_index: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_step_feedback: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_step_drive: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_step_out_level: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_step_amp_attack: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_step_amp_decay: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_step_amp_sustain: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_step_amp_release: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_step_gate_length: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            fmmi_rand_note_enabled: AtomicBool::new(true),
            fmmi_rand_car_wave_enabled: AtomicBool::new(true),
            fmmi_rand_mod_wave_enabled: AtomicBool::new(true),
            fmmi_rand_mod_mode_enabled: AtomicBool::new(true),
            fmmi_rand_car_freq_enabled: AtomicBool::new(true),
            fmmi_rand_car_detune_enabled: AtomicBool::new(true),
            fmmi_rand_mod_value_enabled: AtomicBool::new(true),
            fmmi_rand_mod_detune_enabled: AtomicBool::new(true),
            fmmi_rand_index_enabled: AtomicBool::new(true),
            fmmi_rand_feedback_enabled: AtomicBool::new(true),
            fmmi_rand_drive_enabled: AtomicBool::new(true),
            fmmi_rand_out_level_enabled: AtomicBool::new(true),
            fmmi_rand_amp_attack_enabled: AtomicBool::new(true),
            fmmi_rand_amp_decay_enabled: AtomicBool::new(true),
            fmmi_rand_amp_sustain_enabled: AtomicBool::new(true),
            fmmi_rand_amp_release_enabled: AtomicBool::new(true),
            fmmi_rand_gate_length_enabled: AtomicBool::new(true),
            fmmi_randomize_amount: AtomicU32::new(1.0f32.to_bits()),
            fmmi_randomize_steps_amount: AtomicU32::new(1.0f32.to_bits()),
            fmmi_scale_index: AtomicU32::new(0),
            fmmi_keybed_note: AtomicI32::new(60),
            fmmi_keybed_trigger: AtomicBool::new(false),
            fmmi_current_car_freq: AtomicU32::new(220.0f32.to_bits()),
            fmmi_current_car_detune: AtomicU32::new(0.0f32.to_bits()),
            fmmi_current_mod_value: AtomicU32::new(220.0f32.to_bits()),
            fmmi_current_mod_detune: AtomicU32::new(0.0f32.to_bits()),
            fmmi_current_index: AtomicU32::new(800.0f32.to_bits()),
            fmmi_current_feedback: AtomicU32::new(0.0f32.to_bits()),
            fmmi_current_drive: AtomicU32::new(0.0f32.to_bits()),
            fmmi_current_out_level: AtomicU32::new(0.5f32.to_bits()),
            fmmi_car_phase: AtomicU32::new(0.0f32.to_bits()),
            fmmi_mod_phase: AtomicU32::new(0.0f32.to_bits()),
            fmmi_gate_level: AtomicU32::new(0.0f32.to_bits()),
            fmmi_gate_stage: AtomicU32::new(0),
            fmmi_gate_pos: AtomicU32::new(0),
            fmmi_gate_hold: AtomicU32::new(0),
            fmmi_last_carrier: AtomicU32::new(0.0f32.to_bits()),
            monomi_osc_wave: [
                AtomicU32::new(2),
                AtomicU32::new(3),
                AtomicU32::new(1),
            ],
            monomi_osc_octave: [
                AtomicU32::new(0),
                AtomicU32::new(1),
                AtomicU32::new(2),
            ],
            monomi_osc_detune: std::array::from_fn(|_| AtomicU32::new(0.0f32.to_bits())),
            monomi_osc_mix: std::array::from_fn(|_| AtomicU32::new(0.33f32.to_bits())),
            monomi_osc_pwm: std::array::from_fn(|_| AtomicU32::new(0.5f32.to_bits())),
            monomi_cutoff: AtomicU32::new(1200.0f32.to_bits()),
            monomi_resonance: AtomicU32::new(1.0f32.to_bits()),
            monomi_filter_morph: AtomicU32::new(0.0f32.to_bits()),
            monomi_filter_mode: AtomicU32::new(0),
            monomi_volume: AtomicU32::new(0.75f32.to_bits()),
            monomi_amp_attack: AtomicU32::new(4.0f32.to_bits()),
            monomi_amp_decay: AtomicU32::new(8.0f32.to_bits()),
            monomi_amp_sustain: AtomicU32::new(64.0f32.to_bits()),
            monomi_amp_release: AtomicU32::new(12.0f32.to_bits()),
            monomi_filter_attack: AtomicU32::new(4.0f32.to_bits()),
            monomi_filter_decay: AtomicU32::new(8.0f32.to_bits()),
            monomi_filter_sustain: AtomicU32::new(64.0f32.to_bits()),
            monomi_filter_release: AtomicU32::new(12.0f32.to_bits()),
            monomi_filter_intensity: AtomicU32::new(2.0f32.to_bits()),
            monomi_filter_polarity: AtomicU32::new(1.0f32.to_bits()),
            monomi_filter_saturation: AtomicU32::new(0.0f32.to_bits()),
            monomi_filter_sat_env: AtomicU32::new(0.0f32.to_bits()),
            monomi_filter_sat_pre: AtomicBool::new(false),
            monomi_mix_comp_mode: AtomicU32::new(0),
            monomi_glide: AtomicU32::new(0.0f32.to_bits()),
            monomi_prob: AtomicU32::new(1.0f32.to_bits()),
            monomi_scale_index: AtomicU32::new(0),
            monomi_keybed_note: AtomicI32::new(60),
            monomi_keybed_trigger: AtomicBool::new(false),
            monomi_lfo_shape: [AtomicU32::new(0), AtomicU32::new(1), AtomicU32::new(4)],
            monomi_lfo_target: [AtomicU32::new(0), AtomicU32::new(6), AtomicU32::new(5)],
            monomi_lfo_amount: [
                AtomicU32::new(0.0f32.to_bits()),
                AtomicU32::new(0.0f32.to_bits()),
                AtomicU32::new(0.0f32.to_bits()),
            ],
            monomi_lfo_rate: [
                AtomicU32::new(0.5f32.to_bits()),
                AtomicU32::new(0.25f32.to_bits()),
                AtomicU32::new(1.0f32.to_bits()),
            ],
            monomi_lfo_sync: [AtomicBool::new(true), AtomicBool::new(true), AtomicBool::new(false)],
            monomi_lfo_steps: [AtomicU32::new(4), AtomicU32::new(8), AtomicU32::new(4)],
            monomi_sequencer_grid: Arc::new(std::array::from_fn(|i| AtomicBool::new(i < MONOMI_PAGE_SIZE))),
            monomi_sequencer_step: AtomicI32::new(-1),
            monomi_sequencer_phase: AtomicU32::new(0),
            monomi_page: AtomicU32::new(0),
            monomi_edit_step: AtomicU32::new(0),
            monomi_rng_state: AtomicU32::new(0x91b5_4c3a),
            monomi_step_note: Arc::new(std::array::from_fn(|_| AtomicI32::new(-1))),
            monomi_step_cutoff: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            monomi_step_resonance: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            monomi_step_env_attack: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            monomi_step_env_decay: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            monomi_step_env_sustain: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            monomi_step_env_release: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            monomi_step_gate: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            monomi_step_filter_morph: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            monomi_step_glide: Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits()))),
            monomi_step_osc_mix: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits())))
            }),
            monomi_step_osc_detune: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits())))
            }),
            monomi_step_osc_pwm: std::array::from_fn(|_| {
                Arc::new(std::array::from_fn(|_| AtomicU32::new((-1.0f32).to_bits())))
            }),
            monomi_rand_cutoff: AtomicBool::new(true),
            monomi_rand_resonance: AtomicBool::new(true),
            monomi_rand_env_attack: AtomicBool::new(true),
            monomi_rand_env_decay: AtomicBool::new(true),
            monomi_rand_env_sustain: AtomicBool::new(true),
            monomi_rand_env_release: AtomicBool::new(true),
            monomi_rand_gate: AtomicBool::new(true),
            monomi_rand_filter_morph: AtomicBool::new(true),
            monomi_rand_glide: AtomicBool::new(true),
            monomi_rand_osc_mix: [AtomicBool::new(true), AtomicBool::new(true), AtomicBool::new(true)],
            monomi_rand_osc_detune: [AtomicBool::new(true), AtomicBool::new(true), AtomicBool::new(true)],
            monomi_rand_osc_pwm: [AtomicBool::new(true), AtomicBool::new(true), AtomicBool::new(true)],
            monomi_randomize_amount: AtomicU32::new(1.0f32.to_bits()),
            void_base_freq: AtomicU32::new(40.0f32.to_bits()),
            void_base_freq_smooth: AtomicU32::new(40.0f32.to_bits()),
            void_enabled: AtomicBool::new(false),
            void_chaos_depth: AtomicU32::new(0.5f32.to_bits()),
            void_chaos_depth_smooth: AtomicU32::new(0.5f32.to_bits()),
            void_entropy: AtomicU32::new(0.2f32.to_bits()),
            void_entropy_smooth: AtomicU32::new(0.2f32.to_bits()),
            void_feedback: AtomicU32::new(0.8f32.to_bits()),
            void_feedback_smooth: AtomicU32::new(0.8f32.to_bits()),
            void_diffusion: AtomicU32::new(0.5f32.to_bits()),
            void_diffusion_smooth: AtomicU32::new(0.5f32.to_bits()),
            void_mod_rate: AtomicU32::new(0.1f32.to_bits()),
            void_mod_rate_smooth: AtomicU32::new(0.1f32.to_bits()),
            void_level: AtomicU32::new(0.8f32.to_bits()),
            void_level_smooth: AtomicU32::new(0.8f32.to_bits()),
            void_pan: AtomicU32::new(0.5f32.to_bits()),
            void_pan_smooth: AtomicU32::new(0.5f32.to_bits()),
            void_width: AtomicU32::new(1.0f32.to_bits()),
            void_width_smooth: AtomicU32::new(1.0f32.to_bits()),
            void_close_decay: AtomicU32::new(4.0f32.to_bits()),
            void_filter_cutoff: AtomicU32::new(0.5f32.to_bits()),
            void_filter_cutoff_smooth: AtomicU32::new(0.5f32.to_bits()),
            void_filter_resonance: AtomicU32::new(0.2f32.to_bits()),
            void_filter_resonance_smooth: AtomicU32::new(0.2f32.to_bits()),
            void_drive: AtomicU32::new(0.0f32.to_bits()),
            void_drive_smooth: AtomicU32::new(0.0f32.to_bits()),
            void_filter_pre_drive: AtomicBool::new(true),
            void_osc_phases: Default::default(),
            void_lfo_phases: Default::default(),
            void_lfo_freqs: [
                AtomicU32::new(0.05f32.to_bits()),
                AtomicU32::new(0.12f32.to_bits()),
                AtomicU32::new(0.07f32.to_bits()),
                AtomicU32::new(0.15f32.to_bits()),
                AtomicU32::new(0.03f32.to_bits()),
                AtomicU32::new(0.18f32.to_bits()),
                AtomicU32::new(0.09f32.to_bits()),
                AtomicU32::new(0.11f32.to_bits()),
                AtomicU32::new(0.04f32.to_bits()),
                AtomicU32::new(0.14f32.to_bits()),
                AtomicU32::new(0.06f32.to_bits()),
                AtomicU32::new(0.17f32.to_bits()),
            ],
            void_lfo_chaos_phase: AtomicU32::new(0),
            void_filter_v1: Default::default(),
            void_filter_v2: Default::default(),
            void_internal_gain: AtomicU32::new(0.0f32.to_bits()),
            void_delay_buffer: Arc::new(Mutex::new([vec![0.0; 65536], vec![0.0; 65536]])),
            void_delay_write_pos: AtomicU32::new(0),
            engine_type: AtomicU32::new(0),
            debug_logged: AtomicBool::new(false),
            sample_rate: AtomicU32::new(44_100),
        }
    }
}

pub struct TLBX1 {
    params: Arc<TLBX1Params>,
    tracks: Arc<[Track; NUM_TRACKS]>,
    master_meters: Arc<MasterMeters>,
    visualizer: Arc<VisualizerState>,
    global_tempo: Arc<AtomicU32>,
    follow_host_tempo: Arc<AtomicBool>,
    metronome_enabled: Arc<AtomicBool>,
    metronome_count_in_ticks: Arc<AtomicU32>,
    metronome_count_in_playback: Arc<AtomicBool>,
    metronome_count_in_record: Arc<AtomicBool>,
    metronome_phase_samples: u32,
    metronome_click_remaining: u32,
    master_step_phase: f32,
    master_step_index: i32,
    master_step_count: i64,
    animate_library: Arc<AnimateLibrary>,
    master_fx: MasterFxState,
    sample_rate: AtomicU32,
    pending_project_params: Arc<Mutex<Option<PendingProjectParams>>>,
    track_buffer: Vec<Vec<f32>>,
    syndrm_dsp: [SynDRMDspState; NUM_TRACKS],
    animate_dsp: [AnimateDspState; NUM_TRACKS],
    void_dsp: [VoidSeedDspState; NUM_TRACKS],
    fmmi_dsp: [FmmiDspState; NUM_TRACKS],
    monomi_dsp: [MonomiDspState; NUM_TRACKS],
    last_host_playing: bool,
}

#[derive(Clone, Copy)]
struct FmmiVoiceState {
    active: bool,
    car_phase: f32,
    mod_phase: f32,
    gate_level: f32,
    gate_stage: u32,
    gate_pos: u32,
    gate_hold: u32,
    last_carrier: f32,
    car_wave: u32,
    car_freq: f32,
    car_detune: f32,
    mod_wave: u32,
    mod_mode: u32,
    mod_value: f32,
    mod_detune: f32,
    index: f32,
    feedback: f32,
    drive: f32,
    out_level: f32,
    amp_attack: f32,
    amp_decay: f32,
    amp_sustain: f32,
    amp_release: f32,
    gate_length: f32,
    attack_samples: u32,
    decay_samples: u32,
    release_samples: u32,
    sustain_level: f32,
    hold_samples: u32,
    last_trigger: u64,
}

impl Default for FmmiVoiceState {
    fn default() -> Self {
        Self {
            active: false,
            car_phase: 0.0,
            mod_phase: 0.0,
            gate_level: 0.0,
            gate_stage: 0,
            gate_pos: 0,
            gate_hold: 0,
            last_carrier: 0.0,
            car_wave: 0,
            car_freq: 220.0,
            car_detune: 0.0,
            mod_wave: 0,
            mod_mode: 0,
            mod_value: 220.0,
            mod_detune: 0.0,
            index: 800.0,
            feedback: 0.0,
            drive: 0.0,
            out_level: 0.5,
            amp_attack: 63.0,
            amp_decay: 63.0,
            amp_sustain: 63.0,
            amp_release: 63.0,
            gate_length: -1.0,
            attack_samples: 1,
            decay_samples: 1,
            release_samples: 1,
            sustain_level: 1.0,
            hold_samples: 0,
            last_trigger: 0,
        }
    }
}

struct FmmiDspState {
    voices: [FmmiVoiceState; FMMI_VOICES],
    voice_clock: u64,
}

impl FmmiDspState {
    fn new() -> Self {
        Self {
            voices: std::array::from_fn(|_| FmmiVoiceState::default()),
            voice_clock: 0,
        }
    }
}

struct MonomiDspState {
    sample_rate: f32,
    osc_phase: [f32; 3],
    lfo_phase: [f32; 3],
    lfo_sample_hold: [f32; 3],
    filter_lp: [Box<dyn AudioUnit>; 2],
    filter_hp: [Box<dyn AudioUnit>; 2],
    filter_moog: [Box<dyn AudioUnit>; 2],
    amp_stage: u32,
    amp_pos: u32,
    amp_hold: u32,
    amp_level: f32,
    amp_level_smooth: f32,
    amp_attack: u32,
    amp_decay: u32,
    amp_release: u32,
    amp_sustain: f32,
    filter_stage: u32,
    filter_pos: u32,
    filter_hold: u32,
    filter_level: f32,
    filter_attack: u32,
    filter_decay: u32,
    filter_release: u32,
    filter_sustain: f32,
    current_freq: f32,
    target_freq: f32,
    current_cutoff: f32,
    current_resonance: f32,
    current_morph: f32,
    current_filter_intensity: f32,
    current_filter_polarity: f32,
    current_glide: f32,
    current_osc_detune: [f32; 3],
    current_osc_mix: [f32; 3],
    current_osc_pwm: [f32; 3],
    current_amp_attack: f32,
    current_amp_decay: f32,
    current_amp_sustain: f32,
    current_amp_release: f32,
    current_filter_attack: f32,
    current_filter_decay: f32,
    current_filter_sustain: f32,
    current_filter_release: f32,
    current_gate_steps: f32,
    filter_sat_env: [f32; 2],
}

impl MonomiDspState {
    fn new() -> Self {
        Self {
            sample_rate: 0.0,
            osc_phase: [0.0; 3],
            lfo_phase: [0.0; 3],
            lfo_sample_hold: [0.0; 3],
            filter_lp: [Box::new(lowpass()), Box::new(lowpass())],
            filter_hp: [Box::new(highpass()), Box::new(highpass())],
            filter_moog: [Box::new(moog()), Box::new(moog())],
            amp_stage: 0,
            amp_pos: 0,
            amp_hold: 0,
            amp_level: 0.0,
            amp_level_smooth: 0.0,
            amp_attack: 1,
            amp_decay: 1,
            amp_release: 1,
            amp_sustain: 1.0,
            filter_stage: 0,
            filter_pos: 0,
            filter_hold: 0,
            filter_level: 0.0,
            filter_attack: 1,
            filter_decay: 1,
            filter_release: 1,
            filter_sustain: 1.0,
            current_freq: 220.0,
            target_freq: 220.0,
            current_cutoff: 1200.0,
            current_resonance: 1.0,
            current_morph: 0.0,
            current_filter_intensity: 2.0,
            current_filter_polarity: 1.0,
            current_glide: 0.0,
            current_osc_detune: [0.0; 3],
            current_osc_mix: [0.33; 3],
            current_osc_pwm: [0.5; 3],
            current_amp_attack: 4.0,
            current_amp_decay: 8.0,
            current_amp_sustain: 64.0,
            current_amp_release: 12.0,
            current_filter_attack: 4.0,
            current_filter_decay: 8.0,
            current_filter_sustain: 64.0,
            current_filter_release: 12.0,
            current_gate_steps: 1.0,
            filter_sat_env: [0.0; 2],
        }
    }
}

struct SynDRMDspState {
    sample_rate: f32,
    kick_osc: Box<dyn AudioUnit>,
    kick_drive: Box<dyn AudioUnit>,
    snare_osc: Box<dyn AudioUnit>,
    snare_noise: Box<dyn AudioUnit>,
    snare_drive: Box<dyn AudioUnit>,
    clap_noise: Box<dyn AudioUnit>,
    clap_drive: Box<dyn AudioUnit>,
    hat_drive: Box<dyn AudioUnit>,
    crash_drive: Box<dyn AudioUnit>,
    perc1_noise: Box<dyn AudioUnit>,
    perc1_drive: Box<dyn AudioUnit>,
    perc2_drive: Box<dyn AudioUnit>,
    kick_filter_moog: Box<dyn AudioUnit>,
    kick_filter_lp: Box<dyn AudioUnit>,
    kick_filter_hp: Box<dyn AudioUnit>,
    kick_filter_bp: Box<dyn AudioUnit>,
    snare_filter_moog: Box<dyn AudioUnit>,
    snare_filter_lp: Box<dyn AudioUnit>,
    snare_filter_hp: Box<dyn AudioUnit>,
    snare_filter_bp: Box<dyn AudioUnit>,
    clap_filter_moog: Box<dyn AudioUnit>,
    clap_filter_lp: Box<dyn AudioUnit>,
    clap_filter_hp: Box<dyn AudioUnit>,
    clap_filter_bp: Box<dyn AudioUnit>,
    hat_filter_moog: Box<dyn AudioUnit>,
    hat_filter_lp: Box<dyn AudioUnit>,
    hat_filter_hp: Box<dyn AudioUnit>,
    hat_filter_bp: Box<dyn AudioUnit>,
    crash_filter_moog: Box<dyn AudioUnit>,
    crash_filter_lp: Box<dyn AudioUnit>,
    crash_filter_hp: Box<dyn AudioUnit>,
    crash_filter_bp: Box<dyn AudioUnit>,
    perc1_filter_moog: Box<dyn AudioUnit>,
    perc1_filter_lp: Box<dyn AudioUnit>,
    perc1_filter_hp: Box<dyn AudioUnit>,
    perc1_filter_bp: Box<dyn AudioUnit>,
    perc2_filter_moog: Box<dyn AudioUnit>,
    perc2_filter_lp: Box<dyn AudioUnit>,
    perc2_filter_hp: Box<dyn AudioUnit>,
    perc2_filter_bp: Box<dyn AudioUnit>,
    samp_drive: [Box<dyn AudioUnit>; SYNDRM_SAMPLE_CHANNELS],
    samp_filter_moog: [Box<dyn AudioUnit>; SYNDRM_SAMPLE_CHANNELS],
    samp_filter_lp: [Box<dyn AudioUnit>; SYNDRM_SAMPLE_CHANNELS],
    samp_filter_hp: [Box<dyn AudioUnit>; SYNDRM_SAMPLE_CHANNELS],
    samp_filter_bp: [Box<dyn AudioUnit>; SYNDRM_SAMPLE_CHANNELS],
    perc1_karplus_line: Vec<f32>,
    perc1_karplus_pos: usize,
    perc1_karplus_delay: usize,
}

impl SynDRMDspState {
    fn new() -> Self {
        Self {
            sample_rate: 0.0,
            kick_osc: Box::new(sine()),
            kick_drive: Box::new(shape(Tanh(1.0))),
            snare_osc: Box::new(sine()),
            snare_noise: Box::new(noise()),
            snare_drive: Box::new(shape(Tanh(1.0))),
            clap_noise: Box::new(noise()),
            clap_drive: Box::new(shape(Tanh(1.0))),
            hat_drive: Box::new(shape(Tanh(1.0))),
            crash_drive: Box::new(shape(Tanh(1.0))),
            perc1_noise: Box::new(noise()),
            perc1_drive: Box::new(shape(Tanh(1.0))),
            perc2_drive: Box::new(shape(Tanh(1.0))),
            kick_filter_moog: Box::new(moog()),
            kick_filter_lp: Box::new(lowpass()),
            kick_filter_hp: Box::new(highpass()),
            kick_filter_bp: Box::new(bandpass()),
            snare_filter_moog: Box::new(moog()),
            snare_filter_lp: Box::new(lowpass()),
            snare_filter_hp: Box::new(highpass()),
            snare_filter_bp: Box::new(bandpass()),
            clap_filter_moog: Box::new(moog()),
            clap_filter_lp: Box::new(lowpass()),
            clap_filter_hp: Box::new(highpass()),
            clap_filter_bp: Box::new(bandpass()),
            hat_filter_moog: Box::new(moog()),
            hat_filter_lp: Box::new(lowpass()),
            hat_filter_hp: Box::new(highpass()),
            hat_filter_bp: Box::new(bandpass()),
            crash_filter_moog: Box::new(moog()),
            crash_filter_lp: Box::new(lowpass()),
            crash_filter_hp: Box::new(highpass()),
            crash_filter_bp: Box::new(bandpass()),
            perc1_filter_moog: Box::new(moog()),
            perc1_filter_lp: Box::new(lowpass()),
            perc1_filter_hp: Box::new(highpass()),
            perc1_filter_bp: Box::new(bandpass()),
            perc2_filter_moog: Box::new(moog()),
            perc2_filter_lp: Box::new(lowpass()),
            perc2_filter_hp: Box::new(highpass()),
            perc2_filter_bp: Box::new(bandpass()),
            samp_drive: std::array::from_fn(|_| Box::new(shape(Tanh(1.0))) as Box<dyn AudioUnit>),
            samp_filter_moog: std::array::from_fn(|_| Box::new(moog()) as Box<dyn AudioUnit>),
            samp_filter_lp: std::array::from_fn(|_| Box::new(lowpass()) as Box<dyn AudioUnit>),
            samp_filter_hp: std::array::from_fn(|_| Box::new(highpass()) as Box<dyn AudioUnit>),
            samp_filter_bp: std::array::from_fn(|_| Box::new(bandpass()) as Box<dyn AudioUnit>),
            perc1_karplus_line: vec![0.0; 8192],
            perc1_karplus_pos: 0,
            perc1_karplus_delay: 2,
        }
    }

    fn set_sample_rate(&mut self, sample_rate: f32) {
        if (self.sample_rate - sample_rate).abs() < f32::EPSILON {
            return;
        }
        self.sample_rate = sample_rate;
        let sr = sample_rate as f64;
        self.kick_osc.set_sample_rate(sr);
        self.kick_drive.set_sample_rate(sr);
        self.snare_osc.set_sample_rate(sr);
        self.snare_noise.set_sample_rate(sr);
        self.snare_drive.set_sample_rate(sr);
        self.clap_noise.set_sample_rate(sr);
        self.clap_drive.set_sample_rate(sr);
        self.hat_drive.set_sample_rate(sr);
        self.crash_drive.set_sample_rate(sr);
        self.perc1_noise.set_sample_rate(sr);
        self.perc1_drive.set_sample_rate(sr);
        self.perc2_drive.set_sample_rate(sr);
        self.kick_filter_moog.set_sample_rate(sr);
        self.kick_filter_lp.set_sample_rate(sr);
        self.kick_filter_hp.set_sample_rate(sr);
        self.kick_filter_bp.set_sample_rate(sr);
        self.snare_filter_moog.set_sample_rate(sr);
        self.snare_filter_lp.set_sample_rate(sr);
        self.snare_filter_hp.set_sample_rate(sr);
        self.snare_filter_bp.set_sample_rate(sr);
        self.clap_filter_moog.set_sample_rate(sr);
        self.clap_filter_lp.set_sample_rate(sr);
        self.clap_filter_hp.set_sample_rate(sr);
        self.clap_filter_bp.set_sample_rate(sr);
        self.hat_filter_moog.set_sample_rate(sr);
        self.hat_filter_lp.set_sample_rate(sr);
        self.hat_filter_hp.set_sample_rate(sr);
        self.hat_filter_bp.set_sample_rate(sr);
        self.crash_filter_moog.set_sample_rate(sr);
        self.crash_filter_lp.set_sample_rate(sr);
        self.crash_filter_hp.set_sample_rate(sr);
        self.crash_filter_bp.set_sample_rate(sr);
        self.perc1_filter_moog.set_sample_rate(sr);
        self.perc1_filter_lp.set_sample_rate(sr);
        self.perc1_filter_hp.set_sample_rate(sr);
        self.perc1_filter_bp.set_sample_rate(sr);
        self.perc2_filter_moog.set_sample_rate(sr);
        self.perc2_filter_lp.set_sample_rate(sr);
        self.perc2_filter_hp.set_sample_rate(sr);
        self.perc2_filter_bp.set_sample_rate(sr);
        for unit in self.samp_drive.iter_mut() {
            unit.set_sample_rate(sr);
        }
        for unit in self.samp_filter_moog.iter_mut() {
            unit.set_sample_rate(sr);
        }
        for unit in self.samp_filter_lp.iter_mut() {
            unit.set_sample_rate(sr);
        }
        for unit in self.samp_filter_hp.iter_mut() {
            unit.set_sample_rate(sr);
        }
        for unit in self.samp_filter_bp.iter_mut() {
            unit.set_sample_rate(sr);
        }
    }
}

struct AnimateDspState {
    sample_rate: f32,
    moog: [[Box<dyn AudioUnit>; 4]; 10],
    moog_keybed: [Box<dyn AudioUnit>; 4],
}

impl AnimateDspState {
    fn new() -> Self {
        Self {
            sample_rate: 0.0,
            moog: std::array::from_fn(|_| {
                std::array::from_fn(|_| Box::new(moog()) as Box<dyn AudioUnit>)
            }),
            moog_keybed: std::array::from_fn(|_| Box::new(moog()) as Box<dyn AudioUnit>),
        }
    }

    fn set_sample_rate(&mut self, sr: f32) {
        if (self.sample_rate - sr).abs() < f32::EPSILON {
            return;
        }
        self.sample_rate = sr;
        let sr = sr as f64;
        for row in self.moog.iter_mut() {
            for unit in row.iter_mut() {
                unit.set_sample_rate(sr);
            }
        }
        for unit in self.moog_keybed.iter_mut() {
            unit.set_sample_rate(sr);
        }
    }
}

struct AnimateLibrary {
    wavetable_paths: Vec<PathBuf>,
    sample_paths: Vec<PathBuf>,
    wavetables: Mutex<Vec<Option<Arc<Vec<f32>>>>>,
    samples: Mutex<Vec<Option<Arc<Vec<Vec<f32>>>>>>,
}

#[derive(Params)]
pub struct TLBX1Params {
    #[id = "selected_track"]
    pub selected_track: IntParam,

    #[id = "gain"]
    pub gain: FloatParam,

    #[id = "master_filter"]
    pub master_filter: FloatParam,

    #[id = "master_comp"]
    pub master_comp: FloatParam,
}

impl AnimateLibrary {
    fn load() -> Self {
        fn scan_dir(dir: &Path, paths: &mut Vec<PathBuf>) {
            if let Ok(entries) = std::fs::read_dir(dir) {
                let mut sorted_entries: Vec<_> = entries.flatten().collect();
                sorted_entries.sort_by_key(|e| e.file_name());

                for entry in sorted_entries {
                    let path = entry.path();
                    if path.is_dir() {
                        scan_dir(&path, paths);
                    } else if path.extension().map_or(false, |ext| ext == "wav" || ext == "mp3") {
                        paths.push(path);
                    }
                }
            }
        }

        let mut wavetable_paths = Vec::new();
        let mut sample_paths = Vec::new();

        scan_dir(Path::new("src/library/factory/wavetables"), &mut wavetable_paths);
        scan_dir(Path::new("src/library/factory/samples"), &mut sample_paths);

        let wavetables = vec![None; wavetable_paths.len()];
        let samples = vec![None; sample_paths.len()];

        Self {
            wavetable_paths,
            sample_paths,
            wavetables: Mutex::new(wavetables),
            samples: Mutex::new(samples),
        }
    }

    fn ensure_wavetable_loaded(&self, idx: usize) -> Option<Arc<Vec<f32>>> {
        if idx >= self.wavetable_paths.len() {
            return None;
        }
        if let Some(cache) = self.wavetables.try_lock() {
            if let Some(existing) = cache.get(idx).and_then(|entry| entry.clone()) {
                return Some(existing);
            }
        }
        let path = self.wavetable_paths.get(idx)?.clone();
        let data = load_audio_file(&path).ok();
        let wavetable = data.and_then(|(data, _)| data.get(0).cloned());
        if let Some(wt) = wavetable {
            let arc = Arc::new(wt);
            if let Some(mut cache) = self.wavetables.try_lock() {
                if let Some(entry) = cache.get_mut(idx) {
                    *entry = Some(Arc::clone(&arc));
                }
            }
            return Some(arc);
        }
        None
    }

    fn ensure_sample_loaded(&self, idx: usize) -> Option<Arc<Vec<Vec<f32>>>> {
        if idx >= self.sample_paths.len() {
            return None;
        }
        if let Some(cache) = self.samples.try_lock() {
            if let Some(existing) = cache.get(idx).and_then(|entry| entry.clone()) {
                return Some(existing);
            }
        }
        let path = self.sample_paths.get(idx)?.clone();
        let data = load_audio_file(&path).ok();
        if let Some((data, _)) = data {
            let arc = Arc::new(data);
            if let Some(mut cache) = self.samples.try_lock() {
                if let Some(entry) = cache.get_mut(idx) {
                    *entry = Some(Arc::clone(&arc));
                }
            }
            return Some(arc);
        }
        None
    }

    fn get_wavetable_cached(&self, idx: usize) -> Option<Arc<Vec<f32>>> {
        if idx >= self.wavetable_paths.len() {
            return None;
        }
        self.wavetables
            .try_lock()
            .and_then(|cache| cache.get(idx).and_then(|entry| entry.clone()))
    }

    fn get_sample_cached(&self, idx: usize) -> Option<Arc<Vec<Vec<f32>>>> {
        if idx >= self.sample_paths.len() {
            return None;
        }
        self.samples
            .try_lock()
            .and_then(|cache| cache.get(idx).and_then(|entry| entry.clone()))
    }
}

impl Default for TLBX1 {
    fn default() -> Self {
        let tracks = [
            Track::default(),
            Track::default(),
            Track::default(),
            Track::default(),
        ];
        
        Self {
            params: Arc::new(TLBX1Params::default()),
            tracks: Arc::new(tracks),
            master_meters: Arc::new(MasterMeters::default()),
            visualizer: Arc::new(VisualizerState::new()),
            global_tempo: Arc::new(AtomicU32::new(120.0f32.to_bits())),
            follow_host_tempo: Arc::new(AtomicBool::new(true)),
            metronome_enabled: Arc::new(AtomicBool::new(false)),
            metronome_count_in_ticks: Arc::new(AtomicU32::new(0)),
            metronome_count_in_playback: Arc::new(AtomicBool::new(false)),
            metronome_count_in_record: Arc::new(AtomicBool::new(false)),
            metronome_phase_samples: 0,
            metronome_click_remaining: 0,
            master_step_phase: 0.0,
            master_step_index: 0,
            master_step_count: 0,
            animate_library: Arc::new(AnimateLibrary::load()),
            master_fx: MasterFxState::default(),
            sample_rate: AtomicU32::new(44100),
            pending_project_params: Arc::new(Mutex::new(None)),
            track_buffer: vec![vec![0.0; 1024]; 2],
            syndrm_dsp: std::array::from_fn(|_| SynDRMDspState::new()),
            animate_dsp: std::array::from_fn(|_| AnimateDspState::new()),
            void_dsp: std::array::from_fn(|_| VoidSeedDspState::new()),
            fmmi_dsp: std::array::from_fn(|_| FmmiDspState::new()),
            monomi_dsp: std::array::from_fn(|_| MonomiDspState::new()),
            last_host_playing: false,
        }
    }
}

impl VisualizerState {
    fn new() -> Self {
        Self {
            oscilloscope: Mutex::new(vec![0.0; OSCILLOSCOPE_SAMPLES]),
            spectrum: Mutex::new(vec![0.0; SPECTRUM_BINS]),
            vectorscope_x: Mutex::new(vec![0.0; VECTORSCOPE_POINTS]),
            vectorscope_y: Mutex::new(vec![0.0; VECTORSCOPE_POINTS]),
        }
    }
}

#[derive(Default)]
struct MasterMeters {
    left: AtomicU32,
    right: AtomicU32,
}

struct MasterFxState {
    // SVF filter state: [channel_idx]
    filter_low: [f32; 2],
    filter_band: [f32; 2],
    // Compressor envelope follower
    comp_env: f32,
}

impl Default for MasterFxState {
    fn default() -> Self {
        Self {
            filter_low: [0.0; 2],
            filter_band: [0.0; 2],
            comp_env: 0.0,
        }
    }
}

#[derive(Default)]
struct VisualizerState {
    oscilloscope: Mutex<Vec<f32>>,
    spectrum: Mutex<Vec<f32>>,
    vectorscope_x: Mutex<Vec<f32>>,
    vectorscope_y: Mutex<Vec<f32>>,
}

impl Default for TLBX1Params {
    fn default() -> Self {
        Self {
            selected_track: IntParam::new("Selected Track", 1, IntRange::Linear { min: 1, max: 4 }),
            gain: FloatParam::new(
                "Master Gain",
                util::db_to_gain(0.0),
                FloatRange::Skewed {
                    min: util::db_to_gain(-70.0),
                    max: util::db_to_gain(6.0),
                    factor: FloatRange::gain_skew_factor(-70.0, 6.0),
                },
            )
            .with_unit(" dB")
            .with_value_to_string(formatters::v2s_f32_gain_to_db(2))
            .with_string_to_value(formatters::s2v_f32_gain_to_db()),

            master_filter: FloatParam::new(
                "Master DJ Filter",
                1.0,
                FloatRange::Linear { min: 0.0, max: 1.0 },
            )
            .with_value_to_string(Arc::new(|v| {
                let v = (v * 0.5).clamp(0.0, 0.5);
                if v < 0.49 {
                    format!("HP {:.0} Hz", 20.0 + (1.0 - v / 0.5) * 2000.0)
                } else {
                    "Neutral".to_string()
                }
            })),

            master_comp: FloatParam::new(
                "Master Compression",
                0.0,
                FloatRange::Linear { min: 0.0, max: 1.0 },
            )
            .with_unit("%")
            .with_value_to_string(formatters::v2s_f32_percentage(0)),
        }
    }
}

pub enum TLBX1Task {
    LoadSample(usize, PathBuf),
    LoadSyndrmSample { track_idx: usize, channel_idx: usize, path: PathBuf },
    SaveProject {
        path: PathBuf,
        title: String,
        description: String,
    },
    LoadProject(PathBuf),
    ExportProjectZip {
        path: PathBuf,
        title: String,
        description: String,
    },
}

struct PendingEngineLoad {
    track_idx: usize,
    engine_type: u32,
}

fn calculate_waveform_summary(samples: &[f32], summary: &mut [f32]) {
    if samples.is_empty() {
        for s in summary.iter_mut() { *s = 0.0; }
        return;
    }

    let num_bars = summary.len();
    let samples_per_bar = samples.len() / num_bars;

    if samples_per_bar == 0 {
        for i in 0..num_bars {
            summary[i] = samples.get(i).cloned().unwrap_or(0.0).abs();
        }
        return;
    }

    for i in 0..num_bars {
        let start = i * samples_per_bar;
        let end = (i + 1) * samples_per_bar;
        let mut max_amp: f32 = 0.0;
        for j in start..end {
            let amp = samples[j].abs();
            if amp > max_amp {
                max_amp = amp;
            }
        }
        summary[i] = max_amp;
    }
}

fn reset_track_for_engine(track: &Track, engine_type: u32) {
    track.engine_type.store(engine_type, Ordering::Relaxed);
    track.is_playing.store(false, Ordering::Relaxed);
    track.is_recording.store(false, Ordering::Relaxed);
    track.pending_play.store(false, Ordering::Relaxed);
    track.pending_record.store(false, Ordering::Relaxed);
    track.count_in_remaining.store(0, Ordering::Relaxed);
    track.play_pos.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.record_pos.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.level.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.level_smooth.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.meter_left.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.meter_right.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.is_muted.store(false, Ordering::Relaxed);
    track.video_enabled.store(false, Ordering::Relaxed);
    track.video_width.store(0, Ordering::Relaxed);
    track.video_height.store(0, Ordering::Relaxed);
    track.video_fps.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.video_cache_id.fetch_add(1, Ordering::Relaxed);
    *track.video_cache.lock() = None;
    track.tape_speed.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.tape_speed_smooth.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.tape_tempo.store(120.0f32.to_bits(), Ordering::Relaxed);
    track.tape_rate_mode.store(0, Ordering::Relaxed);
    track.tape_sync_requested.store(false, Ordering::Relaxed);
    track.tape_rotate.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .tape_rotate_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.tape_glide.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .tape_glide_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.tape_sos.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.tape_reverse.store(false, Ordering::Relaxed);
    track.tape_freeze.store(false, Ordering::Relaxed);
    track.tape_keylock.store(false, Ordering::Relaxed);
    track.keylock_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.keylock_grain_a.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.keylock_grain_b.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.tape_monitor.store(false, Ordering::Relaxed);
    track.tape_overdub.store(false, Ordering::Relaxed);
    track.loop_start.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .loop_start_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.trigger_start.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.loop_length.store(1.0f32.to_bits(), Ordering::Relaxed);
    track
        .loop_length_smooth
        .store(1.0f32.to_bits(), Ordering::Relaxed);
    track.loop_xfade.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .loop_xfade_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.loop_enabled.store(true, Ordering::Relaxed);
    track.loop_mode.store(0, Ordering::Relaxed);
    track.loop_dir.store(1, Ordering::Relaxed);
    track.granular_type.store(1, Ordering::Relaxed);
    track.mosaic_pitch.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_pitch_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_rate.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.mosaic_rate_smooth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.mosaic_size.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.mosaic_size_smooth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.mosaic_contour.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.mosaic_contour_smooth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.mosaic_warp.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_warp_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_spray.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_spray_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_pattern.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_pattern_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_wet.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_wet_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_spatial.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .mosaic_spatial_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_detune.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_detune_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_rand_rate.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_rand_rate_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_rand_size.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_rand_size_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_sos.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_sos_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .mosaic_post_gain
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .mosaic_post_gain_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track.mosaic_enabled.store(true, Ordering::Relaxed);
    track.mosaic_loop_lock.store(false, Ordering::Relaxed);
    track.mosaic_write_pos.store(0, Ordering::Relaxed);
    for idx in 0..MOSAIC_MAX_GRAINS {
        track.mosaic_grain_active[idx].store(false, Ordering::Relaxed);
        track.mosaic_grain_start[idx].store(0, Ordering::Relaxed);
        track
            .mosaic_grain_pos[idx]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track.mosaic_grain_len[idx].store(0, Ordering::Relaxed);
        track
            .mosaic_grain_pitch[idx]
            .store(1.0f32.to_bits(), Ordering::Relaxed);
        track
            .mosaic_grain_pan[idx]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
    }
    track
        .mosaic_spawn_phase
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.mosaic_last_grain_start.store(0, Ordering::Relaxed);
    track.mosaic_last_grain_len.store(0, Ordering::Relaxed);
    track.mosaic_rng_state.store(0x1234_abcd, Ordering::Relaxed);
    for marker in &track.mosaic_grain_markers {
        marker.store((-1.0f32).to_bits(), Ordering::Relaxed);
    }
    track.mosaic_grain_marker_write.store(0, Ordering::Relaxed);
    track.ring_cutoff.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_cutoff_smooth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_resonance.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_resonance_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_decay.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_decay_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_decay_mode.store(0, Ordering::Relaxed);
    track.ring_pitch.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_pitch_smooth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_tone.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_tone_smooth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_tilt.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_tilt_smooth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_slope.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_slope_smooth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_wet.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_wet_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_detune.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_detune_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_waves.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_waves_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_waves_rate.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_waves_rate_smooth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_waves_rate_mode.store(0, Ordering::Relaxed);
    track.ring_waves_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_noise.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_noise_smooth.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_noise_rate.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_noise_rate_smooth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.ring_noise_rate_mode.store(0, Ordering::Relaxed);
    track.ring_noise_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_noise_value.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_noise_rng.store(0x1357_2468, Ordering::Relaxed);
    track.ring_scale.store(0, Ordering::Relaxed);
    track.ring_detune_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.ring_enabled.store(false, Ordering::Relaxed);
    track.ring_pre_post.store(true, Ordering::Relaxed);
    for channel in 0..2 {
        track.ring_low[channel].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.ring_band[channel].store(0.0f32.to_bits(), Ordering::Relaxed);
    }
    track.g8_enabled.store(false, Ordering::Relaxed);
    track.g8_rate_index.store(0, Ordering::Relaxed);
    for step in track.g8_steps.iter() {
        step.store(1.0f32.to_bits(), Ordering::Relaxed);
    }
    track
        .g8_gain_smooth
        .store(1.0f32.to_bits(), Ordering::Relaxed);
    track.modul8_enabled.store(false, Ordering::Relaxed);
    for i in 0..MODUL8_LFOS {
        track.modul8_wave[i].store(0, Ordering::Relaxed);
        track.modul8_rate[i].store(1.0f32.to_bits(), Ordering::Relaxed);
        track.modul8_sync[i].store(true, Ordering::Relaxed);
        track.modul8_division[i].store(0, Ordering::Relaxed);
        track.modul8_amount[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.modul8_bias[i].store(0.5f32.to_bits(), Ordering::Relaxed);
        track.modul8_target[i].store(0, Ordering::Relaxed);
        track.modul8_phase[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.modul8_snh[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .modul8_base_value[i]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .modul8_base_target[i]
            .store(u32::MAX, Ordering::Relaxed);
    }
    track.modul8_rng_state.store(0x89ab_cdef, Ordering::Relaxed);
    track.texture_enabled.store(false, Ordering::Relaxed);
    track.texture_gate.store(false, Ordering::Relaxed);
    track.texture_drive.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_drive_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_compress
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_compress_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.texture_crush.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_crush_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.texture_tilt.store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .texture_tilt_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track.texture_noise.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_noise_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_noise_decay
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_noise_decay_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_noise_color
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .texture_noise_color_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track.texture_wet.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_wet_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_post_gain
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .texture_post_gain_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .texture_post_gain
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .texture_post_gain_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .texture_noise_env
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.texture_noise_rng.store(0x2468_1357, Ordering::Relaxed);
    track.texture_crush_phase.store(0, Ordering::Relaxed);
    for channel in 0..2 {
        track
            .texture_noise_lp[channel]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .texture_tilt_lp[channel]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .texture_crush_hold[channel]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
    }
    track.reflect_enabled.store(false, Ordering::Relaxed);
    track.reflect_freeze.store(false, Ordering::Relaxed);
    track.reflect_delay.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .reflect_delay_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.reflect_time.store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .reflect_time_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track.reflect_time_mode.store(0, Ordering::Relaxed);
    track.reflect_reverb.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .reflect_reverb_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.reflect_size.store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .reflect_size_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .reflect_feedback
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .reflect_feedback_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.reflect_spread.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .reflect_spread_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.reflect_damp.store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .reflect_damp_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track.reflect_decay.store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .reflect_decay_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .reflect_post_gain
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .reflect_post_gain_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track.reflect_clear.store(false, Ordering::Relaxed);
    track.reflect_delay_write_pos.store(0, Ordering::Relaxed);
    for idx in 0..track.reflect_reverb_comb_pos.len() {
        track.reflect_reverb_comb_pos[idx].store(0, Ordering::Relaxed);
    }
    for idx in 0..track.reflect_reverb_ap_pos.len() {
        track.reflect_reverb_ap_pos[idx].store(0, Ordering::Relaxed);
    }
    for channel in 0..2 {
        track
            .reflect_damp_state_delay[channel]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .reflect_damp_state_reverb[channel]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
    }
    if let Some(mut buffer) = track.reflect_delay_buffer.try_lock() {
        for channel in buffer.iter_mut() {
            channel.fill(0.0);
        }
    }
    if let Some(mut buffer) = track.reflect_reverb_comb_buffers.try_lock() {
        for channel in buffer.iter_mut() {
            for comb in channel.iter_mut() {
                comb.fill(0.0);
            }
        }
    }
    if let Some(mut buffer) = track.reflect_reverb_ap_buffers.try_lock() {
        for channel in buffer.iter_mut() {
            for ap in channel.iter_mut() {
                ap.fill(0.0);
            }
        }
    }
    if let Some(mut buffer) = track.mosaic_buffer.try_lock() {
        for channel in buffer.iter_mut() {
            channel.fill(0.0);
        }
    }
    for i in 0..4 {
        track.animate_slot_types[i].store(0, Ordering::Relaxed);
        track.animate_slot_wavetables[i].store(0, Ordering::Relaxed);
        track.animate_slot_samples[i].store(0, Ordering::Relaxed);
        track.animate_slot_coarse[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.animate_slot_fine[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.animate_slot_level[i].store(1.0f32.to_bits(), Ordering::Relaxed);
        track.animate_slot_level_smooth[i].store(1.0f32.to_bits(), Ordering::Relaxed);
        track.animate_slot_pan[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.animate_slot_pan_smooth[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .animate_slot_wt_lfo_amount[i]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .animate_slot_wt_lfo_shape[i]
            .store(0, Ordering::Relaxed);
        track
            .animate_slot_wt_lfo_rate[i]
            .store(0.5f32.to_bits(), Ordering::Relaxed);
        track
            .animate_slot_wt_lfo_sync[i]
            .store(false, Ordering::Relaxed);
        track
            .animate_slot_wt_lfo_division[i]
            .store(0, Ordering::Relaxed);
        track
            .animate_slot_wt_lfo_phase[i]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .animate_slot_wt_lfo_snh[i]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .animate_slot_sample_start[i]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .animate_slot_loop_start[i]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .animate_slot_loop_end[i]
            .store(1.0f32.to_bits(), Ordering::Relaxed);
        track
            .animate_slot_filter_type[i]
            .store(0, Ordering::Relaxed);
        track
            .animate_slot_filter_cutoff[i]
            .store(0.5f32.to_bits(), Ordering::Relaxed);
        track
            .animate_slot_filter_resonance[i]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
    }
    track.animate_vector_x.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.animate_vector_y.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.animate_vector_x_smooth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.animate_vector_y_smooth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.animate_lfo_x_waveform.store(0, Ordering::Relaxed);
    track.animate_lfo_x_sync.store(false, Ordering::Relaxed);
    track.animate_lfo_x_division.store(0, Ordering::Relaxed);
    track.animate_lfo_x_rate.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.animate_lfo_x_amount.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.animate_lfo_x_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.animate_lfo_x_snh.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.animate_lfo_y_waveform.store(0, Ordering::Relaxed);
    track.animate_lfo_y_sync.store(false, Ordering::Relaxed);
    track.animate_lfo_y_division.store(0, Ordering::Relaxed);
    track.animate_lfo_y_rate.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.animate_lfo_y_amount.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.animate_lfo_y_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.animate_lfo_y_snh.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.animate_lfo_rng_state.store(0x2468_ace1, Ordering::Relaxed);
    for i in 0..160 {
        track.animate_sequencer_grid[i].store(false, Ordering::Relaxed);
    }
    track.animate_sequencer_step.store(-1, Ordering::Relaxed);
    track.animate_sequencer_phase.store(0, Ordering::Relaxed);
    for voice in 0..10 {
        for slot in 0..4 {
            track.animate_slot_phases[voice][slot].store(0.0f32.to_bits(), Ordering::Relaxed);
            track.animate_slot_sample_pos[voice][slot].store(0.0f32.to_bits(), Ordering::Relaxed);
            track.animate_slot_filter_v1[voice][slot].store(0.0f32.to_bits(), Ordering::Relaxed);
            track.animate_slot_filter_v2[voice][slot].store(0.0f32.to_bits(), Ordering::Relaxed);
            track
                .animate_slot_filter_v1_stage2[voice][slot]
                .store(0.0f32.to_bits(), Ordering::Relaxed);
            track
                .animate_slot_filter_v2_stage2[voice][slot]
                .store(0.0f32.to_bits(), Ordering::Relaxed);
        }
        track.animate_amp_stage[voice].store(0, Ordering::Relaxed);
        track.animate_amp_level[voice].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.animate_slot_a_amp_stage[voice].store(0, Ordering::Relaxed);
        track
            .animate_slot_a_amp_level[voice]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
    }
    track
        .animate_slot_a_attack
        .store(0.01f32.to_bits(), Ordering::Relaxed);
    track
        .animate_slot_a_decay
        .store(0.1f32.to_bits(), Ordering::Relaxed);
    track
        .animate_slot_a_sustain
        .store(0.8f32.to_bits(), Ordering::Relaxed);
    track
        .animate_slot_a_release
        .store(0.3f32.to_bits(), Ordering::Relaxed);
    track.animate_keybed_note.store(60, Ordering::Relaxed);
    track.animate_keybed_trigger.store(false, Ordering::Relaxed);
    track.animate_keybed_hold.store(false, Ordering::Relaxed);
    track.animate_keybed_amp_stage.store(0, Ordering::Relaxed);
    track.animate_keybed_amp_level.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .animate_keybed_slot_a_amp_stage
        .store(0, Ordering::Relaxed);
    track
        .animate_keybed_slot_a_amp_level
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    for slot in 0..4 {
        track
            .animate_keybed_slot_phases[slot]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .animate_keybed_slot_sample_pos[slot]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .animate_keybed_filter_v1[slot]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .animate_keybed_filter_v2[slot]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .animate_keybed_filter_v1_stage2[slot]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .animate_keybed_filter_v2_stage2[slot]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
    }
    track.kick_pitch.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.kick_decay.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.kick_attack.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .kick_pitch_env_amount
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.kick_drive.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.kick_level.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.kick_filter_type.store(0, Ordering::Relaxed);
    track.kick_filter_cutoff.store(0.6f32.to_bits(), Ordering::Relaxed);
    track.kick_filter_resonance.store(0.2f32.to_bits(), Ordering::Relaxed);
    track.kick_filter_pre_drive.store(true, Ordering::Relaxed);
    track.kick_cut_group.store(0, Ordering::Relaxed);
    track.kick_cut_by.store(0, Ordering::Relaxed);
    track.kick_prob.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.kick_lane_enabled.store(true, Ordering::Relaxed);
    for i in 0..SYNDRM_STEPS {
        track.kick_sequencer_grid[i].store(false, Ordering::Relaxed);
    }
    track.kick_sequencer_step.store(-1, Ordering::Relaxed);
    track.kick_sequencer_phase.store(0, Ordering::Relaxed);
    track.kick_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.kick_env.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.kick_pitch_env.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.kick_attack_remaining.store(0, Ordering::Relaxed);
    track.snare_tone.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.snare_decay.store(0.4f32.to_bits(), Ordering::Relaxed);
    track.snare_snappy.store(0.6f32.to_bits(), Ordering::Relaxed);
    track.snare_attack.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.snare_drive.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.snare_level.store(0.8f32.to_bits(), Ordering::Relaxed);
    track.snare_filter_type.store(0, Ordering::Relaxed);
    track.snare_filter_cutoff.store(0.6f32.to_bits(), Ordering::Relaxed);
    track.snare_filter_resonance.store(0.2f32.to_bits(), Ordering::Relaxed);
    track.snare_filter_pre_drive.store(true, Ordering::Relaxed);
    track.snare_cut_group.store(0, Ordering::Relaxed);
    track.snare_cut_by.store(0, Ordering::Relaxed);
    track.snare_prob.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.snare_lane_enabled.store(true, Ordering::Relaxed);
    for i in 0..SYNDRM_STEPS {
        track.snare_sequencer_grid[i].store(false, Ordering::Relaxed);
    }
    track.snare_sequencer_step.store(-1, Ordering::Relaxed);
    track.snare_sequencer_phase.store(0, Ordering::Relaxed);
    track.snare_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.snare_env.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.snare_noise_env.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.snare_attack_remaining.store(0, Ordering::Relaxed);
    track.snare_noise_rng.store(0xdead_beef, Ordering::Relaxed);
    track.clap_pitch.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.clap_decay.store(0.25f32.to_bits(), Ordering::Relaxed);
    track.clap_tone.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.clap_drive.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.clap_level.store(0.8f32.to_bits(), Ordering::Relaxed);
    track.clap_filter_type.store(0, Ordering::Relaxed);
    track.clap_filter_cutoff.store(0.6f32.to_bits(), Ordering::Relaxed);
    track.clap_filter_resonance.store(0.2f32.to_bits(), Ordering::Relaxed);
    track.clap_filter_pre_drive.store(true, Ordering::Relaxed);
    track.clap_cut_group.store(0, Ordering::Relaxed);
    track.clap_cut_by.store(0, Ordering::Relaxed);
    track.clap_prob.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.clap_lane_enabled.store(true, Ordering::Relaxed);
    for i in 0..SYNDRM_STEPS {
        track.clap_sequencer_grid[i].store(false, Ordering::Relaxed);
    }
    track.clap_sequencer_step.store(-1, Ordering::Relaxed);
    track.clap_sequencer_phase.store(0, Ordering::Relaxed);
    track.clap_env.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.clap_phase.store(0, Ordering::Relaxed);
    track.hat_pitch.store(0.664f32.to_bits(), Ordering::Relaxed);
    track.hat_decay.store(0.048f32.to_bits(), Ordering::Relaxed);
    track.hat_tone.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.hat_drive.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.hat_level.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.hat_filter_type.store(1, Ordering::Relaxed);
    track.hat_filter_cutoff.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.hat_filter_resonance.store(0.667f32.to_bits(), Ordering::Relaxed);
    track.hat_filter_pre_drive.store(true, Ordering::Relaxed);
    track.hat_cut_group.store(0, Ordering::Relaxed);
    track.hat_cut_by.store(0, Ordering::Relaxed);
    track.hat_prob.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.hat_lane_enabled.store(true, Ordering::Relaxed);
    for i in 0..SYNDRM_STEPS {
        track.hat_sequencer_grid[i].store(false, Ordering::Relaxed);
    }
    track.hat_sequencer_step.store(-1, Ordering::Relaxed);
    track.hat_sequencer_phase.store(0, Ordering::Relaxed);
    track.hat_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    for i in 0..METAL_INHARM_RATIOS.len() {
        track.hat_phases[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.hat_mod_phases[i].store(0.0f32.to_bits(), Ordering::Relaxed);
    }
    track.hat_env.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.hat_attack_remaining.store(0, Ordering::Relaxed);
    track.hat_hp_x_prev.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.hat_hp_y_prev.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.perc1_pitch.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.perc1_decay.store(0.4f32.to_bits(), Ordering::Relaxed);
    track.perc1_tone.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.perc1_drive.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.perc1_level.store(0.8f32.to_bits(), Ordering::Relaxed);
    track.perc1_filter_type.store(0, Ordering::Relaxed);
    track.perc1_filter_cutoff.store(0.6f32.to_bits(), Ordering::Relaxed);
    track.perc1_filter_resonance.store(0.2f32.to_bits(), Ordering::Relaxed);
    track.perc1_filter_pre_drive.store(true, Ordering::Relaxed);
    track.perc1_cut_group.store(0, Ordering::Relaxed);
    track.perc1_cut_by.store(0, Ordering::Relaxed);
    track.perc1_prob.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.perc1_lane_enabled.store(true, Ordering::Relaxed);
    for i in 0..SYNDRM_STEPS {
        track.perc1_sequencer_grid[i].store(false, Ordering::Relaxed);
    }
    track.perc1_sequencer_step.store(-1, Ordering::Relaxed);
    track.perc1_sequencer_phase.store(0, Ordering::Relaxed);
    track.perc1_attack_remaining.store(0, Ordering::Relaxed);
    track.perc2_pitch.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.perc2_decay.store(0.25f32.to_bits(), Ordering::Relaxed);
    track.perc2_tone.store(0.65f32.to_bits(), Ordering::Relaxed);
    track.perc2_drive.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.perc2_level.store(0.8f32.to_bits(), Ordering::Relaxed);
    track.perc2_filter_type.store(0, Ordering::Relaxed);
    track.perc2_filter_cutoff.store(0.6f32.to_bits(), Ordering::Relaxed);
    track.perc2_filter_resonance.store(0.2f32.to_bits(), Ordering::Relaxed);
    track.perc2_filter_pre_drive.store(true, Ordering::Relaxed);
    track.perc2_cut_group.store(0, Ordering::Relaxed);
    track.perc2_cut_by.store(0, Ordering::Relaxed);
    track.perc2_prob.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.perc2_lane_enabled.store(true, Ordering::Relaxed);
    for i in 0..SYNDRM_STEPS {
        track.perc2_sequencer_grid[i].store(false, Ordering::Relaxed);
    }
    track.perc2_sequencer_step.store(-1, Ordering::Relaxed);
    track.perc2_sequencer_phase.store(0, Ordering::Relaxed);
    track.perc2_env.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.perc2_carrier_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.perc2_mod_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.crash_pitch.store(0.7f32.to_bits(), Ordering::Relaxed);
    track.crash_decay.store(0.7f32.to_bits(), Ordering::Relaxed);
    track.crash_tone.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.crash_drive.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.crash_level.store(0.8f32.to_bits(), Ordering::Relaxed);
    track.crash_filter_type.store(1, Ordering::Relaxed);
    track.crash_filter_cutoff.store(1.0f32.to_bits(), Ordering::Relaxed);
    track
        .crash_filter_resonance
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track.crash_filter_pre_drive.store(true, Ordering::Relaxed);
    track.crash_cut_group.store(0, Ordering::Relaxed);
    track.crash_cut_by.store(0, Ordering::Relaxed);
    track.crash_prob.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.crash_lane_enabled.store(true, Ordering::Relaxed);
    for i in 0..SYNDRM_STEPS {
        track.crash_sequencer_grid[i].store(false, Ordering::Relaxed);
    }
    track.crash_sequencer_step.store(-1, Ordering::Relaxed);
    track.crash_sequencer_phase.store(0, Ordering::Relaxed);
    track.crash_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    for i in 0..METAL_INHARM_RATIOS.len() {
        track.crash_phases[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .crash_mod_phases[i]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
    }
    track.crash_env.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.crash_attack_remaining.store(0, Ordering::Relaxed);
    track.crash_hp_x_prev.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.crash_hp_y_prev.store(0.0f32.to_bits(), Ordering::Relaxed);
    for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
        track.samp_cut_group[samp_idx].store(0, Ordering::Relaxed);
        track.samp_cut_by[samp_idx].store(0, Ordering::Relaxed);
        track.samp_prob[samp_idx].store(1.0f32.to_bits(), Ordering::Relaxed);
        track.samp_lane_enabled[samp_idx].store(true, Ordering::Relaxed);
    }
    track.syndrm_page.store(0, Ordering::Relaxed);
    track.syndrm_edit_lane.store(0, Ordering::Relaxed);
    track.syndrm_edit_step.store(0, Ordering::Relaxed);
    track.syndrm_step_hold.store(false, Ordering::Relaxed);
    track
        .syndrm_randomize_amount
        .store(1.0f32.to_bits(), Ordering::Relaxed);
    track.syndrm_rng_state.store(0x81c3_5f27, Ordering::Relaxed);
    for i in 0..SYNDRM_STEPS {
        track.kick_step_override_enabled[i].store(false, Ordering::Relaxed);
        track.kick_step_pitch[i].store(0.5f32.to_bits(), Ordering::Relaxed);
        track.kick_step_decay[i].store(0.5f32.to_bits(), Ordering::Relaxed);
        track.kick_step_attack[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.kick_step_drive[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.kick_step_level[i].store(1.0f32.to_bits(), Ordering::Relaxed);
        track.kick_step_filter_type[i].store(0, Ordering::Relaxed);
        track.kick_step_filter_cutoff[i].store(0.6f32.to_bits(), Ordering::Relaxed);
        track.kick_step_filter_resonance[i].store(0.2f32.to_bits(), Ordering::Relaxed);
        track.kick_step_retrig_enabled[i].store(false, Ordering::Relaxed);
        track.kick_step_retrig_division[i].store(2, Ordering::Relaxed);
        track.snare_step_override_enabled[i].store(false, Ordering::Relaxed);
        track.snare_step_tone[i].store(0.5f32.to_bits(), Ordering::Relaxed);
        track.snare_step_decay[i].store(0.4f32.to_bits(), Ordering::Relaxed);
        track.snare_step_snappy[i].store(0.6f32.to_bits(), Ordering::Relaxed);
        track.snare_step_attack[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.snare_step_drive[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.snare_step_level[i].store(0.8f32.to_bits(), Ordering::Relaxed);
        track.snare_step_filter_type[i].store(0, Ordering::Relaxed);
        track.snare_step_filter_cutoff[i].store(0.6f32.to_bits(), Ordering::Relaxed);
        track.snare_step_filter_resonance[i].store(0.2f32.to_bits(), Ordering::Relaxed);
        track.snare_step_retrig_enabled[i].store(false, Ordering::Relaxed);
        track.snare_step_retrig_division[i].store(2, Ordering::Relaxed);
        track.clap_step_override_enabled[i].store(false, Ordering::Relaxed);
        track.clap_step_pitch[i].store(0.5f32.to_bits(), Ordering::Relaxed);
        track.clap_step_decay[i].store(0.25f32.to_bits(), Ordering::Relaxed);
        track.clap_step_tone[i].store(0.5f32.to_bits(), Ordering::Relaxed);
        track.clap_step_drive[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.clap_step_level[i].store(0.8f32.to_bits(), Ordering::Relaxed);
        track.clap_step_filter_type[i].store(0, Ordering::Relaxed);
        track.clap_step_filter_cutoff[i].store(0.6f32.to_bits(), Ordering::Relaxed);
        track
            .clap_step_filter_resonance[i]
            .store(0.2f32.to_bits(), Ordering::Relaxed);
        track.clap_step_retrig_enabled[i].store(false, Ordering::Relaxed);
        track.clap_step_retrig_division[i].store(2, Ordering::Relaxed);
        track.hat_step_override_enabled[i].store(false, Ordering::Relaxed);
        track.hat_step_pitch[i].store(0.664f32.to_bits(), Ordering::Relaxed);
        track.hat_step_decay[i].store(0.048f32.to_bits(), Ordering::Relaxed);
        track.hat_step_tone[i].store(0.5f32.to_bits(), Ordering::Relaxed);
        track.hat_step_drive[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.hat_step_level[i].store(1.0f32.to_bits(), Ordering::Relaxed);
        track.hat_step_filter_type[i].store(1, Ordering::Relaxed);
        track.hat_step_filter_cutoff[i].store(1.0f32.to_bits(), Ordering::Relaxed);
        track.hat_step_filter_resonance[i].store(0.667f32.to_bits(), Ordering::Relaxed);
        track.hat_step_retrig_enabled[i].store(false, Ordering::Relaxed);
        track.hat_step_retrig_division[i].store(2, Ordering::Relaxed);
        track.perc1_step_override_enabled[i].store(false, Ordering::Relaxed);
        track.perc1_step_pitch[i].store(0.5f32.to_bits(), Ordering::Relaxed);
        track.perc1_step_decay[i].store(0.4f32.to_bits(), Ordering::Relaxed);
        track.perc1_step_tone[i].store(0.5f32.to_bits(), Ordering::Relaxed);
        track.perc1_step_drive[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.perc1_step_level[i].store(0.8f32.to_bits(), Ordering::Relaxed);
        track.perc1_step_filter_type[i].store(0, Ordering::Relaxed);
        track.perc1_step_filter_cutoff[i].store(0.6f32.to_bits(), Ordering::Relaxed);
        track
            .perc1_step_filter_resonance[i]
            .store(0.2f32.to_bits(), Ordering::Relaxed);
        track.perc1_step_retrig_enabled[i].store(false, Ordering::Relaxed);
        track.perc1_step_retrig_division[i].store(2, Ordering::Relaxed);
        track.perc2_step_override_enabled[i].store(false, Ordering::Relaxed);
        track.perc2_step_pitch[i].store(0.5f32.to_bits(), Ordering::Relaxed);
        track.perc2_step_decay[i].store(0.25f32.to_bits(), Ordering::Relaxed);
        track.perc2_step_tone[i].store(0.65f32.to_bits(), Ordering::Relaxed);
        track.perc2_step_drive[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.perc2_step_level[i].store(0.8f32.to_bits(), Ordering::Relaxed);
        track.perc2_step_filter_type[i].store(0, Ordering::Relaxed);
        track.perc2_step_filter_cutoff[i].store(0.6f32.to_bits(), Ordering::Relaxed);
        track
            .perc2_step_filter_resonance[i]
            .store(0.2f32.to_bits(), Ordering::Relaxed);
        track.perc2_step_retrig_enabled[i].store(false, Ordering::Relaxed);
        track.perc2_step_retrig_division[i].store(2, Ordering::Relaxed);
        track.crash_step_override_enabled[i].store(false, Ordering::Relaxed);
        track.crash_step_pitch[i].store(0.7f32.to_bits(), Ordering::Relaxed);
        track.crash_step_decay[i].store(0.7f32.to_bits(), Ordering::Relaxed);
        track.crash_step_tone[i].store(0.5f32.to_bits(), Ordering::Relaxed);
        track.crash_step_drive[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.crash_step_level[i].store(0.8f32.to_bits(), Ordering::Relaxed);
        track.crash_step_filter_type[i].store(1, Ordering::Relaxed);
        track
            .crash_step_filter_cutoff[i]
            .store(1.0f32.to_bits(), Ordering::Relaxed);
        track
            .crash_step_filter_resonance[i]
            .store(0.5f32.to_bits(), Ordering::Relaxed);
        track.crash_step_retrig_enabled[i].store(false, Ordering::Relaxed);
        track.crash_step_retrig_division[i].store(2, Ordering::Relaxed);
    }
    track.kick_retrig_remaining.store(0, Ordering::Relaxed);
    track.kick_retrig_timer.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.snare_retrig_remaining.store(0, Ordering::Relaxed);
    track.snare_retrig_timer.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.clap_retrig_remaining.store(0, Ordering::Relaxed);
    track.clap_retrig_timer.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.hat_retrig_remaining.store(0, Ordering::Relaxed);
    track.hat_retrig_timer.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.perc1_retrig_remaining.store(0, Ordering::Relaxed);
    track.perc1_retrig_timer.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.perc2_retrig_remaining.store(0, Ordering::Relaxed);
    track.perc2_retrig_timer.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.crash_retrig_remaining.store(0, Ordering::Relaxed);
    track.crash_retrig_timer.store(0.0f32.to_bits(), Ordering::Relaxed);
    for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
        track.samp_retrig_remaining[samp_idx].store(0, Ordering::Relaxed);
        track
            .samp_retrig_timer[samp_idx]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
    }

    track.fmmi_car_wave.store(0, Ordering::Relaxed);
    track.fmmi_car_freq.store(220.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_car_detune.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_mod_wave.store(0, Ordering::Relaxed);
    track.fmmi_mod_mode.store(0, Ordering::Relaxed);
    track.fmmi_mod_value.store(220.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_mod_detune.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_index.store(800.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_feedback.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_drive.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_out_level.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.fmmi_amp_attack.store(63.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_amp_decay.store(63.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_amp_sustain.store(63.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_amp_release.store(63.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_gate_length.store((-1.0f32).to_bits(), Ordering::Relaxed);
    track.fmmi_prob.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_poly_enabled.store(false, Ordering::Relaxed);
    for i in 0..FMMI_STEPS {
        let active = i < FMMI_PAGE_SIZE && i % 2 == 0;
        track.fmmi_sequencer_grid[i].store(active, Ordering::Relaxed);
        track.fmmi_step_note[i].store(-1, Ordering::Relaxed);
        track.fmmi_step_car_wave[i].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_wave[i].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_mode[i].store(-1, Ordering::Relaxed);
        track.fmmi_step_car_freq[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_car_detune[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_mod_value[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_mod_detune[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_index[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_feedback[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_drive[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_out_level[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_attack[i]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_decay[i]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_sustain[i]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_release[i]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_gate_length[i]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
    }
    track.fmmi_sequencer_step.store(-1, Ordering::Relaxed);
    track.fmmi_sequencer_phase.store(0, Ordering::Relaxed);
    track.fmmi_page.store(0, Ordering::Relaxed);
    track.fmmi_edit_step.store(0, Ordering::Relaxed);
    track.fmmi_rng_state.store(0x5a17_c9e3, Ordering::Relaxed);
    track.fmmi_keybed_note.store(60, Ordering::Relaxed);
    track.fmmi_keybed_trigger.store(false, Ordering::Relaxed);
    track.fmmi_rand_note_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_car_wave_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_mod_wave_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_mod_mode_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_car_freq_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_car_detune_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_mod_value_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_mod_detune_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_index_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_feedback_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_drive_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_out_level_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_amp_attack_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_amp_decay_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_amp_sustain_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_amp_release_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_gate_length_enabled.store(true, Ordering::Relaxed);
    track
        .fmmi_randomize_amount
        .store(1.0f32.to_bits(), Ordering::Relaxed);
    track
        .fmmi_randomize_steps_amount
        .store(1.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_scale_index.store(0, Ordering::Relaxed);
    track.fmmi_current_car_freq.store(220.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_current_car_detune.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_current_mod_value.store(220.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_current_mod_detune.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_current_index.store(800.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_current_feedback.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_current_drive.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_current_out_level.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.fmmi_car_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_mod_phase.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_gate_level.store(0.0f32.to_bits(), Ordering::Relaxed);
    track.fmmi_gate_stage.store(0, Ordering::Relaxed);
    track.fmmi_gate_pos.store(0, Ordering::Relaxed);
    track.fmmi_gate_hold.store(0, Ordering::Relaxed);
    track.fmmi_last_carrier.store(0.0f32.to_bits(), Ordering::Relaxed);

    track.void_base_freq.store(40.0f32.to_bits(), Ordering::Relaxed);
    track.void_chaos_depth.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.void_entropy.store(0.2f32.to_bits(), Ordering::Relaxed);
    track.void_feedback.store(0.8f32.to_bits(), Ordering::Relaxed);
    track.void_diffusion.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.void_mod_rate.store(0.1f32.to_bits(), Ordering::Relaxed);
    track.void_level.store(0.8f32.to_bits(), Ordering::Relaxed);
    track.void_pan.store(0.5f32.to_bits(), Ordering::Relaxed);
    track.void_width.store(1.0f32.to_bits(), Ordering::Relaxed);
    track.void_close_decay.store(4.0f32.to_bits(), Ordering::Relaxed);
    track
        .void_filter_cutoff
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .void_filter_cutoff_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .void_filter_resonance
        .store(0.2f32.to_bits(), Ordering::Relaxed);
    track
        .void_filter_resonance_smooth
        .store(0.2f32.to_bits(), Ordering::Relaxed);
    track
        .void_drive
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .void_drive_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.void_filter_pre_drive.store(true, Ordering::Relaxed);
    track
        .void_base_freq_smooth
        .store(40.0f32.to_bits(), Ordering::Relaxed);
    track
        .void_chaos_depth_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .void_entropy_smooth
        .store(0.2f32.to_bits(), Ordering::Relaxed);
    track
        .void_feedback_smooth
        .store(0.8f32.to_bits(), Ordering::Relaxed);
    track
        .void_diffusion_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .void_mod_rate_smooth
        .store(0.1f32.to_bits(), Ordering::Relaxed);
    track
        .void_level_smooth
        .store(0.8f32.to_bits(), Ordering::Relaxed);
    track
        .void_pan_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .void_width_smooth
        .store(1.0f32.to_bits(), Ordering::Relaxed);
    track.void_internal_gain.store(0.0f32.to_bits(), Ordering::Relaxed);
    for i in 0..12 {
        track.void_osc_phases[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.void_lfo_phases[i].store(0.0f32.to_bits(), Ordering::Relaxed);
    }
    track.void_lfo_chaos_phase.store(0, Ordering::Relaxed);
    track.void_filter_v1[0].store(0, Ordering::Relaxed);
    track.void_filter_v1[1].store(0, Ordering::Relaxed);
    track.void_filter_v2[0].store(0, Ordering::Relaxed);
    track.void_filter_v2[1].store(0, Ordering::Relaxed);
    if let Some(mut buffer) = track.void_delay_buffer.try_lock() {
        buffer[0].fill(0.0);
        buffer[1].fill(0.0);
    }
    track.void_delay_write_pos.store(0, Ordering::Relaxed);

    track.sample_rate.store(44_100, Ordering::Relaxed);
    track.debug_logged.store(false, Ordering::Relaxed);

    {
        let mut samples = track.samples.lock();
        *samples = vec![vec![]; 2];
    }
    {
        let mut summary = track.waveform_summary.lock();
        summary.fill(0.0);
    }
    *track.sample_path.lock() = None;
}

impl TLBX1 {
    fn process_animate(
        track: &Track,
        track_output: &mut [Vec<f32>],
        dsp_state: &mut AnimateDspState,
        num_buffer_samples: usize,
        global_tempo: &AtomicU32,
        animate_library: &AnimateLibrary,
        master_step: i32,
        master_phase: f32,
        samples_per_step: f32,
        transport_running: bool,
    ) {
        let sr = track.sample_rate.load(Ordering::Relaxed).max(1) as f32;
        dsp_state.set_sample_rate(sr);
        let tempo_bits = global_tempo.load(Ordering::Relaxed);
        let tempo_raw = f32::from_bits(tempo_bits);
        let tempo = if tempo_raw.is_finite() {
            tempo_raw.clamp(20.0, 240.0)
        } else {
            120.0
        };

        // Sequencer timing
        let mut sequencer_phase = if transport_running {
            master_phase
        } else {
            f32::from_bits(track.animate_sequencer_phase.load(Ordering::Relaxed))
        };
        let mut current_step = if transport_running {
            master_step
        } else {
            track.animate_sequencer_step.load(Ordering::Relaxed)
        };
        if transport_running {
            track
                .animate_sequencer_step
                .store(current_step, Ordering::Relaxed);
        }

        // Animate Parameters
        let target_x = f32::from_bits(track.animate_vector_x.load(Ordering::Relaxed));
        let target_y = f32::from_bits(track.animate_vector_y.load(Ordering::Relaxed));
        let mut x_smooth = f32::from_bits(track.animate_vector_x_smooth.load(Ordering::Relaxed));
        let mut y_smooth = f32::from_bits(track.animate_vector_y_smooth.load(Ordering::Relaxed));
        let lfo_x_waveform = track.animate_lfo_x_waveform.load(Ordering::Relaxed);
        let lfo_x_sync = track.animate_lfo_x_sync.load(Ordering::Relaxed);
        let lfo_x_division = track.animate_lfo_x_division.load(Ordering::Relaxed);
        let lfo_x_rate =
            f32::from_bits(track.animate_lfo_x_rate.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let lfo_x_amount =
            f32::from_bits(track.animate_lfo_x_amount.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut lfo_x_phase =
            f32::from_bits(track.animate_lfo_x_phase.load(Ordering::Relaxed));
        let mut lfo_x_snh = f32::from_bits(track.animate_lfo_x_snh.load(Ordering::Relaxed));
        let lfo_y_waveform = track.animate_lfo_y_waveform.load(Ordering::Relaxed);
        let lfo_y_sync = track.animate_lfo_y_sync.load(Ordering::Relaxed);
        let lfo_y_division = track.animate_lfo_y_division.load(Ordering::Relaxed);
        let lfo_y_rate =
            f32::from_bits(track.animate_lfo_y_rate.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let lfo_y_amount =
            f32::from_bits(track.animate_lfo_y_amount.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut lfo_y_phase =
            f32::from_bits(track.animate_lfo_y_phase.load(Ordering::Relaxed));
        let mut lfo_y_snh = f32::from_bits(track.animate_lfo_y_snh.load(Ordering::Relaxed));
        let mut lfo_rng_state = track.animate_lfo_rng_state.load(Ordering::Relaxed);

        let lfo_x_rate_hz = if lfo_x_sync {
            let beats = lfo_division_beats(lfo_x_division);
            (tempo / 60.0) / beats
        } else {
            ANIMATE_LFO_RATE_MIN_HZ
                * (ANIMATE_LFO_RATE_MAX_HZ / ANIMATE_LFO_RATE_MIN_HZ).powf(lfo_x_rate)
        };
        let lfo_y_rate_hz = if lfo_y_sync {
            let beats = lfo_division_beats(lfo_y_division);
            (tempo / 60.0) / beats
        } else {
            ANIMATE_LFO_RATE_MIN_HZ
                * (ANIMATE_LFO_RATE_MAX_HZ / ANIMATE_LFO_RATE_MIN_HZ).powf(lfo_y_rate)
        };
        let wt_lfo_amount = [
            f32::from_bits(
                track.animate_slot_wt_lfo_amount[0].load(Ordering::Relaxed),
            )
            .clamp(0.0, 1.0),
            f32::from_bits(
                track.animate_slot_wt_lfo_amount[1].load(Ordering::Relaxed),
            )
            .clamp(0.0, 1.0),
            f32::from_bits(
                track.animate_slot_wt_lfo_amount[2].load(Ordering::Relaxed),
            )
            .clamp(0.0, 1.0),
            f32::from_bits(
                track.animate_slot_wt_lfo_amount[3].load(Ordering::Relaxed),
            )
            .clamp(0.0, 1.0),
        ];
        let wt_lfo_shape = [
            track.animate_slot_wt_lfo_shape[0].load(Ordering::Relaxed),
            track.animate_slot_wt_lfo_shape[1].load(Ordering::Relaxed),
            track.animate_slot_wt_lfo_shape[2].load(Ordering::Relaxed),
            track.animate_slot_wt_lfo_shape[3].load(Ordering::Relaxed),
        ];
        let wt_lfo_rate = [
            f32::from_bits(track.animate_slot_wt_lfo_rate[0].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
            f32::from_bits(track.animate_slot_wt_lfo_rate[1].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
            f32::from_bits(track.animate_slot_wt_lfo_rate[2].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
            f32::from_bits(track.animate_slot_wt_lfo_rate[3].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
        ];
        let wt_lfo_sync = [
            track.animate_slot_wt_lfo_sync[0].load(Ordering::Relaxed),
            track.animate_slot_wt_lfo_sync[1].load(Ordering::Relaxed),
            track.animate_slot_wt_lfo_sync[2].load(Ordering::Relaxed),
            track.animate_slot_wt_lfo_sync[3].load(Ordering::Relaxed),
        ];
        let wt_lfo_division = [
            track.animate_slot_wt_lfo_division[0].load(Ordering::Relaxed),
            track.animate_slot_wt_lfo_division[1].load(Ordering::Relaxed),
            track.animate_slot_wt_lfo_division[2].load(Ordering::Relaxed),
            track.animate_slot_wt_lfo_division[3].load(Ordering::Relaxed),
        ];
        let mut wt_lfo_phase = [
            f32::from_bits(track.animate_slot_wt_lfo_phase[0].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_slot_wt_lfo_phase[1].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_slot_wt_lfo_phase[2].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_slot_wt_lfo_phase[3].load(Ordering::Relaxed)),
        ];
        let mut wt_lfo_snh = [
            f32::from_bits(track.animate_slot_wt_lfo_snh[0].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_slot_wt_lfo_snh[1].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_slot_wt_lfo_snh[2].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_slot_wt_lfo_snh[3].load(Ordering::Relaxed)),
        ];
        let wt_lfo_rate_hz = [
            if wt_lfo_sync[0] {
                let beats = lfo_division_beats(wt_lfo_division[0]);
                (tempo / 60.0) / beats
            } else {
                ANIMATE_LFO_RATE_MIN_HZ
                    * (ANIMATE_LFO_RATE_MAX_HZ / ANIMATE_LFO_RATE_MIN_HZ).powf(wt_lfo_rate[0])
            },
            if wt_lfo_sync[1] {
                let beats = lfo_division_beats(wt_lfo_division[1]);
                (tempo / 60.0) / beats
            } else {
                ANIMATE_LFO_RATE_MIN_HZ
                    * (ANIMATE_LFO_RATE_MAX_HZ / ANIMATE_LFO_RATE_MIN_HZ).powf(wt_lfo_rate[1])
            },
            if wt_lfo_sync[2] {
                let beats = lfo_division_beats(wt_lfo_division[2]);
                (tempo / 60.0) / beats
            } else {
                ANIMATE_LFO_RATE_MIN_HZ
                    * (ANIMATE_LFO_RATE_MAX_HZ / ANIMATE_LFO_RATE_MIN_HZ).powf(wt_lfo_rate[2])
            },
            if wt_lfo_sync[3] {
                let beats = lfo_division_beats(wt_lfo_division[3]);
                (tempo / 60.0) / beats
            } else {
                ANIMATE_LFO_RATE_MIN_HZ
                    * (ANIMATE_LFO_RATE_MAX_HZ / ANIMATE_LFO_RATE_MIN_HZ).powf(wt_lfo_rate[3])
            },
        ];
        let sample_start = [
            f32::from_bits(track.animate_slot_sample_start[0].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
            f32::from_bits(track.animate_slot_sample_start[1].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
            f32::from_bits(track.animate_slot_sample_start[2].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
            f32::from_bits(track.animate_slot_sample_start[3].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
        ];
        let loop_start = [
            f32::from_bits(track.animate_slot_loop_start[0].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
            f32::from_bits(track.animate_slot_loop_start[1].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
            f32::from_bits(track.animate_slot_loop_start[2].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
            f32::from_bits(track.animate_slot_loop_start[3].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
        ];
        let loop_end = [
            f32::from_bits(track.animate_slot_loop_end[0].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
            f32::from_bits(track.animate_slot_loop_end[1].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
            f32::from_bits(track.animate_slot_loop_end[2].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
            f32::from_bits(track.animate_slot_loop_end[3].load(Ordering::Relaxed))
                .clamp(0.0, 1.0),
        ];

        let attack = 0.01f32;
        let decay = 0.1f32;
        let sustain = 0.8f32;
        let release = 0.3f32;
        let slot_a_attack = f32::from_bits(track.animate_slot_a_attack.load(Ordering::Relaxed))
            .clamp(0.0, 5.0);
        let slot_a_decay = f32::from_bits(track.animate_slot_a_decay.load(Ordering::Relaxed))
            .clamp(0.0, 10.0);
        let slot_a_sustain = f32::from_bits(track.animate_slot_a_sustain.load(Ordering::Relaxed))
            .clamp(0.0, 1.0);
        let slot_a_release = f32::from_bits(track.animate_slot_a_release.load(Ordering::Relaxed))
            .clamp(0.0, 10.0);

        let mut amp_levels = [0.0f32; 10];
        let mut amp_stages = [0u32; 10];
        for i in 0..10 {
            amp_levels[i] = f32::from_bits(track.animate_amp_level[i].load(Ordering::Relaxed));
            amp_stages[i] = track.animate_amp_stage[i].load(Ordering::Relaxed);
        }
        let mut slot_a_amp_levels = [0.0f32; 10];
        let mut slot_a_amp_stages = [0u32; 10];
        for i in 0..10 {
            slot_a_amp_levels[i] =
                f32::from_bits(track.animate_slot_a_amp_level[i].load(Ordering::Relaxed));
            slot_a_amp_stages[i] =
                track.animate_slot_a_amp_stage[i].load(Ordering::Relaxed);
        }

        let mut keybed_amp_level =
            f32::from_bits(track.animate_keybed_amp_level.load(Ordering::Relaxed));
        let mut keybed_amp_stage = track.animate_keybed_amp_stage.load(Ordering::Relaxed);
        let mut keybed_slot_a_amp_level =
            f32::from_bits(track.animate_keybed_slot_a_amp_level.load(Ordering::Relaxed));
        let mut keybed_slot_a_amp_stage =
            track.animate_keybed_slot_a_amp_stage.load(Ordering::Relaxed);
        let mut keybed_phases = [
            f32::from_bits(track.animate_keybed_slot_phases[0].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_slot_phases[1].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_slot_phases[2].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_slot_phases[3].load(Ordering::Relaxed)),
        ];
        let mut keybed_sample_pos = [
            f32::from_bits(track.animate_keybed_slot_sample_pos[0].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_slot_sample_pos[1].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_slot_sample_pos[2].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_slot_sample_pos[3].load(Ordering::Relaxed)),
        ];
        let mut keybed_filter_v1 = [
            f32::from_bits(track.animate_keybed_filter_v1[0].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_filter_v1[1].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_filter_v1[2].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_filter_v1[3].load(Ordering::Relaxed)),
        ];
        let mut keybed_filter_v2 = [
            f32::from_bits(track.animate_keybed_filter_v2[0].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_filter_v2[1].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_filter_v2[2].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_filter_v2[3].load(Ordering::Relaxed)),
        ];
        let mut keybed_filter_v1_stage2 = [
            f32::from_bits(track.animate_keybed_filter_v1_stage2[0].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_filter_v1_stage2[1].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_filter_v1_stage2[2].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_filter_v1_stage2[3].load(Ordering::Relaxed)),
        ];
        let mut keybed_filter_v2_stage2 = [
            f32::from_bits(track.animate_keybed_filter_v2_stage2[0].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_filter_v2_stage2[1].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_filter_v2_stage2[2].load(Ordering::Relaxed)),
            f32::from_bits(track.animate_keybed_filter_v2_stage2[3].load(Ordering::Relaxed)),
        ];

        let keybed_triggered = track
            .animate_keybed_trigger
            .swap(false, Ordering::Relaxed);
        let mut keybed_note = track.animate_keybed_note.load(Ordering::Relaxed);
        let mut keybed_freq = (440.0
            * 2.0_f32.powf((keybed_note as f32 - 69.0) / 12.0))
            .max(1.0);

        if keybed_triggered {
            keybed_note = track.animate_keybed_note.load(Ordering::Relaxed);
            keybed_freq = (440.0
                * 2.0_f32.powf((keybed_note as f32 - 69.0) / 12.0))
                .max(1.0);
            keybed_amp_stage = 1;
            keybed_amp_level = 0.0;
            keybed_slot_a_amp_stage = 1;
            keybed_slot_a_amp_level = 0.0;
            for slot in 0..4 {
                if track.animate_slot_types[slot].load(Ordering::Relaxed) == 1 {
                    let smp_idx =
                        track.animate_slot_samples[slot].load(Ordering::Relaxed) as usize;
                    if let Some(smp) = animate_library.get_sample_cached(smp_idx) {
                        let len = smp.get(0).map(|ch| ch.len()).unwrap_or(0);
                        if len > 0 {
                            let start = (sample_start[slot]
                                * (len.saturating_sub(1) as f32))
                                .round()
                                .clamp(0.0, (len.saturating_sub(1)) as f32);
                            keybed_sample_pos[slot] = start;
                        }
                    }
                }
            }
        }

        
        // Pre-calculate envelope coefficients
        let calc_coef = |time_secs: f32| -> f32 {
            if time_secs <= 0.001 { 0.0 }
            else { (-1.0 / (time_secs * sr)).exp() }
        };

        let coef_attack = calc_coef(attack);
        let coef_decay = calc_coef(decay);
        let coef_release = calc_coef(release);
        let coef_slot_a_attack = calc_coef(slot_a_attack);
        let coef_slot_a_decay = calc_coef(slot_a_decay);
        let coef_slot_a_release = calc_coef(slot_a_release);
        let keybed_hold = track.animate_keybed_hold.load(Ordering::Relaxed);
        let keybed_sustain = if keybed_hold { 1.0f32 } else { 0.0f32 };
        let keybed_slot_a_sustain = if keybed_hold { slot_a_sustain } else { 0.0f32 };

        let frequencies = [
            65.41, 73.42, 82.41, 98.00, 110.00, // C2, D2, E2, G2, A2
            130.81, 146.83, 164.81, 196.00, 220.00, // C3, D3, E3, G3, A3
        ];

        let num_channels = track_output.len();
        let output = track_output;

        for sample_idx in 0..num_buffer_samples {
            // Step sequencer (master-synced)
            if transport_running {
                sequencer_phase += 1.0;
                if sequencer_phase >= samples_per_step {
                    sequencer_phase -= samples_per_step;
                    current_step = (current_step + 1).rem_euclid(16);
                    track
                        .animate_sequencer_step
                        .store(current_step, Ordering::Relaxed);

                    // Update envelope stages for all voices based on grid
                    for row in 0..10 {
                        let note_active = track.animate_sequencer_grid[row * 16 + current_step as usize]
                            .load(Ordering::Relaxed);
                        if note_active {
                            if amp_stages[row] == 0 || amp_stages[row] == 4 {
                                amp_stages[row] = 1; // Attack
                                for slot in 0..4 {
                                    if track.animate_slot_types[slot].load(Ordering::Relaxed) == 1 {
                                        let smp_idx =
                                            track.animate_slot_samples[slot].load(Ordering::Relaxed)
                                                as usize;
                                        if let Some(smp) = animate_library.get_sample_cached(smp_idx) {
                                            let len = smp.get(0).map(|ch| ch.len()).unwrap_or(0);
                                            if len > 0 {
                                                let start = (sample_start[slot]
                                                    * (len.saturating_sub(1) as f32))
                                                    .round()
                                                    .clamp(0.0, (len.saturating_sub(1)) as f32);
                                                track.animate_slot_sample_pos[row][slot]
                                                    .store(start.to_bits(), Ordering::Relaxed);
                                            }
                                        }
                                    }
                                }
                            }
                            if slot_a_amp_stages[row] == 0 || slot_a_amp_stages[row] == 4 {
                                slot_a_amp_stages[row] = 1;
                                slot_a_amp_levels[row] = 0.0;
                            }
                        } else if amp_stages[row] != 0 && amp_stages[row] != 4 {
                            amp_stages[row] = 4; // Release
                            if slot_a_amp_stages[row] != 0 && slot_a_amp_stages[row] != 4 {
                                slot_a_amp_stages[row] = 4;
                            }
                        }
                    }
                }
            }

            let mut wt_lfo_values = [0.0f32; 4];
            for slot in 0..4 {
                wt_lfo_values[slot] =
                    lfo_waveform_value(wt_lfo_shape[slot], wt_lfo_phase[slot], wt_lfo_snh[slot]);
                wt_lfo_phase[slot] += wt_lfo_rate_hz[slot] / sr;
                if wt_lfo_phase[slot] >= 1.0 {
                    wt_lfo_phase[slot] -= 1.0;
                    if wt_lfo_shape[slot] == 4 {
                        wt_lfo_snh[slot] =
                            next_mosaic_rand_unit(&mut lfo_rng_state) * 2.0 - 1.0;
                    }
                }
            }

            // Process Envelopes for all voices
            for i in 0..10 {
                match amp_stages[i] {
                    1 => { // Attack
                        amp_levels[i] = amp_levels[i] * coef_attack + 1.1 * (1.0 - coef_attack);
                        if amp_levels[i] >= 1.0 {
                            amp_levels[i] = 1.0;
                            amp_stages[i] = 2;
                        }
                    }
                    2 => { // Decay
                        amp_levels[i] = amp_levels[i] * coef_decay + sustain * (1.0 - coef_decay);
                        if (amp_levels[i] - sustain).abs() < 0.001 {
                            amp_levels[i] = sustain;
                            amp_stages[i] = 3;
                        }
                    }
                    3 => { // Sustain
                        amp_levels[i] = sustain;
                    }
                    4 => { // Release
                        amp_levels[i] = amp_levels[i] * coef_release;
                        if amp_levels[i] < 0.0001 {
                            amp_levels[i] = 0.0;
                            amp_stages[i] = 0;
                        }
                    }
                    _ => {
                        amp_levels[i] = 0.0;
                    }
                }
            }
            for i in 0..10 {
                match slot_a_amp_stages[i] {
                    1 => {
                        slot_a_amp_levels[i] =
                            slot_a_amp_levels[i] * coef_slot_a_attack
                                + 1.1 * (1.0 - coef_slot_a_attack);
                        if slot_a_amp_levels[i] >= 1.0 {
                            slot_a_amp_levels[i] = 1.0;
                            slot_a_amp_stages[i] = 2;
                        }
                    }
                    2 => {
                        slot_a_amp_levels[i] =
                            slot_a_amp_levels[i] * coef_slot_a_decay
                                + slot_a_sustain * (1.0 - coef_slot_a_decay);
                        if (slot_a_amp_levels[i] - slot_a_sustain).abs() < 0.001 {
                            slot_a_amp_levels[i] = slot_a_sustain;
                            slot_a_amp_stages[i] = 3;
                        }
                    }
                    3 => {
                        slot_a_amp_levels[i] = slot_a_sustain;
                    }
                    4 => {
                        slot_a_amp_levels[i] = slot_a_amp_levels[i] * coef_slot_a_release;
                        if slot_a_amp_levels[i] < 0.0001 {
                            slot_a_amp_levels[i] = 0.0;
                            slot_a_amp_stages[i] = 0;
                        }
                    }
                    _ => {
                        slot_a_amp_levels[i] = 0.0;
                    }
                }
            }

            match keybed_amp_stage {
                1 => {
                    keybed_amp_level =
                        keybed_amp_level * coef_attack + 1.1 * (1.0 - coef_attack);
                    if keybed_amp_level >= 1.0 {
                        keybed_amp_level = 1.0;
                        keybed_amp_stage = 2;
                    }
                }
                2 => {
                    keybed_amp_level =
                        keybed_amp_level * coef_decay + keybed_sustain * (1.0 - coef_decay);
                    if (keybed_amp_level - keybed_sustain).abs() < 0.001 {
                        keybed_amp_level = keybed_sustain;
                        keybed_amp_stage = if keybed_hold { 3 } else { 4 };
                    }
                }
                3 => {
                    if keybed_hold {
                        keybed_amp_level = keybed_sustain;
                    } else {
                        keybed_amp_stage = 4;
                    }
                }
                4 => {
                    keybed_amp_level = keybed_amp_level * coef_release;
                    if keybed_amp_level < 0.0001 {
                        keybed_amp_level = 0.0;
                        keybed_amp_stage = 0;
                    }
                }
                _ => {
                    keybed_amp_level = 0.0;
                }
            }
            match keybed_slot_a_amp_stage {
                1 => {
                    keybed_slot_a_amp_level = keybed_slot_a_amp_level * coef_slot_a_attack
                        + 1.1 * (1.0 - coef_slot_a_attack);
                    if keybed_slot_a_amp_level >= 1.0 {
                        keybed_slot_a_amp_level = 1.0;
                        keybed_slot_a_amp_stage = 2;
                    }
                }
                2 => {
                    keybed_slot_a_amp_level = keybed_slot_a_amp_level * coef_slot_a_decay
                        + keybed_slot_a_sustain * (1.0 - coef_slot_a_decay);
                    if (keybed_slot_a_amp_level - keybed_slot_a_sustain).abs() < 0.001 {
                        keybed_slot_a_amp_level = keybed_slot_a_sustain;
                        keybed_slot_a_amp_stage = if keybed_hold { 3 } else { 4 };
                    }
                }
                3 => {
                    if keybed_hold {
                        keybed_slot_a_amp_level = keybed_slot_a_sustain;
                    } else {
                        keybed_slot_a_amp_stage = 4;
                    }
                }
                4 => {
                    keybed_slot_a_amp_level = keybed_slot_a_amp_level * coef_slot_a_release;
                    if keybed_slot_a_amp_level < 0.0001 {
                        keybed_slot_a_amp_level = 0.0;
                        keybed_slot_a_amp_stage = 0;
                    }
                }
                _ => {
                    keybed_slot_a_amp_level = 0.0;
                }
            }

            // Smooth vector position
            let lfo_x_value = lfo_waveform_value(lfo_x_waveform, lfo_x_phase, lfo_x_snh);
            let lfo_y_value = lfo_waveform_value(lfo_y_waveform, lfo_y_phase, lfo_y_snh);
            let target_x_mod = (target_x + lfo_x_value * lfo_x_amount).clamp(0.0, 1.0);
            let target_y_mod = (target_y + lfo_y_value * lfo_y_amount).clamp(0.0, 1.0);
            x_smooth = x_smooth * 0.999 + target_x_mod * 0.001;
            y_smooth = y_smooth * 0.999 + target_y_mod * 0.001;

            lfo_x_phase += lfo_x_rate_hz / sr;
            if lfo_x_phase >= 1.0 {
                lfo_x_phase -= 1.0;
                if lfo_x_waveform == 4 {
                    lfo_x_snh = next_mosaic_rand_unit(&mut lfo_rng_state) * 2.0 - 1.0;
                }
            }
            lfo_y_phase += lfo_y_rate_hz / sr;
            if lfo_y_phase >= 1.0 {
                lfo_y_phase -= 1.0;
                if lfo_y_waveform == 4 {
                    lfo_y_snh = next_mosaic_rand_unit(&mut lfo_rng_state) * 2.0 - 1.0;
                }
            }

            // Calculate weights for 4 slots
            let w_a = (1.0 - x_smooth) * (1.0 - y_smooth);
            let w_b = x_smooth * (1.0 - y_smooth);
            let w_c = (1.0 - x_smooth) * y_smooth;
            let w_d = x_smooth * y_smooth;
            let weights = [w_a, w_b, w_c, w_d];

            let mut mixed_sample_l = 0.0f32;
            let mut mixed_sample_r = 0.0f32;

            // Sum active voices
            for row in 0..10 {
                if amp_levels[row] <= 0.0 && slot_a_amp_levels[row] <= 0.0 {
                    continue;
                }
                
                let base_freq = frequencies[row as usize];
                
                for slot in 0..4 {
                    let slot_type = track.animate_slot_types[slot].load(Ordering::Relaxed);
                    let coarse = f32::from_bits(track.animate_slot_coarse[slot].load(Ordering::Relaxed));
                    let fine = f32::from_bits(track.animate_slot_fine[slot].load(Ordering::Relaxed));
                    let pitch_ratio = 2.0f32.powf((coarse + fine / 100.0) / 12.0);
                    let freq = base_freq * pitch_ratio;

                    let mut slot_sample = 0.0f32;
                    if slot_type == 0 { // Wavetable
                        let wt_idx =
                            track.animate_slot_wavetables[slot].load(Ordering::Relaxed) as usize;
                        if let Some(wt) = animate_library.get_wavetable_cached(wt_idx) {
                            if !wt.is_empty() {
                                let phase = f32::from_bits(track.animate_slot_phases[row][slot].load(Ordering::Relaxed));
                                // Use first cycle (2048 samples)
                                let cycle_len = wt.len().min(2048);
                                if cycle_len > 0 {
                                    let num_cycles = wt.len() / cycle_len;
                                    let cycle_offset = if num_cycles > 1 && wt_lfo_amount[slot] > 0.0 {
                                        let lfo_pos = (wt_lfo_values[slot] * 0.5 + 0.5).clamp(0.0, 1.0);
                                        let max_idx = (num_cycles - 1) as f32;
                                        (lfo_pos * wt_lfo_amount[slot] * max_idx).round() as usize
                                    } else {
                                        0
                                    };
                                    let base = cycle_offset * cycle_len;
                                    let pos = phase * (cycle_len - 1) as f32;
                                    let idx = pos as usize;
                                    let frac = pos - idx as f32;
                                    let s1 = wt[base + idx];
                                    let s2 = wt[base + ((idx + 1) % cycle_len)];
                                    slot_sample = s1 + (s2 - s1) * frac;
                                }

                                let new_phase = (phase + freq / sr) % 1.0;
                                track.animate_slot_phases[row][slot].store(new_phase.to_bits(), Ordering::Relaxed);
                            }
                        }
                    } else { // Sample
                        let smp_idx =
                            track.animate_slot_samples[slot].load(Ordering::Relaxed) as usize;
                        if let Some(smp) = animate_library.get_sample_cached(smp_idx) {
                            if !smp.is_empty() && !smp[0].is_empty() {
                                let len = smp[0].len();
                                if len > 0 {
                                    let mut pos =
                                        f32::from_bits(track.animate_slot_sample_pos[row][slot].load(Ordering::Relaxed));
                                    let start_idx = (sample_start[slot] * (len.saturating_sub(1) as f32))
                                        .round()
                                        .clamp(0.0, (len.saturating_sub(1)) as f32) as usize;
                                    let mut loop_start_idx =
                                        (loop_start[slot] * (len.saturating_sub(1) as f32))
                                            .round()
                                            .clamp(0.0, (len.saturating_sub(1)) as f32) as usize;
                                    let mut loop_end_idx =
                                        (loop_end[slot] * (len.saturating_sub(1) as f32))
                                            .round()
                                            .clamp(0.0, (len.saturating_sub(1)) as f32) as usize;
                                    if loop_end_idx <= loop_start_idx {
                                        loop_start_idx = start_idx.min(len.saturating_sub(1));
                                        loop_end_idx = len.saturating_sub(1);
                                    }
                                    let mut idx = pos as usize;
                                    if idx >= loop_end_idx {
                                        pos = loop_start_idx as f32;
                                        idx = loop_start_idx;
                                    }
                                    if idx < len {
                                        slot_sample = smp[0][idx];
                                        let mut new_pos = pos + (freq / 440.0); // Rough sample playback
                                        if new_pos >= loop_end_idx as f32 {
                                            new_pos = loop_start_idx as f32;
                                        }
                                        track.animate_slot_sample_pos[row][slot]
                                            .store(new_pos.to_bits(), Ordering::Relaxed);
                                    }
                                }
                            }
                        }
                    }

                    let filter_type =
                        track.animate_slot_filter_type[slot].load(Ordering::Relaxed) as u32;
                    let filter_cutoff = f32::from_bits(
                        track.animate_slot_filter_cutoff[slot].load(Ordering::Relaxed),
                    )
                    .clamp(0.001, 1.0);
                    let filter_resonance = f32::from_bits(
                        track.animate_slot_filter_resonance[slot].load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 0.95);
                    let cutoff_hz = 20.0 + filter_cutoff.powf(2.0) * (20_000.0 - 20.0);
                    let filter_f =
                        (2.0 * (std::f32::consts::PI * cutoff_hz / sr).sin()).clamp(0.0, 0.99);
                    let filter_q = 1.0 - filter_resonance;
                    let filter_moog_q = 0.1 + filter_resonance * 0.9;
                    let filter_v1 = f32::from_bits(
                        track.animate_slot_filter_v1[row][slot].load(Ordering::Relaxed),
                    );
                    let filter_v2 = f32::from_bits(
                        track.animate_slot_filter_v2[row][slot].load(Ordering::Relaxed),
                    );
                    let filter_v1_stage2 = f32::from_bits(
                        track
                            .animate_slot_filter_v1_stage2[row][slot]
                            .load(Ordering::Relaxed),
                    );
                    let filter_v2_stage2 = f32::from_bits(
                        track
                            .animate_slot_filter_v2_stage2[row][slot]
                            .load(Ordering::Relaxed),
                    );
                    let filter_low = filter_v2 + filter_f * filter_v1;
                    let filter_high = slot_sample - filter_low - filter_q * filter_v1;
                    let filter_band = filter_f * filter_high + filter_v1;
                    let filter_low_stage2 = filter_v2_stage2 + filter_f * filter_v1_stage2;
                    let filter_high_stage2 = filter_low - filter_low_stage2 - filter_q * filter_v1_stage2;
                    let filter_band_stage2 = filter_f * filter_high_stage2 + filter_v1_stage2;
                    let mut filtered_sample = match filter_type {
                        0 => filter_low_stage2,
                        1 => filter_low,
                        2 => filter_high,
                        3 => filter_band,
                        4 => {
                            let mut out = [0.0f32];
                            dsp_state.moog[row][slot]
                                .tick(&[slot_sample, cutoff_hz, filter_moog_q], &mut out);
                            out[0]
                        }
                        _ => filter_low,
                    };
                    if !filtered_sample.is_finite() {
                        filtered_sample = slot_sample;
                        track.animate_slot_filter_v1[row][slot]
                            .store(0.0f32.to_bits(), Ordering::Relaxed);
                        track.animate_slot_filter_v2[row][slot]
                            .store(0.0f32.to_bits(), Ordering::Relaxed);
                        track.animate_slot_filter_v1_stage2[row][slot]
                            .store(0.0f32.to_bits(), Ordering::Relaxed);
                        track.animate_slot_filter_v2_stage2[row][slot]
                            .store(0.0f32.to_bits(), Ordering::Relaxed);
                    } else {
                        track.animate_slot_filter_v1[row][slot]
                            .store(filter_band.to_bits(), Ordering::Relaxed);
                        track.animate_slot_filter_v2[row][slot]
                            .store(filter_low.to_bits(), Ordering::Relaxed);
                        track.animate_slot_filter_v1_stage2[row][slot]
                            .store(filter_band_stage2.to_bits(), Ordering::Relaxed);
                        track.animate_slot_filter_v2_stage2[row][slot]
                            .store(filter_low_stage2.to_bits(), Ordering::Relaxed);
                    }
                    slot_sample = filtered_sample;

                    let amp_level = if slot == 0 {
                        slot_a_amp_levels[row]
                    } else {
                        amp_levels[row]
                    };
                    let level = f32::from_bits(track.animate_slot_level[slot].load(Ordering::Relaxed))
                        * weights[slot]
                        * amp_level;
                    let pan = f32::from_bits(track.animate_slot_pan[slot].load(Ordering::Relaxed)).clamp(-1.0, 1.0);
                    
                    let left_gain = (1.0 - pan).min(1.0);
                    let right_gain = (1.0 + pan).min(1.0);
                    
                    mixed_sample_l += slot_sample * level * left_gain;
                    mixed_sample_r += slot_sample * level * right_gain;
                }
            }

            if keybed_amp_level > 0.0 || keybed_slot_a_amp_level > 0.0 {
                for slot in 0..4 {
                    let slot_type = track.animate_slot_types[slot].load(Ordering::Relaxed);
                    let coarse =
                        f32::from_bits(track.animate_slot_coarse[slot].load(Ordering::Relaxed));
                    let fine =
                        f32::from_bits(track.animate_slot_fine[slot].load(Ordering::Relaxed));
                    let pitch_ratio = 2.0f32.powf((coarse + fine / 100.0) / 12.0);
                    let freq = keybed_freq * pitch_ratio;

                    let mut slot_sample = 0.0f32;
                    if slot_type == 0 {
                        let wt_idx =
                            track.animate_slot_wavetables[slot].load(Ordering::Relaxed) as usize;
                        if let Some(wt) = animate_library.get_wavetable_cached(wt_idx) {
                            if !wt.is_empty() {
                                let phase = keybed_phases[slot];
                                let cycle_len = wt.len().min(2048);
                                if cycle_len > 0 {
                                    let num_cycles = wt.len() / cycle_len;
                                    let cycle_offset = if num_cycles > 1
                                        && wt_lfo_amount[slot] > 0.0
                                    {
                                        let lfo_pos =
                                            (wt_lfo_values[slot] * 0.5 + 0.5).clamp(0.0, 1.0);
                                        let max_idx = (num_cycles - 1) as f32;
                                        (lfo_pos * wt_lfo_amount[slot] * max_idx).round() as usize
                                    } else {
                                        0
                                    };
                                    let base = cycle_offset * cycle_len;
                                    let pos = phase * (cycle_len - 1) as f32;
                                    let idx = pos as usize;
                                    let frac = pos - idx as f32;
                                    let s1 = wt[base + idx];
                                    let s2 = wt[base + ((idx + 1) % cycle_len)];
                                    slot_sample = s1 + (s2 - s1) * frac;
                                }
                                keybed_phases[slot] = (phase + freq / sr) % 1.0;
                            }
                        }
                    } else {
                        let smp_idx =
                            track.animate_slot_samples[slot].load(Ordering::Relaxed) as usize;
                        if let Some(smp) = animate_library.get_sample_cached(smp_idx) {
                            if !smp.is_empty() && !smp[0].is_empty() {
                                let len = smp[0].len();
                                if len > 0 {
                                    let mut pos = keybed_sample_pos[slot];
                                    let start_idx = (sample_start[slot]
                                        * (len.saturating_sub(1) as f32))
                                        .round()
                                        .clamp(0.0, (len.saturating_sub(1)) as f32)
                                        as usize;
                                    let mut loop_start_idx = (loop_start[slot]
                                        * (len.saturating_sub(1) as f32))
                                        .round()
                                        .clamp(0.0, (len.saturating_sub(1)) as f32)
                                        as usize;
                                    let mut loop_end_idx = (loop_end[slot]
                                        * (len.saturating_sub(1) as f32))
                                        .round()
                                        .clamp(0.0, (len.saturating_sub(1)) as f32)
                                        as usize;
                                    if loop_end_idx <= loop_start_idx {
                                        loop_start_idx = start_idx.min(len.saturating_sub(1));
                                        loop_end_idx = len.saturating_sub(1);
                                    }
                                    let mut idx = pos as usize;
                                    if idx >= loop_end_idx {
                                        pos = loop_start_idx as f32;
                                        idx = loop_start_idx;
                                    }
                                    if idx < len {
                                        slot_sample = smp[0][idx];
                                        let mut new_pos = pos + (freq / 440.0);
                                        if new_pos >= loop_end_idx as f32 {
                                            new_pos = loop_start_idx as f32;
                                        }
                                        keybed_sample_pos[slot] = new_pos;
                                    }
                                }
                            }
                        }
                    }

                    let filter_type =
                        track.animate_slot_filter_type[slot].load(Ordering::Relaxed) as u32;
                    let filter_cutoff = f32::from_bits(
                        track.animate_slot_filter_cutoff[slot].load(Ordering::Relaxed),
                    )
                    .clamp(0.001, 1.0);
                    let filter_resonance = f32::from_bits(
                        track.animate_slot_filter_resonance[slot].load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 0.95);
                    let cutoff_hz = 20.0 + filter_cutoff.powf(2.0) * (20_000.0 - 20.0);
                    let filter_f =
                        (2.0 * (std::f32::consts::PI * cutoff_hz / sr).sin()).clamp(0.0, 0.99);
                    let filter_q = 1.0 - filter_resonance;
                    let filter_moog_q = 0.1 + filter_resonance * 0.9;
                    let mut filter_v1 = keybed_filter_v1[slot];
                    let mut filter_v2 = keybed_filter_v2[slot];
                    let mut filter_v1_stage2 = keybed_filter_v1_stage2[slot];
                    let mut filter_v2_stage2 = keybed_filter_v2_stage2[slot];
                    let filter_low = filter_v2 + filter_f * filter_v1;
                    let filter_high = slot_sample - filter_low - filter_q * filter_v1;
                    let filter_band = filter_f * filter_high + filter_v1;
                    let filter_low_stage2 = filter_v2_stage2 + filter_f * filter_v1_stage2;
                    let filter_high_stage2 =
                        filter_low - filter_low_stage2 - filter_q * filter_v1_stage2;
                    let filter_band_stage2 = filter_f * filter_high_stage2 + filter_v1_stage2;
                    let mut filtered_sample = match filter_type {
                        0 => filter_low_stage2,
                        1 => filter_low,
                        2 => filter_high,
                        3 => filter_band,
                        4 => {
                            let mut out = [0.0f32];
                            dsp_state.moog_keybed[slot]
                                .tick(&[slot_sample, cutoff_hz, filter_moog_q], &mut out);
                            out[0]
                        }
                        _ => filter_low,
                    };
                    if !filtered_sample.is_finite() {
                        filtered_sample = slot_sample;
                        keybed_filter_v1[slot] = 0.0;
                        keybed_filter_v2[slot] = 0.0;
                        keybed_filter_v1_stage2[slot] = 0.0;
                        keybed_filter_v2_stage2[slot] = 0.0;
                    } else {
                        filter_v1 = filter_band;
                        filter_v2 = filter_low;
                        filter_v1_stage2 = filter_band_stage2;
                        filter_v2_stage2 = filter_low_stage2;
                        keybed_filter_v1[slot] = filter_v1;
                        keybed_filter_v2[slot] = filter_v2;
                        keybed_filter_v1_stage2[slot] = filter_v1_stage2;
                        keybed_filter_v2_stage2[slot] = filter_v2_stage2;
                    }
                    slot_sample = filtered_sample;

                    let amp_level = if slot == 0 {
                        keybed_slot_a_amp_level
                    } else {
                        keybed_amp_level
                    };
                    let level = f32::from_bits(track.animate_slot_level[slot].load(Ordering::Relaxed))
                        * weights[slot]
                        * amp_level;
                    let pan = f32::from_bits(track.animate_slot_pan[slot].load(Ordering::Relaxed))
                        .clamp(-1.0, 1.0);
                    let left_gain = (1.0 - pan).min(1.0);
                    let right_gain = (1.0 + pan).min(1.0);
                    mixed_sample_l += slot_sample * level * left_gain;
                    mixed_sample_r += slot_sample * level * right_gain;
                }
            }

            for ch in 0..num_channels.min(2) {
                let input = if ch == 0 { mixed_sample_l } else { mixed_sample_r };
                output[ch][sample_idx] += input;
            }
        }

        if transport_running {
            track
                .animate_sequencer_phase
                .store(sequencer_phase.round().max(0.0) as u32, Ordering::Relaxed);
        }
        track.animate_vector_x_smooth.store(x_smooth.to_bits(), Ordering::Relaxed);
        track.animate_vector_y_smooth.store(y_smooth.to_bits(), Ordering::Relaxed);
        track
            .animate_lfo_x_phase
            .store(lfo_x_phase.to_bits(), Ordering::Relaxed);
        track
            .animate_lfo_x_snh
            .store(lfo_x_snh.to_bits(), Ordering::Relaxed);
        track
            .animate_lfo_y_phase
            .store(lfo_y_phase.to_bits(), Ordering::Relaxed);
        track
            .animate_lfo_y_snh
            .store(lfo_y_snh.to_bits(), Ordering::Relaxed);
        track
            .animate_lfo_rng_state
            .store(lfo_rng_state, Ordering::Relaxed);
        for slot in 0..4 {
            track.animate_slot_wt_lfo_phase[slot]
                .store(wt_lfo_phase[slot].to_bits(), Ordering::Relaxed);
            track.animate_slot_wt_lfo_snh[slot]
                .store(wt_lfo_snh[slot].to_bits(), Ordering::Relaxed);
        }
        for i in 0..10 {
            track.animate_amp_stage[i].store(amp_stages[i], Ordering::Relaxed);
            track.animate_amp_level[i].store(amp_levels[i].to_bits(), Ordering::Relaxed);
            track
                .animate_slot_a_amp_stage[i]
                .store(slot_a_amp_stages[i], Ordering::Relaxed);
            track
                .animate_slot_a_amp_level[i]
                .store(slot_a_amp_levels[i].to_bits(), Ordering::Relaxed);
        }
        track
            .animate_keybed_amp_stage
            .store(keybed_amp_stage, Ordering::Relaxed);
        track
            .animate_keybed_amp_level
            .store(keybed_amp_level.to_bits(), Ordering::Relaxed);
        track
            .animate_keybed_slot_a_amp_stage
            .store(keybed_slot_a_amp_stage, Ordering::Relaxed);
        track
            .animate_keybed_slot_a_amp_level
            .store(keybed_slot_a_amp_level.to_bits(), Ordering::Relaxed);
        for slot in 0..4 {
            track
                .animate_keybed_slot_phases[slot]
                .store(keybed_phases[slot].to_bits(), Ordering::Relaxed);
            track
                .animate_keybed_slot_sample_pos[slot]
                .store(keybed_sample_pos[slot].to_bits(), Ordering::Relaxed);
            track
                .animate_keybed_filter_v1[slot]
                .store(keybed_filter_v1[slot].to_bits(), Ordering::Relaxed);
            track
                .animate_keybed_filter_v2[slot]
                .store(keybed_filter_v2[slot].to_bits(), Ordering::Relaxed);
            track
                .animate_keybed_filter_v1_stage2[slot]
                .store(keybed_filter_v1_stage2[slot].to_bits(), Ordering::Relaxed);
            track
                .animate_keybed_filter_v2_stage2[slot]
                .store(keybed_filter_v2_stage2[slot].to_bits(), Ordering::Relaxed);
        }
    }

    fn process_syndrm(
        track: &Track,
        track_output: &mut [Vec<f32>],
        dsp_state: &mut SynDRMDspState,
        num_buffer_samples: usize,
        _global_tempo: &AtomicU32,
        _master_step: i32,
        master_phase: f32,
        master_step_count: i64,
        samples_per_step: f32,
        sample_rate: f32,
        transport_running: bool,
    ) {
        let sr = sample_rate.max(1.0);
        dsp_state.set_sample_rate(sr);
        let mut max_active_step = None;
        for i in 0..SYNDRM_STEPS {
            let mut active = track.kick_sequencer_grid[i].load(Ordering::Relaxed)
                || track.snare_sequencer_grid[i].load(Ordering::Relaxed)
                || track.clap_sequencer_grid[i].load(Ordering::Relaxed)
                || track.hat_sequencer_grid[i].load(Ordering::Relaxed)
                || track.perc1_sequencer_grid[i].load(Ordering::Relaxed)
                || track.perc2_sequencer_grid[i].load(Ordering::Relaxed)
                || track.crash_sequencer_grid[i].load(Ordering::Relaxed);
            if !active {
                for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                    if track.samp_sequencer_grid[samp_idx][i].load(Ordering::Relaxed) {
                        active = true;
                        break;
                    }
                }
            }
            if active {
                max_active_step = Some(i);
            }
        }
        let mut loop_steps = SYNDRM_PAGE_SIZE;
        if let Some(max_step) = max_active_step {
            loop_steps = ((max_step / SYNDRM_PAGE_SIZE) + 1) * SYNDRM_PAGE_SIZE;
        }
        let loop_steps_i32 = loop_steps.max(1) as i32;
        let mut sequencer_phase = if transport_running {
            master_phase
        } else {
            f32::from_bits(track.kick_sequencer_phase.load(Ordering::Relaxed))
        };
        let mut current_step = if transport_running {
            (master_step_count as i32).rem_euclid(loop_steps_i32)
        } else {
            let step = track.kick_sequencer_step.load(Ordering::Relaxed);
            if step < 0 {
                step
            } else {
                step.rem_euclid(loop_steps_i32)
            }
        };
        if transport_running {
            track.kick_sequencer_step.store(current_step, Ordering::Relaxed);
            track.snare_sequencer_step.store(current_step, Ordering::Relaxed);
            track.clap_sequencer_step.store(current_step, Ordering::Relaxed);
            track.hat_sequencer_step.store(current_step, Ordering::Relaxed);
            track.perc1_sequencer_step.store(current_step, Ordering::Relaxed);
            track.perc2_sequencer_step.store(current_step, Ordering::Relaxed);
            track.crash_sequencer_step.store(current_step, Ordering::Relaxed);
            for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                track.samp_sequencer_step[samp_idx].store(current_step, Ordering::Relaxed);
            }
        }

        let mut kick_pitch_base =
            f32::from_bits(track.kick_pitch.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut kick_decay_base =
            f32::from_bits(track.kick_decay.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut kick_attack_base =
            f32::from_bits(track.kick_attack.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let kick_pitch_env_amount =
            f32::from_bits(track.kick_pitch_env_amount.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut kick_drive_base =
            f32::from_bits(track.kick_drive.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let track_muted = track.is_muted.load(Ordering::Relaxed);
        let mut kick_level_base =
            f32::from_bits(track.kick_level.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut kick_filter_type_base = track.kick_filter_type.load(Ordering::Relaxed);
        let mut kick_filter_cutoff_base =
            f32::from_bits(track.kick_filter_cutoff.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut kick_filter_resonance_base =
            f32::from_bits(track.kick_filter_resonance.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let kick_filter_pre_drive = track.kick_filter_pre_drive.load(Ordering::Relaxed);
        let mut snare_tone_base =
            f32::from_bits(track.snare_tone.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut snare_decay_base =
            f32::from_bits(track.snare_decay.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut snare_snappy_base =
            f32::from_bits(track.snare_snappy.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut snare_attack_base =
            f32::from_bits(track.snare_attack.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut snare_drive_base =
            f32::from_bits(track.snare_drive.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut snare_level_base =
            f32::from_bits(track.snare_level.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut snare_filter_type_base = track.snare_filter_type.load(Ordering::Relaxed);
        let mut snare_filter_cutoff_base =
            f32::from_bits(track.snare_filter_cutoff.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut snare_filter_resonance_base =
            f32::from_bits(track.snare_filter_resonance.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let snare_filter_pre_drive = track.snare_filter_pre_drive.load(Ordering::Relaxed);
        let mut clap_pitch_base =
            f32::from_bits(track.clap_pitch.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut clap_decay_base =
            f32::from_bits(track.clap_decay.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut clap_tone_base =
            f32::from_bits(track.clap_tone.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut clap_drive_base =
            f32::from_bits(track.clap_drive.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut clap_level_base =
            f32::from_bits(track.clap_level.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut clap_filter_type_base = track.clap_filter_type.load(Ordering::Relaxed);
        let mut clap_filter_cutoff_base =
            f32::from_bits(track.clap_filter_cutoff.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut clap_filter_resonance_base =
            f32::from_bits(track.clap_filter_resonance.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let clap_filter_pre_drive = track.clap_filter_pre_drive.load(Ordering::Relaxed);
        let mut hat_pitch_base =
            f32::from_bits(track.hat_pitch.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut hat_decay_base =
            f32::from_bits(track.hat_decay.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut hat_tone_base =
            f32::from_bits(track.hat_tone.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut hat_drive_base =
            f32::from_bits(track.hat_drive.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut hat_level_base =
            f32::from_bits(track.hat_level.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut hat_filter_type_base = track.hat_filter_type.load(Ordering::Relaxed);
        let mut hat_filter_cutoff_base =
            f32::from_bits(track.hat_filter_cutoff.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut hat_filter_resonance_base =
            f32::from_bits(track.hat_filter_resonance.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let hat_filter_pre_drive = track.hat_filter_pre_drive.load(Ordering::Relaxed);
        let mut perc1_pitch_base =
            f32::from_bits(track.perc1_pitch.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut perc1_decay_base =
            f32::from_bits(track.perc1_decay.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut perc1_tone_base =
            f32::from_bits(track.perc1_tone.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut perc1_drive_base =
            f32::from_bits(track.perc1_drive.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut perc1_level_base =
            f32::from_bits(track.perc1_level.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut perc1_filter_type_base = track.perc1_filter_type.load(Ordering::Relaxed);
        let mut perc1_filter_cutoff_base =
            f32::from_bits(track.perc1_filter_cutoff.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut perc1_filter_resonance_base =
            f32::from_bits(track.perc1_filter_resonance.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let perc1_filter_pre_drive = track.perc1_filter_pre_drive.load(Ordering::Relaxed);
        let mut perc2_pitch_base =
            f32::from_bits(track.perc2_pitch.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut perc2_decay_base =
            f32::from_bits(track.perc2_decay.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut perc2_tone_base =
            f32::from_bits(track.perc2_tone.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut perc2_drive_base =
            f32::from_bits(track.perc2_drive.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut perc2_level_base =
            f32::from_bits(track.perc2_level.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut perc2_filter_type_base = track.perc2_filter_type.load(Ordering::Relaxed);
        let mut perc2_filter_cutoff_base =
            f32::from_bits(track.perc2_filter_cutoff.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut perc2_filter_resonance_base =
            f32::from_bits(track.perc2_filter_resonance.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let perc2_filter_pre_drive = track.perc2_filter_pre_drive.load(Ordering::Relaxed);
        let mut crash_pitch_base =
            f32::from_bits(track.crash_pitch.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut crash_decay_base =
            f32::from_bits(track.crash_decay.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut crash_tone_base =
            f32::from_bits(track.crash_tone.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut crash_drive_base =
            f32::from_bits(track.crash_drive.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut crash_level_base =
            f32::from_bits(track.crash_level.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut crash_filter_type_base = track.crash_filter_type.load(Ordering::Relaxed);
        let mut crash_filter_cutoff_base =
            f32::from_bits(track.crash_filter_cutoff.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut crash_filter_resonance_base =
            f32::from_bits(track.crash_filter_resonance.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let crash_filter_pre_drive = track.crash_filter_pre_drive.load(Ordering::Relaxed);
        let kick_cut_group = track.kick_cut_group.load(Ordering::Relaxed);
        let kick_cut_by = track.kick_cut_by.load(Ordering::Relaxed);
        let kick_prob = f32::from_bits(track.kick_prob.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let snare_cut_group = track.snare_cut_group.load(Ordering::Relaxed);
        let snare_cut_by = track.snare_cut_by.load(Ordering::Relaxed);
        let snare_prob =
            f32::from_bits(track.snare_prob.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let clap_cut_group = track.clap_cut_group.load(Ordering::Relaxed);
        let clap_cut_by = track.clap_cut_by.load(Ordering::Relaxed);
        let clap_prob =
            f32::from_bits(track.clap_prob.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let hat_cut_group = track.hat_cut_group.load(Ordering::Relaxed);
        let hat_cut_by = track.hat_cut_by.load(Ordering::Relaxed);
        let hat_prob =
            f32::from_bits(track.hat_prob.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let perc1_cut_group = track.perc1_cut_group.load(Ordering::Relaxed);
        let perc1_cut_by = track.perc1_cut_by.load(Ordering::Relaxed);
        let perc1_prob =
            f32::from_bits(track.perc1_prob.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let perc2_cut_group = track.perc2_cut_group.load(Ordering::Relaxed);
        let perc2_cut_by = track.perc2_cut_by.load(Ordering::Relaxed);
        let perc2_prob =
            f32::from_bits(track.perc2_prob.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let crash_cut_group = track.crash_cut_group.load(Ordering::Relaxed);
        let crash_cut_by = track.crash_cut_by.load(Ordering::Relaxed);
        let crash_prob =
            f32::from_bits(track.crash_prob.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let samp_cut_group: [u32; SYNDRM_SAMPLE_CHANNELS] =
            std::array::from_fn(|idx| track.samp_cut_group[idx].load(Ordering::Relaxed));
        let samp_cut_by: [u32; SYNDRM_SAMPLE_CHANNELS] =
            std::array::from_fn(|idx| track.samp_cut_by[idx].load(Ordering::Relaxed));
        let samp_prob: [f32; SYNDRM_SAMPLE_CHANNELS] = std::array::from_fn(|idx| {
            f32::from_bits(track.samp_prob[idx].load(Ordering::Relaxed)).clamp(0.0, 1.0)
        });
        let mut samp_pitch_base: [f32; SYNDRM_SAMPLE_CHANNELS] = std::array::from_fn(|idx| {
            f32::from_bits(track.samp_pitch[idx].load(Ordering::Relaxed)).clamp(0.0, 1.0)
        });
        let mut samp_attack_base: [f32; SYNDRM_SAMPLE_CHANNELS] = std::array::from_fn(|idx| {
            f32::from_bits(track.samp_attack[idx].load(Ordering::Relaxed)).clamp(0.0, 1.0)
        });
        let mut samp_decay_base: [f32; SYNDRM_SAMPLE_CHANNELS] = std::array::from_fn(|idx| {
            f32::from_bits(track.samp_decay[idx].load(Ordering::Relaxed)).clamp(0.0, 1.0)
        });
        let mut samp_drive_base: [f32; SYNDRM_SAMPLE_CHANNELS] = std::array::from_fn(|idx| {
            f32::from_bits(track.samp_drive[idx].load(Ordering::Relaxed)).clamp(0.0, 1.0)
        });
        let mut samp_level_base: [f32; SYNDRM_SAMPLE_CHANNELS] = std::array::from_fn(|idx| {
            f32::from_bits(track.samp_level[idx].load(Ordering::Relaxed)).clamp(0.0, 1.0)
        });
        let mut samp_filter_type_base: [u32; SYNDRM_SAMPLE_CHANNELS] =
            std::array::from_fn(|idx| track.samp_filter_type[idx].load(Ordering::Relaxed));
        let mut samp_filter_cutoff_base: [f32; SYNDRM_SAMPLE_CHANNELS] =
            std::array::from_fn(|idx| {
            f32::from_bits(track.samp_filter_cutoff[idx].load(Ordering::Relaxed)).clamp(0.0, 1.0)
        });
        let mut samp_filter_resonance_base: [f32; SYNDRM_SAMPLE_CHANNELS] =
            std::array::from_fn(|idx| {
            f32::from_bits(track.samp_filter_resonance[idx].load(Ordering::Relaxed))
                .clamp(0.0, 1.0)
        });
        let samp_filter_pre_drive: [bool; SYNDRM_SAMPLE_CHANNELS] =
            std::array::from_fn(|idx| {
            track.samp_filter_pre_drive[idx].load(Ordering::Relaxed)
        });

        let samp_samples: [Option<Arc<Vec<Vec<f32>>>>; SYNDRM_SAMPLE_CHANNELS] =
            std::array::from_fn(|idx| {
                if let Some(guard) = track.samp_samples[idx].try_lock() {
                    guard.as_ref().map(Arc::clone)
                } else {
                    None
                }
            });
        let samp_sample_rate: [u32; SYNDRM_SAMPLE_CHANNELS] = std::array::from_fn(|idx| {
            track.samp_sample_rate[idx].load(Ordering::Relaxed).max(1)
        });
        let samp_sample_len: [u32; SYNDRM_SAMPLE_CHANNELS] =
            std::array::from_fn(|idx| track.samp_sample_len[idx].load(Ordering::Relaxed));

        let mut env = f32::from_bits(track.kick_env.load(Ordering::Relaxed));
        let mut pitch_env = f32::from_bits(track.kick_pitch_env.load(Ordering::Relaxed));
        let mut attack_remaining = track.kick_attack_remaining.load(Ordering::Relaxed);
        let mut snare_env = f32::from_bits(track.snare_env.load(Ordering::Relaxed));
        let mut snare_noise_env =
            f32::from_bits(track.snare_noise_env.load(Ordering::Relaxed));
        let mut snare_attack_remaining =
            track.snare_attack_remaining.load(Ordering::Relaxed);
        let mut clap_env = f32::from_bits(track.clap_env.load(Ordering::Relaxed));
        let mut clap_phase = track.clap_phase.load(Ordering::Relaxed);
        let mut hat_env = f32::from_bits(track.hat_env.load(Ordering::Relaxed));
        let mut hat_attack_remaining = track.hat_attack_remaining.load(Ordering::Relaxed);
        let mut hat_phase = f32::from_bits(track.hat_phase.load(Ordering::Relaxed));
        let mut hat_phases = [0.0f32; 6];
        let mut hat_mod_phases = [0.0f32; 6];
        for i in 0..METAL_INHARM_RATIOS.len() {
            hat_phases[i] = f32::from_bits(track.hat_phases[i].load(Ordering::Relaxed));
            hat_mod_phases[i] = f32::from_bits(track.hat_mod_phases[i].load(Ordering::Relaxed));
        }
        let mut hat_hp_x_prev = f32::from_bits(track.hat_hp_x_prev.load(Ordering::Relaxed));
        let mut hat_hp_y_prev = f32::from_bits(track.hat_hp_y_prev.load(Ordering::Relaxed));
        let mut perc1_attack_remaining = track.perc1_attack_remaining.load(Ordering::Relaxed);
        let perc1_line_len = dsp_state.perc1_karplus_line.len().max(2);
        let mut perc1_pos = dsp_state.perc1_karplus_pos.min(perc1_line_len - 1);
        let mut perc1_delay_len = dsp_state
            .perc1_karplus_delay
            .clamp(2, perc1_line_len - 1);
        let mut perc2_env = f32::from_bits(track.perc2_env.load(Ordering::Relaxed));
        let mut perc2_carrier_phase =
            f32::from_bits(track.perc2_carrier_phase.load(Ordering::Relaxed));
        let mut perc2_mod_phase = f32::from_bits(track.perc2_mod_phase.load(Ordering::Relaxed));
        let mut crash_env = f32::from_bits(track.crash_env.load(Ordering::Relaxed));
        let mut crash_attack_remaining = track.crash_attack_remaining.load(Ordering::Relaxed);
        let mut crash_phase = f32::from_bits(track.crash_phase.load(Ordering::Relaxed));
        let mut crash_phases = [0.0f32; 6];
        let mut crash_mod_phases = [0.0f32; 6];
        for i in 0..METAL_INHARM_RATIOS.len() {
            crash_phases[i] = f32::from_bits(track.crash_phases[i].load(Ordering::Relaxed));
            crash_mod_phases[i] = f32::from_bits(track.crash_mod_phases[i].load(Ordering::Relaxed));
        }
        let mut crash_hp_x_prev =
            f32::from_bits(track.crash_hp_x_prev.load(Ordering::Relaxed));
        let mut crash_hp_y_prev =
            f32::from_bits(track.crash_hp_y_prev.load(Ordering::Relaxed));
        let mut samp_env: [f32; SYNDRM_SAMPLE_CHANNELS] = std::array::from_fn(|idx| {
            f32::from_bits(track.samp_env[idx].load(Ordering::Relaxed))
        });
        let mut samp_playhead: [f32; SYNDRM_SAMPLE_CHANNELS] = std::array::from_fn(|idx| {
            f32::from_bits(track.samp_playhead[idx].load(Ordering::Relaxed))
        });
        let mut samp_attack_remaining: [u32; SYNDRM_SAMPLE_CHANNELS] =
            std::array::from_fn(|idx| track.samp_attack_remaining[idx].load(Ordering::Relaxed));
        let mut samp_decay_remaining: [u32; SYNDRM_SAMPLE_CHANNELS] =
            std::array::from_fn(|idx| track.samp_decay_remaining[idx].load(Ordering::Relaxed));

        let cutoff_min = 20.0;
        let cutoff_max = 12_000.0;
        let cutoff_span: f32 = cutoff_max / cutoff_min;
        let step_hold = track.syndrm_step_hold.load(Ordering::Relaxed);
        let mut rng_state = track.syndrm_rng_state.load(Ordering::Relaxed);
        let mut kick_retrig_remaining = track.kick_retrig_remaining.load(Ordering::Relaxed);
        let mut kick_retrig_timer =
            f32::from_bits(track.kick_retrig_timer.load(Ordering::Relaxed));
        let mut snare_retrig_remaining = track.snare_retrig_remaining.load(Ordering::Relaxed);
        let mut snare_retrig_timer =
            f32::from_bits(track.snare_retrig_timer.load(Ordering::Relaxed));
        let mut clap_retrig_remaining = track.clap_retrig_remaining.load(Ordering::Relaxed);
        let mut clap_retrig_timer =
            f32::from_bits(track.clap_retrig_timer.load(Ordering::Relaxed));
        let mut hat_retrig_remaining = track.hat_retrig_remaining.load(Ordering::Relaxed);
        let mut hat_retrig_timer =
            f32::from_bits(track.hat_retrig_timer.load(Ordering::Relaxed));
        let mut perc1_retrig_remaining = track.perc1_retrig_remaining.load(Ordering::Relaxed);
        let mut perc1_retrig_timer =
            f32::from_bits(track.perc1_retrig_timer.load(Ordering::Relaxed));
        let mut perc2_retrig_remaining = track.perc2_retrig_remaining.load(Ordering::Relaxed);
        let mut perc2_retrig_timer =
            f32::from_bits(track.perc2_retrig_timer.load(Ordering::Relaxed));
        let mut crash_retrig_remaining = track.crash_retrig_remaining.load(Ordering::Relaxed);
        let mut crash_retrig_timer =
            f32::from_bits(track.crash_retrig_timer.load(Ordering::Relaxed));
        let mut samp_retrig_remaining: [u32; SYNDRM_SAMPLE_CHANNELS] =
            std::array::from_fn(|idx| track.samp_retrig_remaining[idx].load(Ordering::Relaxed));
        let mut samp_retrig_timer: [f32; SYNDRM_SAMPLE_CHANNELS] = std::array::from_fn(|idx| {
            f32::from_bits(track.samp_retrig_timer[idx].load(Ordering::Relaxed))
        });
        let mut kick_retrig_interval = 0.0f32;
        let mut snare_retrig_interval = 0.0f32;
        let mut clap_retrig_interval = 0.0f32;
        let mut hat_retrig_interval = 0.0f32;
        let mut perc1_retrig_interval = 0.0f32;
        let mut perc2_retrig_interval = 0.0f32;
        let mut crash_retrig_interval = 0.0f32;
        let mut samp_retrig_interval = [0.0f32; SYNDRM_SAMPLE_CHANNELS];
        let mut arm_retrig = |enabled: bool,
                              division: u32,
                              triggered: bool,
                              remaining: &mut u32,
                              timer: &mut f32,
                              interval: &mut f32| {
            if triggered && enabled {
                let div: u32 = if division <= 2 { 2 } else { 4 };
                *interval = if samples_per_step > 0.0 {
                    samples_per_step / div as f32
                } else {
                    0.0
                };
                *remaining = div.saturating_sub(1);
                *timer = *interval;
            } else {
                *remaining = 0;
                *timer = 0.0;
                *interval = 0.0;
            }
        };
        if !transport_running {
            kick_retrig_remaining = 0;
            kick_retrig_timer = 0.0;
            snare_retrig_remaining = 0;
            snare_retrig_timer = 0.0;
            clap_retrig_remaining = 0;
            clap_retrig_timer = 0.0;
            hat_retrig_remaining = 0;
            hat_retrig_timer = 0.0;
            perc1_retrig_remaining = 0;
            perc1_retrig_timer = 0.0;
            perc2_retrig_remaining = 0;
            perc2_retrig_timer = 0.0;
            crash_retrig_remaining = 0;
            crash_retrig_timer = 0.0;
            for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                samp_retrig_remaining[samp_idx] = 0;
                samp_retrig_timer[samp_idx] = 0.0;
            }
        } else if current_step >= 0 && samples_per_step > 0.0 {
            let step_idx = current_step as usize;
            if step_idx < SYNDRM_STEPS {
                if kick_retrig_remaining > 0 && kick_retrig_interval <= 0.0 {
                    let div = track.kick_step_retrig_division[step_idx]
                        .load(Ordering::Relaxed)
                        .max(1);
                    let div = if div <= 2 { 2 } else { 4 };
                    kick_retrig_interval = samples_per_step / div as f32;
                }
                if snare_retrig_remaining > 0 && snare_retrig_interval <= 0.0 {
                    let div = track.snare_step_retrig_division[step_idx]
                        .load(Ordering::Relaxed)
                        .max(1);
                    let div = if div <= 2 { 2 } else { 4 };
                    snare_retrig_interval = samples_per_step / div as f32;
                }
                if clap_retrig_remaining > 0 && clap_retrig_interval <= 0.0 {
                    let div = track.clap_step_retrig_division[step_idx]
                        .load(Ordering::Relaxed)
                        .max(1);
                    let div = if div <= 2 { 2 } else { 4 };
                    clap_retrig_interval = samples_per_step / div as f32;
                }
                if hat_retrig_remaining > 0 && hat_retrig_interval <= 0.0 {
                    let div = track.hat_step_retrig_division[step_idx]
                        .load(Ordering::Relaxed)
                        .max(1);
                    let div = if div <= 2 { 2 } else { 4 };
                    hat_retrig_interval = samples_per_step / div as f32;
                }
                if perc1_retrig_remaining > 0 && perc1_retrig_interval <= 0.0 {
                    let div = track.perc1_step_retrig_division[step_idx]
                        .load(Ordering::Relaxed)
                        .max(1);
                    let div = if div <= 2 { 2 } else { 4 };
                    perc1_retrig_interval = samples_per_step / div as f32;
                }
                if perc2_retrig_remaining > 0 && perc2_retrig_interval <= 0.0 {
                    let div = track.perc2_step_retrig_division[step_idx]
                        .load(Ordering::Relaxed)
                        .max(1);
                    let div = if div <= 2 { 2 } else { 4 };
                    perc2_retrig_interval = samples_per_step / div as f32;
                }
                if crash_retrig_remaining > 0 && crash_retrig_interval <= 0.0 {
                    let div = track.crash_step_retrig_division[step_idx]
                        .load(Ordering::Relaxed)
                        .max(1);
                    let div = if div <= 2 { 2 } else { 4 };
                    crash_retrig_interval = samples_per_step / div as f32;
                }
                for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                    if samp_retrig_remaining[samp_idx] > 0
                        && samp_retrig_interval[samp_idx] <= 0.0
                    {
                        let div = track.samp_step_retrig_division[samp_idx][step_idx]
                            .load(Ordering::Relaxed)
                            .max(1);
                        let div = if div <= 2 { 2 } else { 4 };
                        samp_retrig_interval[samp_idx] = samples_per_step / div as f32;
                    }
                }
            }
        }

        let mut kick_pitch = kick_pitch_base;
        let mut kick_decay = kick_decay_base;
        let mut kick_attack = kick_attack_base;
        let mut kick_drive = kick_drive_base;
        let mut kick_level = kick_level_base;
        let mut kick_filter_type = kick_filter_type_base;
        let mut kick_filter_cutoff = kick_filter_cutoff_base;
        let mut kick_filter_resonance = kick_filter_resonance_base;
        let mut snare_tone = snare_tone_base;
        let mut snare_decay = snare_decay_base;
        let mut snare_snappy = snare_snappy_base;
        let mut snare_attack = snare_attack_base;
        let mut snare_drive = snare_drive_base;
        let mut snare_level = snare_level_base;
        let mut snare_filter_type = snare_filter_type_base;
        let mut snare_filter_cutoff = snare_filter_cutoff_base;
        let mut snare_filter_resonance = snare_filter_resonance_base;
        let mut clap_pitch = clap_pitch_base;
        let mut clap_decay = clap_decay_base;
        let mut clap_tone = clap_tone_base;
        let mut clap_drive = clap_drive_base;
        let mut clap_level = clap_level_base;
        let mut clap_filter_type = clap_filter_type_base;
        let mut clap_filter_cutoff = clap_filter_cutoff_base;
        let mut clap_filter_resonance = clap_filter_resonance_base;
        let mut hat_pitch = hat_pitch_base;
        let mut hat_decay = hat_decay_base;
        let mut hat_tone = hat_tone_base;
        let mut hat_drive = hat_drive_base;
        let mut hat_level = hat_level_base;
        let mut hat_filter_type = hat_filter_type_base;
        let mut hat_filter_cutoff = hat_filter_cutoff_base;
        let mut hat_filter_resonance = hat_filter_resonance_base;
        let mut perc1_pitch = perc1_pitch_base;
        let mut perc1_decay = perc1_decay_base;
        let mut perc1_tone = perc1_tone_base;
        let mut perc1_drive = perc1_drive_base;
        let mut perc1_level = perc1_level_base;
        let mut perc1_filter_type = perc1_filter_type_base;
        let mut perc1_filter_cutoff = perc1_filter_cutoff_base;
        let mut perc1_filter_resonance = perc1_filter_resonance_base;
        let mut perc2_pitch = perc2_pitch_base;
        let mut perc2_decay = perc2_decay_base;
        let mut perc2_tone = perc2_tone_base;
        let mut perc2_drive = perc2_drive_base;
        let mut perc2_level = perc2_level_base;
        let mut perc2_filter_type = perc2_filter_type_base;
        let mut perc2_filter_cutoff = perc2_filter_cutoff_base;
        let mut perc2_filter_resonance = perc2_filter_resonance_base;
        let mut crash_pitch = crash_pitch_base;
        let mut crash_decay = crash_decay_base;
        let mut crash_tone = crash_tone_base;
        let mut crash_drive = crash_drive_base;
        let mut crash_level = crash_level_base;
        let mut crash_filter_type = crash_filter_type_base;
        let mut crash_filter_cutoff = crash_filter_cutoff_base;
        let mut crash_filter_resonance = crash_filter_resonance_base;
        let mut samp_pitch: [f32; SYNDRM_SAMPLE_CHANNELS] = samp_pitch_base;
        let mut samp_attack: [f32; SYNDRM_SAMPLE_CHANNELS] = samp_attack_base;
        let mut samp_decay: [f32; SYNDRM_SAMPLE_CHANNELS] = samp_decay_base;
        let mut samp_drive: [f32; SYNDRM_SAMPLE_CHANNELS] = samp_drive_base;
        let mut samp_level: [f32; SYNDRM_SAMPLE_CHANNELS] = samp_level_base;
        let mut samp_filter_type: [u32; SYNDRM_SAMPLE_CHANNELS] = samp_filter_type_base;
        let mut samp_filter_cutoff: [f32; SYNDRM_SAMPLE_CHANNELS] = samp_filter_cutoff_base;
        let mut samp_filter_resonance: [f32; SYNDRM_SAMPLE_CHANNELS] = samp_filter_resonance_base;

        let mut decay_time = 0.05 + kick_decay * 1.5;
        let mut pitch_decay_time = (0.01 + kick_decay * 0.25)
            * (1.0 - 0.7 * kick_pitch_env_amount).max(0.1);
        let mut env_coeff = (-1.0 / (decay_time * sr)).exp();
        let mut attack_time = kick_attack * 0.01;
        let mut attack_samples = (attack_time * sr).round().max(0.0) as u32;
        let mut attack_step = if attack_samples > 0 {
            1.0 / attack_samples as f32
        } else {
            1.0
        };
        let mut pitch_coeff = (-1.0 / (pitch_decay_time * sr)).exp();
        let mut base_freq = 40.0 + kick_pitch * 120.0;
        let mut sweep = base_freq * (kick_pitch_env_amount * 4.0);
        let mut drive = 1.0 + kick_drive * 8.0;
        let mut kick_cutoff_hz = cutoff_min * cutoff_span.powf(kick_filter_cutoff);
        let mut kick_q = 0.1 + kick_filter_resonance * 0.9;
        let mut snare_decay_time = 0.03 + snare_decay * 0.4;
        let mut snare_noise_decay_time = 0.02 + snare_decay * 0.2;
        let mut snare_env_coeff = (-1.0 / (snare_decay_time * sr)).exp();
        let mut snare_noise_coeff = (-1.0 / (snare_noise_decay_time * sr)).exp();
        let mut snare_attack_time = snare_attack * 0.01;
        let mut snare_attack_samples = (snare_attack_time * sr).round().max(0.0) as u32;
        let mut snare_attack_step = if snare_attack_samples > 0 {
            1.0 / snare_attack_samples as f32
        } else {
            1.0
        };
        let mut snare_freq = 180.0 + snare_tone * 420.0;
        let mut snare_cutoff_hz = cutoff_min * cutoff_span.powf(snare_filter_cutoff);
        let mut snare_q = 0.1 + snare_filter_resonance * 0.9;
        let mut snare_drive_gain = 1.0 + snare_drive * 8.0;
        let mut clap_decay_time = 0.04 + clap_decay * 0.6;
        let mut clap_env_coeff = (-1.0 / (clap_decay_time * sr)).exp();
        let mut clap_burst_decay_time = 0.005 + (1.0 - clap_tone) * 0.02;
        let mut clap_burst_inv = 1.0 / (clap_burst_decay_time * sr);
        let mut clap_cutoff_hz = cutoff_min * cutoff_span.powf(clap_filter_cutoff);
        let mut clap_q = 0.1 + clap_filter_resonance * 0.9;
        let mut clap_drive_gain = 1.0 + clap_drive * 8.0;
        clap_cutoff_hz = (clap_cutoff_hz * (0.5 + clap_pitch * 1.5)).min(cutoff_min * cutoff_span);
        let clap_burst_delay_1 = (0.012 * sr).round() as u32;
        let clap_burst_delay_2 = (0.024 * sr).round() as u32;
        let clap_burst_delay_3 = (0.036 * sr).round() as u32;
        let mut hat_decay_time = 0.01 + hat_decay * 1.49;
        let mut hat_env_coeff = (-1.0 / (hat_decay_time * sr)).exp();
        let hat_attack_time = 0.001;
        let mut hat_attack_samples = (hat_attack_time * sr).round().max(0.0) as u32;
        let mut hat_attack_step = if hat_attack_samples > 0 {
            1.0 / hat_attack_samples as f32
        } else {
            1.0
        };
        let mut hat_freq = 100.0 + hat_pitch * 11_900.0;
        let mut hat_harmonicity = 5.0 + hat_tone * 3.0;
        let mut hat_mod_index = 10.0 + hat_tone * 20.0;
        let mut hat_cutoff_hz = cutoff_min * cutoff_span.powf(hat_filter_cutoff);
        let mut hat_q = 0.1 + hat_filter_resonance * 0.9;
        let mut hat_drive_gain = 1.0 + hat_drive * 8.0;
        let mut perc1_decay_time = 0.05 + perc1_decay * 1.5;
        let mut perc1_decay_coeff = (-1.0 / (perc1_decay_time * sr)).exp();
        let mut perc1_attack_time = 0.002 + perc1_decay * 0.008;
        let mut perc1_attack_samples = (perc1_attack_time * sr).round().max(0.0) as u32;
        let mut perc1_attack_step = if perc1_attack_samples > 0 {
            1.0 / perc1_attack_samples as f32
        } else {
            1.0
        };
        let mut perc1_freq = 80.0 + perc1_pitch * 6000.0;
        let mut perc1_cutoff_hz = cutoff_min * cutoff_span.powf(perc1_filter_cutoff);
        let mut perc1_q = 0.1 + perc1_filter_resonance * 0.9;
        let mut perc1_drive_gain = 1.0 + perc1_drive * 8.0;
        let mut perc1_damping = 0.5 + (1.0 - perc1_tone) * 0.45;
        let mut perc2_decay_time = 0.001 + perc2_decay * 1.0;
        let mut perc2_env_coeff = (-1.0 / (perc2_decay_time * sr)).exp();
        let mut perc2_freq = 60.0 + perc2_pitch * 520.0;
        let mut perc2_mod_index = 30.0 * perc2_tone + 5.0;
        let mut perc2_cutoff_hz = cutoff_min * cutoff_span.powf(perc2_filter_cutoff);
        let mut perc2_q = 0.1 + perc2_filter_resonance * 0.9;
        let mut perc2_drive_gain = 1.0 + perc2_drive * 8.0;
        let mut crash_decay_time = 0.2 + crash_decay * 3.0;
        let mut crash_env_coeff = (-1.0 / (crash_decay_time * sr)).exp();
        let crash_attack_time = 0.002;
        let mut crash_attack_samples = (crash_attack_time * sr).round().max(0.0) as u32;
        let mut crash_attack_step = if crash_attack_samples > 0 {
            1.0 / crash_attack_samples as f32
        } else {
            1.0
        };
        let mut crash_freq = 80.0 + crash_pitch * 9000.0;
        let mut crash_harmonicity = 6.0 + crash_tone * 3.0;
        let mut crash_mod_index = 12.0 + crash_tone * 20.0;
        let mut crash_cutoff_hz = cutoff_min * cutoff_span.powf(crash_filter_cutoff);
        let mut crash_q = 0.1 + crash_filter_resonance * 0.9;
        let mut crash_drive_gain = 1.0 + crash_drive * 8.0;
        let mut samp_attack_samples: [u32; SYNDRM_SAMPLE_CHANNELS] =
            [0u32; SYNDRM_SAMPLE_CHANNELS];
        let mut samp_attack_step: [f32; SYNDRM_SAMPLE_CHANNELS] =
            [1.0f32; SYNDRM_SAMPLE_CHANNELS];
        let mut samp_decay_time: [f32; SYNDRM_SAMPLE_CHANNELS] =
            [0.0f32; SYNDRM_SAMPLE_CHANNELS];
        let mut samp_decay_coeff: [f32; SYNDRM_SAMPLE_CHANNELS] =
            [0.0f32; SYNDRM_SAMPLE_CHANNELS];
        let mut samp_rate: [f32; SYNDRM_SAMPLE_CHANNELS] =
            [1.0f32; SYNDRM_SAMPLE_CHANNELS];
        let mut samp_drive_gain: [f32; SYNDRM_SAMPLE_CHANNELS] =
            [1.0f32; SYNDRM_SAMPLE_CHANNELS];
        let mut samp_cutoff_hz: [f32; SYNDRM_SAMPLE_CHANNELS] =
            [cutoff_min; SYNDRM_SAMPLE_CHANNELS];
        let mut samp_q: [f32; SYNDRM_SAMPLE_CHANNELS] =
            [0.1f32; SYNDRM_SAMPLE_CHANNELS];

        for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
            let duration = if samp_sample_len[samp_idx] > 0 {
                samp_sample_len[samp_idx] as f32 / samp_sample_rate[samp_idx] as f32
            } else {
                0.0
            };
            let attack_time = samp_attack[samp_idx] * duration;
            let decay_max = (duration - attack_time).max(0.0);
            samp_decay_time[samp_idx] = samp_decay[samp_idx] * decay_max;
            samp_attack_samples[samp_idx] = (attack_time * sr).round().max(0.0) as u32;
            samp_attack_step[samp_idx] = if samp_attack_samples[samp_idx] > 0 {
                1.0 / samp_attack_samples[samp_idx] as f32
            } else {
                1.0
            };
            samp_decay_coeff[samp_idx] = if samp_decay_time[samp_idx] > 0.0 {
                (-1.0 / (samp_decay_time[samp_idx] * sr)).exp()
            } else {
                0.0
            };
            let semitones = (samp_pitch[samp_idx] - 0.5) * 24.0;
            samp_rate[samp_idx] = 2.0f32.powf(semitones / 12.0);
            samp_drive_gain[samp_idx] = 1.0 + samp_drive[samp_idx] * 8.0;
            samp_cutoff_hz[samp_idx] = cutoff_min * cutoff_span.powf(samp_filter_cutoff[samp_idx]);
            samp_q[samp_idx] = 0.1 + samp_filter_resonance[samp_idx] * 0.9;
        }

        fn apply_kick_step_params(
            track: &Track,
            step_idx: usize,
            step_hold: bool,
            track_muted: bool,
            cutoff_min: f32,
            cutoff_span: f32,
            sr: f32,
            kick_pitch: &mut f32,
            kick_decay: &mut f32,
            kick_attack: &mut f32,
            kick_pitch_env_amount: f32,
            kick_drive: &mut f32,
            kick_level: &mut f32,
            kick_filter_type: &mut u32,
            kick_filter_cutoff: &mut f32,
            kick_filter_resonance: &mut f32,
            kick_pitch_base: &mut f32,
            kick_decay_base: &mut f32,
            kick_attack_base: &mut f32,
            kick_drive_base: &mut f32,
            kick_level_base: &mut f32,
            kick_filter_type_base: &mut u32,
            kick_filter_cutoff_base: &mut f32,
            kick_filter_resonance_base: &mut f32,
            decay_time: &mut f32,
            pitch_decay_time: &mut f32,
            env_coeff: &mut f32,
            attack_time: &mut f32,
            attack_samples: &mut u32,
            attack_step: &mut f32,
            pitch_coeff: &mut f32,
            base_freq: &mut f32,
            sweep: &mut f32,
            drive: &mut f32,
            kick_cutoff_hz: &mut f32,
            kick_q: &mut f32,
        ) {
            let override_enabled =
                track.kick_step_override_enabled[step_idx].load(Ordering::Relaxed);
            if override_enabled {
                let pitch =
                    f32::from_bits(track.kick_step_pitch[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let decay =
                    f32::from_bits(track.kick_step_decay[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let attack =
                    f32::from_bits(track.kick_step_attack[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let drive_val =
                    f32::from_bits(track.kick_step_drive[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let level =
                    f32::from_bits(track.kick_step_level[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let filter_type = track.kick_step_filter_type[step_idx].load(Ordering::Relaxed);
                let filter_cutoff = f32::from_bits(
                    track.kick_step_filter_cutoff[step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let filter_resonance = f32::from_bits(
                    track.kick_step_filter_resonance[step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);

                *kick_pitch = pitch;
                *kick_decay = decay;
                *kick_attack = attack;
                *kick_drive = drive_val;
                *kick_level = if track_muted { 0.0 } else { level };
                *kick_filter_type = filter_type;
                *kick_filter_cutoff = filter_cutoff;
                *kick_filter_resonance = filter_resonance;

                *decay_time = 0.05 + *kick_decay * 1.5;
                *pitch_decay_time = (0.01 + *kick_decay * 0.25)
                    * (1.0 - 0.7 * kick_pitch_env_amount).max(0.1);
                *env_coeff = (-1.0 / (*decay_time * sr)).exp();
                *attack_time = *kick_attack * 0.01;
                *attack_samples = (*attack_time * sr).round().max(0.0) as u32;
                *attack_step = if *attack_samples > 0 {
                    1.0 / *attack_samples as f32
                } else {
                    1.0
                };
                *pitch_coeff = (-1.0 / (*pitch_decay_time * sr)).exp();
                *base_freq = 40.0 + *kick_pitch * 120.0;
                *sweep = *base_freq * (kick_pitch_env_amount * 4.0);
                *drive = 1.0 + *kick_drive * 8.0;
                *kick_cutoff_hz = cutoff_min * cutoff_span.powf(*kick_filter_cutoff);
                *kick_q = 0.1 + *kick_filter_resonance * 0.9;

                if step_hold {
                    *kick_pitch_base = pitch;
                    *kick_decay_base = decay;
                    *kick_attack_base = attack;
                    *kick_drive_base = drive_val;
                    *kick_level_base = level;
                    *kick_filter_type_base = filter_type;
                    *kick_filter_cutoff_base = filter_cutoff;
                    *kick_filter_resonance_base = filter_resonance;
                    track.kick_pitch.store(pitch.to_bits(), Ordering::Relaxed);
                    track.kick_decay.store(decay.to_bits(), Ordering::Relaxed);
                    track.kick_attack.store(attack.to_bits(), Ordering::Relaxed);
                    track.kick_drive.store(drive_val.to_bits(), Ordering::Relaxed);
                    track.kick_level.store(level.to_bits(), Ordering::Relaxed);
                    track.kick_filter_type.store(filter_type, Ordering::Relaxed);
                    track.kick_filter_cutoff.store(filter_cutoff.to_bits(), Ordering::Relaxed);
                    track
                        .kick_filter_resonance
                        .store(filter_resonance.to_bits(), Ordering::Relaxed);
                }
            } else {
                *kick_pitch = *kick_pitch_base;
                *kick_decay = *kick_decay_base;
                *kick_attack = *kick_attack_base;
                *kick_drive = *kick_drive_base;
                *kick_level = if track_muted { 0.0 } else { *kick_level_base };
                *kick_filter_type = *kick_filter_type_base;
                *kick_filter_cutoff = *kick_filter_cutoff_base;
                *kick_filter_resonance = *kick_filter_resonance_base;

                *decay_time = 0.05 + *kick_decay * 1.5;
                *pitch_decay_time = (0.01 + *kick_decay * 0.25)
                    * (1.0 - 0.7 * kick_pitch_env_amount).max(0.1);
                *env_coeff = (-1.0 / (*decay_time * sr)).exp();
                *attack_time = *kick_attack * 0.01;
                *attack_samples = (*attack_time * sr).round().max(0.0) as u32;
                *attack_step = if *attack_samples > 0 {
                    1.0 / *attack_samples as f32
                } else {
                    1.0
                };
                *pitch_coeff = (-1.0 / (*pitch_decay_time * sr)).exp();
                *base_freq = 40.0 + *kick_pitch * 120.0;
                *sweep = *base_freq * (kick_pitch_env_amount * 4.0);
                *drive = 1.0 + *kick_drive * 8.0;
                *kick_cutoff_hz = cutoff_min * cutoff_span.powf(*kick_filter_cutoff);
                *kick_q = 0.1 + *kick_filter_resonance * 0.9;
            }
        }

        fn apply_snare_step_params(
            track: &Track,
            step_idx: usize,
            step_hold: bool,
            track_muted: bool,
            cutoff_min: f32,
            cutoff_span: f32,
            sr: f32,
            snare_tone: &mut f32,
            snare_decay: &mut f32,
            snare_snappy: &mut f32,
            snare_attack: &mut f32,
            snare_drive: &mut f32,
            snare_level: &mut f32,
            snare_filter_type: &mut u32,
            snare_filter_cutoff: &mut f32,
            snare_filter_resonance: &mut f32,
            snare_tone_base: &mut f32,
            snare_decay_base: &mut f32,
            snare_snappy_base: &mut f32,
            snare_attack_base: &mut f32,
            snare_drive_base: &mut f32,
            snare_level_base: &mut f32,
            snare_filter_type_base: &mut u32,
            snare_filter_cutoff_base: &mut f32,
            snare_filter_resonance_base: &mut f32,
            snare_decay_time: &mut f32,
            snare_noise_decay_time: &mut f32,
            snare_env_coeff: &mut f32,
            snare_noise_coeff: &mut f32,
            snare_attack_time: &mut f32,
            snare_attack_samples: &mut u32,
            snare_attack_step: &mut f32,
            snare_freq: &mut f32,
            snare_cutoff_hz: &mut f32,
            snare_q: &mut f32,
            snare_drive_gain: &mut f32,
        ) {
            let override_enabled =
                track.snare_step_override_enabled[step_idx].load(Ordering::Relaxed);
            if override_enabled {
                let tone =
                    f32::from_bits(track.snare_step_tone[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let decay =
                    f32::from_bits(track.snare_step_decay[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let snappy =
                    f32::from_bits(track.snare_step_snappy[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let attack =
                    f32::from_bits(track.snare_step_attack[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let drive_val =
                    f32::from_bits(track.snare_step_drive[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let level =
                    f32::from_bits(track.snare_step_level[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let filter_type = track.snare_step_filter_type[step_idx].load(Ordering::Relaxed);
                let filter_cutoff = f32::from_bits(
                    track.snare_step_filter_cutoff[step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let filter_resonance = f32::from_bits(
                    track.snare_step_filter_resonance[step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);

                *snare_tone = tone;
                *snare_decay = decay;
                *snare_snappy = snappy;
                *snare_attack = attack;
                *snare_drive = drive_val;
                *snare_level = if track_muted { 0.0 } else { level };
                *snare_filter_type = filter_type;
                *snare_filter_cutoff = filter_cutoff;
                *snare_filter_resonance = filter_resonance;

                *snare_decay_time = 0.03 + *snare_decay * 0.4;
                *snare_noise_decay_time = 0.02 + *snare_decay * 0.2;
                *snare_env_coeff = (-1.0 / (*snare_decay_time * sr)).exp();
                *snare_noise_coeff = (-1.0 / (*snare_noise_decay_time * sr)).exp();
                *snare_attack_time = *snare_attack * 0.01;
                *snare_attack_samples = (*snare_attack_time * sr).round().max(0.0) as u32;
                *snare_attack_step = if *snare_attack_samples > 0 {
                    1.0 / *snare_attack_samples as f32
                } else {
                    1.0
                };
                *snare_freq = 180.0 + *snare_tone * 420.0;
                *snare_cutoff_hz = cutoff_min * cutoff_span.powf(*snare_filter_cutoff);
                *snare_q = 0.1 + *snare_filter_resonance * 0.9;
                *snare_drive_gain = 1.0 + *snare_drive * 8.0;

                if step_hold {
                    *snare_tone_base = tone;
                    *snare_decay_base = decay;
                    *snare_snappy_base = snappy;
                    *snare_attack_base = attack;
                    *snare_drive_base = drive_val;
                    *snare_level_base = level;
                    *snare_filter_type_base = filter_type;
                    *snare_filter_cutoff_base = filter_cutoff;
                    *snare_filter_resonance_base = filter_resonance;
                    track.snare_tone.store(tone.to_bits(), Ordering::Relaxed);
                    track.snare_decay.store(decay.to_bits(), Ordering::Relaxed);
                    track.snare_snappy.store(snappy.to_bits(), Ordering::Relaxed);
                    track.snare_attack.store(attack.to_bits(), Ordering::Relaxed);
                    track.snare_drive.store(drive_val.to_bits(), Ordering::Relaxed);
                    track.snare_level.store(level.to_bits(), Ordering::Relaxed);
                    track.snare_filter_type.store(filter_type, Ordering::Relaxed);
                    track
                        .snare_filter_cutoff
                        .store(filter_cutoff.to_bits(), Ordering::Relaxed);
                    track
                        .snare_filter_resonance
                        .store(filter_resonance.to_bits(), Ordering::Relaxed);
                }
            } else {
                *snare_tone = *snare_tone_base;
                *snare_decay = *snare_decay_base;
                *snare_snappy = *snare_snappy_base;
                *snare_attack = *snare_attack_base;
                *snare_drive = *snare_drive_base;
                *snare_level = if track_muted { 0.0 } else { *snare_level_base };
                *snare_filter_type = *snare_filter_type_base;
                *snare_filter_cutoff = *snare_filter_cutoff_base;
                *snare_filter_resonance = *snare_filter_resonance_base;

                *snare_decay_time = 0.03 + *snare_decay * 0.4;
                *snare_noise_decay_time = 0.02 + *snare_decay * 0.2;
                *snare_env_coeff = (-1.0 / (*snare_decay_time * sr)).exp();
                *snare_noise_coeff = (-1.0 / (*snare_noise_decay_time * sr)).exp();
                *snare_attack_time = *snare_attack * 0.01;
                *snare_attack_samples = (*snare_attack_time * sr).round().max(0.0) as u32;
                *snare_attack_step = if *snare_attack_samples > 0 {
                    1.0 / *snare_attack_samples as f32
                } else {
                    1.0
                };
                *snare_freq = 180.0 + *snare_tone * 420.0;
                *snare_cutoff_hz = cutoff_min * cutoff_span.powf(*snare_filter_cutoff);
                *snare_q = 0.1 + *snare_filter_resonance * 0.9;
                *snare_drive_gain = 1.0 + *snare_drive * 8.0;
            }
        }

        fn apply_clap_step_params(
            track: &Track,
            step_idx: usize,
            step_hold: bool,
            track_muted: bool,
            cutoff_min: f32,
            cutoff_span: f32,
            sr: f32,
            clap_pitch: &mut f32,
            clap_decay: &mut f32,
            clap_tone: &mut f32,
            clap_drive: &mut f32,
            clap_level: &mut f32,
            clap_filter_type: &mut u32,
            clap_filter_cutoff: &mut f32,
            clap_filter_resonance: &mut f32,
            clap_pitch_base: &mut f32,
            clap_decay_base: &mut f32,
            clap_tone_base: &mut f32,
            clap_drive_base: &mut f32,
            clap_level_base: &mut f32,
            clap_filter_type_base: &mut u32,
            clap_filter_cutoff_base: &mut f32,
            clap_filter_resonance_base: &mut f32,
            clap_decay_time: &mut f32,
            clap_env_coeff: &mut f32,
            clap_burst_decay_time: &mut f32,
            clap_burst_inv: &mut f32,
            clap_cutoff_hz: &mut f32,
            clap_q: &mut f32,
            clap_drive_gain: &mut f32,
        ) {
            let override_enabled =
                track.clap_step_override_enabled[step_idx].load(Ordering::Relaxed);
            if override_enabled {
                let pitch =
                    f32::from_bits(track.clap_step_pitch[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let decay =
                    f32::from_bits(track.clap_step_decay[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let tone =
                    f32::from_bits(track.clap_step_tone[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let drive_val =
                    f32::from_bits(track.clap_step_drive[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let level =
                    f32::from_bits(track.clap_step_level[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let filter_type = track.clap_step_filter_type[step_idx].load(Ordering::Relaxed);
                let filter_cutoff = f32::from_bits(
                    track.clap_step_filter_cutoff[step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let filter_resonance = f32::from_bits(
                    track.clap_step_filter_resonance[step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);

                *clap_pitch = pitch;
                *clap_decay = decay;
                *clap_tone = tone;
                *clap_drive = drive_val;
                *clap_level = if track_muted { 0.0 } else { level };
                *clap_filter_type = filter_type;
                *clap_filter_cutoff = filter_cutoff;
                *clap_filter_resonance = filter_resonance;

                *clap_decay_time = 0.04 + *clap_decay * 0.6;
                *clap_env_coeff = (-1.0 / (*clap_decay_time * sr)).exp();
                *clap_burst_decay_time = 0.005 + (1.0 - *clap_tone) * 0.02;
                *clap_burst_inv = 1.0 / (*clap_burst_decay_time * sr);
                let cutoff = cutoff_min * cutoff_span.powf(*clap_filter_cutoff);
                *clap_cutoff_hz =
                    (cutoff * (0.5 + *clap_pitch * 1.5)).min(cutoff_min * cutoff_span);
                *clap_q = 0.1 + *clap_filter_resonance * 0.9;
                *clap_drive_gain = 1.0 + *clap_drive * 8.0;

                if step_hold {
                    *clap_pitch_base = pitch;
                    *clap_decay_base = decay;
                    *clap_tone_base = tone;
                    *clap_drive_base = drive_val;
                    *clap_level_base = level;
                    *clap_filter_type_base = filter_type;
                    *clap_filter_cutoff_base = filter_cutoff;
                    *clap_filter_resonance_base = filter_resonance;
                    track.clap_pitch.store(pitch.to_bits(), Ordering::Relaxed);
                    track.clap_decay.store(decay.to_bits(), Ordering::Relaxed);
                    track.clap_tone.store(tone.to_bits(), Ordering::Relaxed);
                    track.clap_drive.store(drive_val.to_bits(), Ordering::Relaxed);
                    track.clap_level.store(level.to_bits(), Ordering::Relaxed);
                    track.clap_filter_type.store(filter_type, Ordering::Relaxed);
                    track
                        .clap_filter_cutoff
                        .store(filter_cutoff.to_bits(), Ordering::Relaxed);
                    track
                        .clap_filter_resonance
                        .store(filter_resonance.to_bits(), Ordering::Relaxed);
                }
            } else {
                *clap_pitch = *clap_pitch_base;
                *clap_decay = *clap_decay_base;
                *clap_tone = *clap_tone_base;
                *clap_drive = *clap_drive_base;
                *clap_level = if track_muted { 0.0 } else { *clap_level_base };
                *clap_filter_type = *clap_filter_type_base;
                *clap_filter_cutoff = *clap_filter_cutoff_base;
                *clap_filter_resonance = *clap_filter_resonance_base;

                *clap_decay_time = 0.04 + *clap_decay * 0.6;
                *clap_env_coeff = (-1.0 / (*clap_decay_time * sr)).exp();
                *clap_burst_decay_time = 0.005 + (1.0 - *clap_tone) * 0.02;
                *clap_burst_inv = 1.0 / (*clap_burst_decay_time * sr);
                let cutoff = cutoff_min * cutoff_span.powf(*clap_filter_cutoff);
                *clap_cutoff_hz =
                    (cutoff * (0.5 + *clap_pitch * 1.5)).min(cutoff_min * cutoff_span);
                *clap_q = 0.1 + *clap_filter_resonance * 0.9;
                *clap_drive_gain = 1.0 + *clap_drive * 8.0;
            }
        }

        fn apply_hat_step_params(
            track: &Track,
            step_idx: usize,
            step_hold: bool,
            track_muted: bool,
            cutoff_min: f32,
            cutoff_span: f32,
            sr: f32,
            hat_pitch: &mut f32,
            hat_decay: &mut f32,
            hat_tone: &mut f32,
            hat_drive: &mut f32,
            hat_level: &mut f32,
            hat_filter_type: &mut u32,
            hat_filter_cutoff: &mut f32,
            hat_filter_resonance: &mut f32,
            hat_pitch_base: &mut f32,
            hat_decay_base: &mut f32,
            hat_tone_base: &mut f32,
            hat_drive_base: &mut f32,
            hat_level_base: &mut f32,
            hat_filter_type_base: &mut u32,
            hat_filter_cutoff_base: &mut f32,
            hat_filter_resonance_base: &mut f32,
            hat_decay_time: &mut f32,
            hat_env_coeff: &mut f32,
            hat_attack_samples: &mut u32,
            hat_attack_step: &mut f32,
            hat_freq: &mut f32,
            hat_harmonicity: &mut f32,
            hat_mod_index: &mut f32,
            hat_cutoff_hz: &mut f32,
            hat_q: &mut f32,
            hat_drive_gain: &mut f32,
        ) {
            let override_enabled =
                track.hat_step_override_enabled[step_idx].load(Ordering::Relaxed);
            if override_enabled {
                let pitch =
                    f32::from_bits(track.hat_step_pitch[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let decay =
                    f32::from_bits(track.hat_step_decay[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let tone =
                    f32::from_bits(track.hat_step_tone[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let drive_val =
                    f32::from_bits(track.hat_step_drive[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let level =
                    f32::from_bits(track.hat_step_level[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let filter_type = track.hat_step_filter_type[step_idx].load(Ordering::Relaxed);
                let filter_cutoff = f32::from_bits(
                    track.hat_step_filter_cutoff[step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let filter_resonance = f32::from_bits(
                    track.hat_step_filter_resonance[step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);

                *hat_pitch = pitch;
                *hat_decay = decay;
                *hat_tone = tone;
                *hat_drive = drive_val;
                *hat_level = if track_muted { 0.0 } else { level };
                *hat_filter_type = filter_type;
                *hat_filter_cutoff = filter_cutoff;
                *hat_filter_resonance = filter_resonance;

                *hat_decay_time = 0.01 + *hat_decay * 1.49;
                *hat_env_coeff = (-1.0 / (*hat_decay_time * sr)).exp();
                *hat_attack_samples = (0.001 * sr).round().max(0.0) as u32;
                *hat_attack_step = if *hat_attack_samples > 0 {
                    1.0 / *hat_attack_samples as f32
                } else {
                    1.0
                };
                *hat_freq = 100.0 + *hat_pitch * 11_900.0;
                *hat_harmonicity = 5.0 + *hat_tone * 3.0;
                *hat_mod_index = 10.0 + *hat_tone * 20.0;
                *hat_cutoff_hz = cutoff_min * cutoff_span.powf(*hat_filter_cutoff);
                *hat_q = 0.1 + *hat_filter_resonance * 0.9;
                *hat_drive_gain = 1.0 + *hat_drive * 8.0;

                if step_hold {
                    *hat_pitch_base = pitch;
                    *hat_decay_base = decay;
                    *hat_tone_base = tone;
                    *hat_drive_base = drive_val;
                    *hat_level_base = level;
                    *hat_filter_type_base = filter_type;
                    *hat_filter_cutoff_base = filter_cutoff;
                    *hat_filter_resonance_base = filter_resonance;
                    track.hat_pitch.store(pitch.to_bits(), Ordering::Relaxed);
                    track.hat_decay.store(decay.to_bits(), Ordering::Relaxed);
                    track.hat_tone.store(tone.to_bits(), Ordering::Relaxed);
                    track.hat_drive.store(drive_val.to_bits(), Ordering::Relaxed);
                    track.hat_level.store(level.to_bits(), Ordering::Relaxed);
                    track.hat_filter_type.store(filter_type, Ordering::Relaxed);
                    track
                        .hat_filter_cutoff
                        .store(filter_cutoff.to_bits(), Ordering::Relaxed);
                    track
                        .hat_filter_resonance
                        .store(filter_resonance.to_bits(), Ordering::Relaxed);
                }
            } else {
                *hat_pitch = *hat_pitch_base;
                *hat_decay = *hat_decay_base;
                *hat_tone = *hat_tone_base;
                *hat_drive = *hat_drive_base;
                *hat_level = if track_muted { 0.0 } else { *hat_level_base };
                *hat_filter_type = *hat_filter_type_base;
                *hat_filter_cutoff = *hat_filter_cutoff_base;
                *hat_filter_resonance = *hat_filter_resonance_base;

                *hat_decay_time = 0.01 + *hat_decay * 1.49;
                *hat_env_coeff = (-1.0 / (*hat_decay_time * sr)).exp();
                *hat_attack_samples = (0.001 * sr).round().max(0.0) as u32;
                *hat_attack_step = if *hat_attack_samples > 0 {
                    1.0 / *hat_attack_samples as f32
                } else {
                    1.0
                };
                *hat_freq = 100.0 + *hat_pitch * 11_900.0;
                *hat_harmonicity = 5.0 + *hat_tone * 3.0;
                *hat_mod_index = 10.0 + *hat_tone * 20.0;
                *hat_cutoff_hz = cutoff_min * cutoff_span.powf(*hat_filter_cutoff);
                *hat_q = 0.1 + *hat_filter_resonance * 0.9;
                *hat_drive_gain = 1.0 + *hat_drive * 8.0;
            }
        }

        fn apply_crash_step_params(
            track: &Track,
            step_idx: usize,
            step_hold: bool,
            track_muted: bool,
            cutoff_min: f32,
            cutoff_span: f32,
            sr: f32,
            crash_pitch: &mut f32,
            crash_decay: &mut f32,
            crash_tone: &mut f32,
            crash_drive: &mut f32,
            crash_level: &mut f32,
            crash_filter_type: &mut u32,
            crash_filter_cutoff: &mut f32,
            crash_filter_resonance: &mut f32,
            crash_pitch_base: &mut f32,
            crash_decay_base: &mut f32,
            crash_tone_base: &mut f32,
            crash_drive_base: &mut f32,
            crash_level_base: &mut f32,
            crash_filter_type_base: &mut u32,
            crash_filter_cutoff_base: &mut f32,
            crash_filter_resonance_base: &mut f32,
            crash_decay_time: &mut f32,
            crash_env_coeff: &mut f32,
            crash_attack_samples: &mut u32,
            crash_attack_step: &mut f32,
            crash_freq: &mut f32,
            crash_harmonicity: &mut f32,
            crash_mod_index: &mut f32,
            crash_cutoff_hz: &mut f32,
            crash_q: &mut f32,
            crash_drive_gain: &mut f32,
        ) {
            let override_enabled =
                track.crash_step_override_enabled[step_idx].load(Ordering::Relaxed);
            if override_enabled {
                let pitch =
                    f32::from_bits(track.crash_step_pitch[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let decay =
                    f32::from_bits(track.crash_step_decay[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let tone =
                    f32::from_bits(track.crash_step_tone[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let drive_val =
                    f32::from_bits(track.crash_step_drive[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let level =
                    f32::from_bits(track.crash_step_level[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let filter_type = track.crash_step_filter_type[step_idx].load(Ordering::Relaxed);
                let filter_cutoff = f32::from_bits(
                    track.crash_step_filter_cutoff[step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let filter_resonance = f32::from_bits(
                    track
                        .crash_step_filter_resonance[step_idx]
                        .load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);

                *crash_pitch = pitch;
                *crash_decay = decay;
                *crash_tone = tone;
                *crash_drive = drive_val;
                *crash_level = if track_muted { 0.0 } else { level };
                *crash_filter_type = filter_type;
                *crash_filter_cutoff = filter_cutoff;
                *crash_filter_resonance = filter_resonance;

                *crash_decay_time = 0.2 + *crash_decay * 3.0;
                *crash_env_coeff = (-1.0 / (*crash_decay_time * sr)).exp();
                *crash_attack_samples = (0.002 * sr).round().max(0.0) as u32;
                *crash_attack_step = if *crash_attack_samples > 0 {
                    1.0 / *crash_attack_samples as f32
                } else {
                    1.0
                };
                *crash_freq = 80.0 + *crash_pitch * 9000.0;
                *crash_harmonicity = 6.0 + *crash_tone * 3.0;
                *crash_mod_index = 12.0 + *crash_tone * 20.0;
                *crash_cutoff_hz = cutoff_min * cutoff_span.powf(*crash_filter_cutoff);
                *crash_q = 0.1 + *crash_filter_resonance * 0.9;
                *crash_drive_gain = 1.0 + *crash_drive * 8.0;

                if step_hold {
                    *crash_pitch_base = pitch;
                    *crash_decay_base = decay;
                    *crash_tone_base = tone;
                    *crash_drive_base = drive_val;
                    *crash_level_base = level;
                    *crash_filter_type_base = filter_type;
                    *crash_filter_cutoff_base = filter_cutoff;
                    *crash_filter_resonance_base = filter_resonance;
                    track.crash_pitch.store(pitch.to_bits(), Ordering::Relaxed);
                    track.crash_decay.store(decay.to_bits(), Ordering::Relaxed);
                    track.crash_tone.store(tone.to_bits(), Ordering::Relaxed);
                    track.crash_drive.store(drive_val.to_bits(), Ordering::Relaxed);
                    track.crash_level.store(level.to_bits(), Ordering::Relaxed);
                    track.crash_filter_type.store(filter_type, Ordering::Relaxed);
                    track
                        .crash_filter_cutoff
                        .store(filter_cutoff.to_bits(), Ordering::Relaxed);
                    track
                        .crash_filter_resonance
                        .store(filter_resonance.to_bits(), Ordering::Relaxed);
                }
            } else {
                *crash_pitch = *crash_pitch_base;
                *crash_decay = *crash_decay_base;
                *crash_tone = *crash_tone_base;
                *crash_drive = *crash_drive_base;
                *crash_level = if track_muted { 0.0 } else { *crash_level_base };
                *crash_filter_type = *crash_filter_type_base;
                *crash_filter_cutoff = *crash_filter_cutoff_base;
                *crash_filter_resonance = *crash_filter_resonance_base;

                *crash_decay_time = 0.2 + *crash_decay * 3.0;
                *crash_env_coeff = (-1.0 / (*crash_decay_time * sr)).exp();
                *crash_attack_samples = (0.002 * sr).round().max(0.0) as u32;
                *crash_attack_step = if *crash_attack_samples > 0 {
                    1.0 / *crash_attack_samples as f32
                } else {
                    1.0
                };
                *crash_freq = 80.0 + *crash_pitch * 9000.0;
                *crash_harmonicity = 6.0 + *crash_tone * 3.0;
                *crash_mod_index = 12.0 + *crash_tone * 20.0;
                *crash_cutoff_hz = cutoff_min * cutoff_span.powf(*crash_filter_cutoff);
                *crash_q = 0.1 + *crash_filter_resonance * 0.9;
                *crash_drive_gain = 1.0 + *crash_drive * 8.0;
            }
        }

        fn apply_samp_step_params(
            track: &Track,
            channel_idx: usize,
            step_idx: usize,
            step_hold: bool,
            track_muted: bool,
            cutoff_min: f32,
            cutoff_span: f32,
            sr: f32,
            samp_pitch: &mut f32,
            samp_attack: &mut f32,
            samp_decay: &mut f32,
            samp_drive: &mut f32,
            samp_level: &mut f32,
            samp_filter_type: &mut u32,
            samp_filter_cutoff: &mut f32,
            samp_filter_resonance: &mut f32,
            samp_pitch_base: &mut f32,
            samp_attack_base: &mut f32,
            samp_decay_base: &mut f32,
            samp_drive_base: &mut f32,
            samp_level_base: &mut f32,
            samp_filter_type_base: &mut u32,
            samp_filter_cutoff_base: &mut f32,
            samp_filter_resonance_base: &mut f32,
            samp_attack_samples: &mut u32,
            samp_attack_step: &mut f32,
            samp_decay_time: &mut f32,
            samp_decay_coeff: &mut f32,
            samp_rate: &mut f32,
            samp_drive_gain: &mut f32,
            samp_cutoff_hz: &mut f32,
            samp_q: &mut f32,
            samp_sample_len: u32,
            samp_sample_rate: u32,
        ) {
            let override_enabled =
                track.samp_step_override_enabled[channel_idx][step_idx].load(Ordering::Relaxed);
            if override_enabled {
                let pitch = f32::from_bits(
                    track.samp_step_pitch[channel_idx][step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let attack = f32::from_bits(
                    track.samp_step_attack[channel_idx][step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let decay = f32::from_bits(
                    track.samp_step_decay[channel_idx][step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let drive_val = f32::from_bits(
                    track.samp_step_drive[channel_idx][step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let level = f32::from_bits(
                    track.samp_step_level[channel_idx][step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let filter_type =
                    track.samp_step_filter_type[channel_idx][step_idx].load(Ordering::Relaxed);
                let filter_cutoff = f32::from_bits(
                    track.samp_step_filter_cutoff[channel_idx][step_idx]
                        .load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let filter_resonance = f32::from_bits(
                    track.samp_step_filter_resonance[channel_idx][step_idx]
                        .load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);

                *samp_pitch = pitch;
                *samp_attack = attack;
                *samp_decay = decay;
                *samp_drive = drive_val;
                *samp_level = if track_muted { 0.0 } else { level };
                *samp_filter_type = filter_type;
                *samp_filter_cutoff = filter_cutoff;
                *samp_filter_resonance = filter_resonance;

                let duration = if samp_sample_len > 0 {
                    samp_sample_len as f32 / samp_sample_rate.max(1) as f32
                } else {
                    0.0
                };
                let attack_time = *samp_attack * duration;
                let decay_max = (duration - attack_time).max(0.0);
                *samp_decay_time = *samp_decay * decay_max;
                *samp_attack_samples = (attack_time * sr).round().max(0.0) as u32;
                *samp_attack_step = if *samp_attack_samples > 0 {
                    1.0 / *samp_attack_samples as f32
                } else {
                    1.0
                };
                *samp_decay_coeff = if *samp_decay_time > 0.0 {
                    (-1.0 / (*samp_decay_time * sr)).exp()
                } else {
                    0.0
                };
                let semitones = (*samp_pitch - 0.5) * 24.0;
                *samp_rate = 2.0f32.powf(semitones / 12.0);
                *samp_drive_gain = 1.0 + *samp_drive * 8.0;
                *samp_cutoff_hz = cutoff_min * cutoff_span.powf(*samp_filter_cutoff);
                *samp_q = 0.1 + *samp_filter_resonance * 0.9;

                if step_hold {
                    *samp_pitch_base = pitch;
                    *samp_attack_base = attack;
                    *samp_decay_base = decay;
                    *samp_drive_base = drive_val;
                    *samp_level_base = level;
                    *samp_filter_type_base = filter_type;
                    *samp_filter_cutoff_base = filter_cutoff;
                    *samp_filter_resonance_base = filter_resonance;
                    track.samp_pitch[channel_idx].store(pitch.to_bits(), Ordering::Relaxed);
                    track
                        .samp_attack[channel_idx]
                        .store(attack.to_bits(), Ordering::Relaxed);
                    track
                        .samp_decay[channel_idx]
                        .store(decay.to_bits(), Ordering::Relaxed);
                    track
                        .samp_drive[channel_idx]
                        .store(drive_val.to_bits(), Ordering::Relaxed);
                    track
                        .samp_level[channel_idx]
                        .store(level.to_bits(), Ordering::Relaxed);
                    track
                        .samp_filter_type[channel_idx]
                        .store(filter_type, Ordering::Relaxed);
                    track
                        .samp_filter_cutoff[channel_idx]
                        .store(filter_cutoff.to_bits(), Ordering::Relaxed);
                    track
                        .samp_filter_resonance[channel_idx]
                        .store(filter_resonance.to_bits(), Ordering::Relaxed);
                }
            } else {
                *samp_pitch = *samp_pitch_base;
                *samp_attack = *samp_attack_base;
                *samp_decay = *samp_decay_base;
                *samp_drive = *samp_drive_base;
                *samp_level = if track_muted { 0.0 } else { *samp_level_base };
                *samp_filter_type = *samp_filter_type_base;
                *samp_filter_cutoff = *samp_filter_cutoff_base;
                *samp_filter_resonance = *samp_filter_resonance_base;

                let duration = if samp_sample_len > 0 {
                    samp_sample_len as f32 / samp_sample_rate.max(1) as f32
                } else {
                    0.0
                };
                let attack_time = *samp_attack * duration;
                let decay_max = (duration - attack_time).max(0.0);
                *samp_decay_time = *samp_decay * decay_max;
                *samp_attack_samples = (attack_time * sr).round().max(0.0) as u32;
                *samp_attack_step = if *samp_attack_samples > 0 {
                    1.0 / *samp_attack_samples as f32
                } else {
                    1.0
                };
                *samp_decay_coeff = if *samp_decay_time > 0.0 {
                    (-1.0 / (*samp_decay_time * sr)).exp()
                } else {
                    0.0
                };
                let semitones = (*samp_pitch - 0.5) * 24.0;
                *samp_rate = 2.0f32.powf(semitones / 12.0);
                *samp_drive_gain = 1.0 + *samp_drive * 8.0;
                *samp_cutoff_hz = cutoff_min * cutoff_span.powf(*samp_filter_cutoff);
                *samp_q = 0.1 + *samp_filter_resonance * 0.9;
            }
        }

        fn apply_perc1_step_params(
            track: &Track,
            step_idx: usize,
            step_hold: bool,
            track_muted: bool,
            cutoff_min: f32,
            cutoff_span: f32,
            sr: f32,
            perc1_pitch: &mut f32,
            perc1_decay: &mut f32,
            perc1_tone: &mut f32,
            perc1_drive: &mut f32,
            perc1_level: &mut f32,
            perc1_filter_type: &mut u32,
            perc1_filter_cutoff: &mut f32,
            perc1_filter_resonance: &mut f32,
            perc1_pitch_base: &mut f32,
            perc1_decay_base: &mut f32,
            perc1_tone_base: &mut f32,
            perc1_drive_base: &mut f32,
            perc1_level_base: &mut f32,
            perc1_filter_type_base: &mut u32,
            perc1_filter_cutoff_base: &mut f32,
            perc1_filter_resonance_base: &mut f32,
            perc1_decay_time: &mut f32,
            perc1_decay_coeff: &mut f32,
            perc1_attack_time: &mut f32,
            perc1_attack_samples: &mut u32,
            perc1_attack_step: &mut f32,
            perc1_freq: &mut f32,
            perc1_cutoff_hz: &mut f32,
            perc1_q: &mut f32,
            perc1_drive_gain: &mut f32,
            perc1_damping: &mut f32,
        ) {
            let override_enabled =
                track.perc1_step_override_enabled[step_idx].load(Ordering::Relaxed);
            if override_enabled {
                let pitch =
                    f32::from_bits(track.perc1_step_pitch[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let decay =
                    f32::from_bits(track.perc1_step_decay[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let tone =
                    f32::from_bits(track.perc1_step_tone[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let drive_val =
                    f32::from_bits(track.perc1_step_drive[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let level =
                    f32::from_bits(track.perc1_step_level[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let filter_type = track.perc1_step_filter_type[step_idx].load(Ordering::Relaxed);
                let filter_cutoff = f32::from_bits(
                    track.perc1_step_filter_cutoff[step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let filter_resonance = f32::from_bits(
                    track.perc1_step_filter_resonance[step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);

                *perc1_pitch = pitch;
                *perc1_decay = decay;
                *perc1_tone = tone;
                *perc1_drive = drive_val;
                *perc1_level = if track_muted { 0.0 } else { level };
                *perc1_filter_type = filter_type;
                *perc1_filter_cutoff = filter_cutoff;
                *perc1_filter_resonance = filter_resonance;

                *perc1_decay_time = 0.05 + *perc1_decay * 1.5;
                *perc1_decay_coeff = (-1.0 / (*perc1_decay_time * sr)).exp();
                *perc1_attack_time = 0.002 + *perc1_decay * 0.008;
                *perc1_attack_samples = (*perc1_attack_time * sr).round().max(0.0) as u32;
                *perc1_attack_step = if *perc1_attack_samples > 0 {
                    1.0 / *perc1_attack_samples as f32
                } else {
                    1.0
                };
                *perc1_freq = 80.0 + *perc1_pitch * 6000.0;
                *perc1_cutoff_hz = cutoff_min * cutoff_span.powf(*perc1_filter_cutoff);
                *perc1_q = 0.1 + *perc1_filter_resonance * 0.9;
                *perc1_drive_gain = 1.0 + *perc1_drive * 8.0;
                *perc1_damping = 0.5 + (1.0 - *perc1_tone) * 0.45;

                if step_hold {
                    *perc1_pitch_base = pitch;
                    *perc1_decay_base = decay;
                    *perc1_tone_base = tone;
                    *perc1_drive_base = drive_val;
                    *perc1_level_base = level;
                    *perc1_filter_type_base = filter_type;
                    *perc1_filter_cutoff_base = filter_cutoff;
                    *perc1_filter_resonance_base = filter_resonance;
                    track.perc1_pitch.store(pitch.to_bits(), Ordering::Relaxed);
                    track.perc1_decay.store(decay.to_bits(), Ordering::Relaxed);
                    track.perc1_tone.store(tone.to_bits(), Ordering::Relaxed);
                    track.perc1_drive.store(drive_val.to_bits(), Ordering::Relaxed);
                    track.perc1_level.store(level.to_bits(), Ordering::Relaxed);
                    track.perc1_filter_type.store(filter_type, Ordering::Relaxed);
                    track
                        .perc1_filter_cutoff
                        .store(filter_cutoff.to_bits(), Ordering::Relaxed);
                    track
                        .perc1_filter_resonance
                        .store(filter_resonance.to_bits(), Ordering::Relaxed);
                }
            } else {
                *perc1_pitch = *perc1_pitch_base;
                *perc1_decay = *perc1_decay_base;
                *perc1_tone = *perc1_tone_base;
                *perc1_drive = *perc1_drive_base;
                *perc1_level = if track_muted { 0.0 } else { *perc1_level_base };
                *perc1_filter_type = *perc1_filter_type_base;
                *perc1_filter_cutoff = *perc1_filter_cutoff_base;
                *perc1_filter_resonance = *perc1_filter_resonance_base;

                *perc1_decay_time = 0.05 + *perc1_decay * 1.5;
                *perc1_decay_coeff = (-1.0 / (*perc1_decay_time * sr)).exp();
                *perc1_attack_time = 0.002 + *perc1_decay * 0.008;
                *perc1_attack_samples = (*perc1_attack_time * sr).round().max(0.0) as u32;
                *perc1_attack_step = if *perc1_attack_samples > 0 {
                    1.0 / *perc1_attack_samples as f32
                } else {
                    1.0
                };
                *perc1_freq = 80.0 + *perc1_pitch * 6000.0;
                *perc1_cutoff_hz = cutoff_min * cutoff_span.powf(*perc1_filter_cutoff);
                *perc1_q = 0.1 + *perc1_filter_resonance * 0.9;
                *perc1_drive_gain = 1.0 + *perc1_drive * 8.0;
                *perc1_damping = 0.5 + (1.0 - *perc1_tone) * 0.45;
            }
        }

        fn apply_perc2_step_params(
            track: &Track,
            step_idx: usize,
            step_hold: bool,
            track_muted: bool,
            cutoff_min: f32,
            cutoff_span: f32,
            sr: f32,
            perc2_pitch: &mut f32,
            perc2_decay: &mut f32,
            perc2_tone: &mut f32,
            perc2_drive: &mut f32,
            perc2_level: &mut f32,
            perc2_filter_type: &mut u32,
            perc2_filter_cutoff: &mut f32,
            perc2_filter_resonance: &mut f32,
            perc2_pitch_base: &mut f32,
            perc2_decay_base: &mut f32,
            perc2_tone_base: &mut f32,
            perc2_drive_base: &mut f32,
            perc2_level_base: &mut f32,
            perc2_filter_type_base: &mut u32,
            perc2_filter_cutoff_base: &mut f32,
            perc2_filter_resonance_base: &mut f32,
            perc2_decay_time: &mut f32,
            perc2_env_coeff: &mut f32,
            perc2_freq: &mut f32,
            perc2_mod_index: &mut f32,
            perc2_cutoff_hz: &mut f32,
            perc2_q: &mut f32,
            perc2_drive_gain: &mut f32,
        ) {
            let override_enabled =
                track.perc2_step_override_enabled[step_idx].load(Ordering::Relaxed);
            if override_enabled {
                let pitch =
                    f32::from_bits(track.perc2_step_pitch[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let decay =
                    f32::from_bits(track.perc2_step_decay[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let tone =
                    f32::from_bits(track.perc2_step_tone[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let drive_val =
                    f32::from_bits(track.perc2_step_drive[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let level =
                    f32::from_bits(track.perc2_step_level[step_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let filter_type = track.perc2_step_filter_type[step_idx].load(Ordering::Relaxed);
                let filter_cutoff = f32::from_bits(
                    track.perc2_step_filter_cutoff[step_idx].load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);
                let filter_resonance = f32::from_bits(
                    track
                        .perc2_step_filter_resonance[step_idx]
                        .load(Ordering::Relaxed),
                )
                .clamp(0.0, 1.0);

                *perc2_pitch = pitch;
                *perc2_decay = decay;
                *perc2_tone = tone;
                *perc2_drive = drive_val;
                *perc2_level = if track_muted { 0.0 } else { level };
                *perc2_filter_type = filter_type;
                *perc2_filter_cutoff = filter_cutoff;
                *perc2_filter_resonance = filter_resonance;

                *perc2_decay_time = 0.001 + *perc2_decay * 1.0;
                *perc2_env_coeff = (-1.0 / (*perc2_decay_time * sr)).exp();
                *perc2_freq = 60.0 + *perc2_pitch * 520.0;
                *perc2_mod_index = 30.0 * *perc2_tone + 5.0;
                *perc2_cutoff_hz = cutoff_min * cutoff_span.powf(*perc2_filter_cutoff);
                *perc2_q = 0.1 + *perc2_filter_resonance * 0.9;
                *perc2_drive_gain = 1.0 + *perc2_drive * 8.0;

                if step_hold {
                    *perc2_pitch_base = pitch;
                    *perc2_decay_base = decay;
                    *perc2_tone_base = tone;
                    *perc2_drive_base = drive_val;
                    *perc2_level_base = level;
                    *perc2_filter_type_base = filter_type;
                    *perc2_filter_cutoff_base = filter_cutoff;
                    *perc2_filter_resonance_base = filter_resonance;
                    track.perc2_pitch.store(pitch.to_bits(), Ordering::Relaxed);
                    track.perc2_decay.store(decay.to_bits(), Ordering::Relaxed);
                    track.perc2_tone.store(tone.to_bits(), Ordering::Relaxed);
                    track.perc2_drive.store(drive_val.to_bits(), Ordering::Relaxed);
                    track.perc2_level.store(level.to_bits(), Ordering::Relaxed);
                    track.perc2_filter_type.store(filter_type, Ordering::Relaxed);
                    track
                        .perc2_filter_cutoff
                        .store(filter_cutoff.to_bits(), Ordering::Relaxed);
                    track
                        .perc2_filter_resonance
                        .store(filter_resonance.to_bits(), Ordering::Relaxed);
                }
            } else {
                *perc2_pitch = *perc2_pitch_base;
                *perc2_decay = *perc2_decay_base;
                *perc2_tone = *perc2_tone_base;
                *perc2_drive = *perc2_drive_base;
                *perc2_level = if track_muted { 0.0 } else { *perc2_level_base };
                *perc2_filter_type = *perc2_filter_type_base;
                *perc2_filter_cutoff = *perc2_filter_cutoff_base;
                *perc2_filter_resonance = *perc2_filter_resonance_base;

                *perc2_decay_time = 0.001 + *perc2_decay * 1.0;
                *perc2_env_coeff = (-1.0 / (*perc2_decay_time * sr)).exp();
                *perc2_freq = 60.0 + *perc2_pitch * 520.0;
                *perc2_mod_index = 30.0 * *perc2_tone + 5.0;
                *perc2_cutoff_hz = cutoff_min * cutoff_span.powf(*perc2_filter_cutoff);
                *perc2_q = 0.1 + *perc2_filter_resonance * 0.9;
                *perc2_drive_gain = 1.0 + *perc2_drive * 8.0;
            }
        }

        if current_step >= 0 {
            let step_idx = current_step as usize;
            if step_idx < SYNDRM_STEPS {
                apply_kick_step_params(
                    track,
                    step_idx,
                    step_hold,
                    track_muted,
                    cutoff_min,
                    cutoff_span,
                    sr,
                    &mut kick_pitch,
                    &mut kick_decay,
                    &mut kick_attack,
                    kick_pitch_env_amount,
                    &mut kick_drive,
                    &mut kick_level,
                    &mut kick_filter_type,
                    &mut kick_filter_cutoff,
                    &mut kick_filter_resonance,
                    &mut kick_pitch_base,
                    &mut kick_decay_base,
                    &mut kick_attack_base,
                    &mut kick_drive_base,
                    &mut kick_level_base,
                    &mut kick_filter_type_base,
                    &mut kick_filter_cutoff_base,
                    &mut kick_filter_resonance_base,
                    &mut decay_time,
                    &mut pitch_decay_time,
                    &mut env_coeff,
                    &mut attack_time,
                    &mut attack_samples,
                    &mut attack_step,
                    &mut pitch_coeff,
                    &mut base_freq,
                    &mut sweep,
                    &mut drive,
                    &mut kick_cutoff_hz,
                    &mut kick_q,
                );
                apply_snare_step_params(
                    track,
                    step_idx,
                    step_hold,
                    track_muted,
                    cutoff_min,
                    cutoff_span,
                    sr,
                    &mut snare_tone,
                    &mut snare_decay,
                    &mut snare_snappy,
                    &mut snare_attack,
                    &mut snare_drive,
                    &mut snare_level,
                    &mut snare_filter_type,
                    &mut snare_filter_cutoff,
                    &mut snare_filter_resonance,
                    &mut snare_tone_base,
                    &mut snare_decay_base,
                    &mut snare_snappy_base,
                    &mut snare_attack_base,
                    &mut snare_drive_base,
                    &mut snare_level_base,
                    &mut snare_filter_type_base,
                    &mut snare_filter_cutoff_base,
                    &mut snare_filter_resonance_base,
                    &mut snare_decay_time,
                    &mut snare_noise_decay_time,
                    &mut snare_env_coeff,
                    &mut snare_noise_coeff,
                    &mut snare_attack_time,
                    &mut snare_attack_samples,
                    &mut snare_attack_step,
                    &mut snare_freq,
                    &mut snare_cutoff_hz,
                    &mut snare_q,
                    &mut snare_drive_gain,
                );
                apply_clap_step_params(
                    track,
                    step_idx,
                    step_hold,
                    track_muted,
                    cutoff_min,
                    cutoff_span,
                    sr,
                    &mut clap_pitch,
                    &mut clap_decay,
                    &mut clap_tone,
                    &mut clap_drive,
                    &mut clap_level,
                    &mut clap_filter_type,
                    &mut clap_filter_cutoff,
                    &mut clap_filter_resonance,
                    &mut clap_pitch_base,
                    &mut clap_decay_base,
                    &mut clap_tone_base,
                    &mut clap_drive_base,
                    &mut clap_level_base,
                    &mut clap_filter_type_base,
                    &mut clap_filter_cutoff_base,
                    &mut clap_filter_resonance_base,
                    &mut clap_decay_time,
                    &mut clap_env_coeff,
                    &mut clap_burst_decay_time,
                    &mut clap_burst_inv,
                    &mut clap_cutoff_hz,
                    &mut clap_q,
                    &mut clap_drive_gain,
                );
                apply_hat_step_params(
                    track,
                    step_idx,
                    step_hold,
                    track_muted,
                    cutoff_min,
                    cutoff_span,
                    sr,
                    &mut hat_pitch,
                    &mut hat_decay,
                    &mut hat_tone,
                    &mut hat_drive,
                    &mut hat_level,
                    &mut hat_filter_type,
                    &mut hat_filter_cutoff,
                    &mut hat_filter_resonance,
                    &mut hat_pitch_base,
                    &mut hat_decay_base,
                    &mut hat_tone_base,
                    &mut hat_drive_base,
                    &mut hat_level_base,
                    &mut hat_filter_type_base,
                    &mut hat_filter_cutoff_base,
                    &mut hat_filter_resonance_base,
                    &mut hat_decay_time,
                    &mut hat_env_coeff,
                    &mut hat_attack_samples,
                    &mut hat_attack_step,
                    &mut hat_freq,
                    &mut hat_harmonicity,
                    &mut hat_mod_index,
                    &mut hat_cutoff_hz,
                    &mut hat_q,
                    &mut hat_drive_gain,
                );
                apply_perc1_step_params(
                    track,
                    step_idx,
                    step_hold,
                    track_muted,
                    cutoff_min,
                    cutoff_span,
                    sr,
                    &mut perc1_pitch,
                    &mut perc1_decay,
                    &mut perc1_tone,
                    &mut perc1_drive,
                    &mut perc1_level,
                    &mut perc1_filter_type,
                    &mut perc1_filter_cutoff,
                    &mut perc1_filter_resonance,
                    &mut perc1_pitch_base,
                    &mut perc1_decay_base,
                    &mut perc1_tone_base,
                    &mut perc1_drive_base,
                    &mut perc1_level_base,
                    &mut perc1_filter_type_base,
                    &mut perc1_filter_cutoff_base,
                    &mut perc1_filter_resonance_base,
                    &mut perc1_decay_time,
                    &mut perc1_decay_coeff,
                    &mut perc1_attack_time,
                    &mut perc1_attack_samples,
                    &mut perc1_attack_step,
                    &mut perc1_freq,
                    &mut perc1_cutoff_hz,
                    &mut perc1_q,
                    &mut perc1_drive_gain,
                    &mut perc1_damping,
                );
                apply_perc2_step_params(
                    track,
                    step_idx,
                    step_hold,
                    track_muted,
                    cutoff_min,
                    cutoff_span,
                    sr,
                    &mut perc2_pitch,
                    &mut perc2_decay,
                    &mut perc2_tone,
                    &mut perc2_drive,
                    &mut perc2_level,
                    &mut perc2_filter_type,
                    &mut perc2_filter_cutoff,
                    &mut perc2_filter_resonance,
                    &mut perc2_pitch_base,
                    &mut perc2_decay_base,
                    &mut perc2_tone_base,
                    &mut perc2_drive_base,
                    &mut perc2_level_base,
                    &mut perc2_filter_type_base,
                    &mut perc2_filter_cutoff_base,
                    &mut perc2_filter_resonance_base,
                    &mut perc2_decay_time,
                    &mut perc2_env_coeff,
                    &mut perc2_freq,
                    &mut perc2_mod_index,
                    &mut perc2_cutoff_hz,
                    &mut perc2_q,
                    &mut perc2_drive_gain,
                );
                apply_crash_step_params(
                    track,
                    step_idx,
                    step_hold,
                    track_muted,
                    cutoff_min,
                    cutoff_span,
                    sr,
                    &mut crash_pitch,
                    &mut crash_decay,
                    &mut crash_tone,
                    &mut crash_drive,
                    &mut crash_level,
                    &mut crash_filter_type,
                    &mut crash_filter_cutoff,
                    &mut crash_filter_resonance,
                    &mut crash_pitch_base,
                    &mut crash_decay_base,
                    &mut crash_tone_base,
                    &mut crash_drive_base,
                    &mut crash_level_base,
                    &mut crash_filter_type_base,
                    &mut crash_filter_cutoff_base,
                    &mut crash_filter_resonance_base,
                    &mut crash_decay_time,
                    &mut crash_env_coeff,
                    &mut crash_attack_samples,
                    &mut crash_attack_step,
                    &mut crash_freq,
                    &mut crash_harmonicity,
                    &mut crash_mod_index,
                    &mut crash_cutoff_hz,
                    &mut crash_q,
                    &mut crash_drive_gain,
                );
            }
        }

        let output = track_output;

        for sample_idx in 0..num_buffer_samples {
            if transport_running {
                sequencer_phase += 1.0;
                if sequencer_phase >= samples_per_step {
                    sequencer_phase -= samples_per_step;
                    current_step = (current_step + 1).rem_euclid(loop_steps_i32);
                    track.kick_sequencer_step.store(current_step, Ordering::Relaxed);
                    track.snare_sequencer_step.store(current_step, Ordering::Relaxed);
                    track.clap_sequencer_step.store(current_step, Ordering::Relaxed);
                    track.hat_sequencer_step.store(current_step, Ordering::Relaxed);
                    track.perc1_sequencer_step.store(current_step, Ordering::Relaxed);
                    track.perc2_sequencer_step.store(current_step, Ordering::Relaxed);
                    track.crash_sequencer_step.store(current_step, Ordering::Relaxed);
                    for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                        track.samp_sequencer_step[samp_idx]
                            .store(current_step, Ordering::Relaxed);
                    }
                    let step_idx = current_step as usize;
                    if step_idx < SYNDRM_STEPS {
                        apply_kick_step_params(
                            track,
                            step_idx,
                            step_hold,
                            track_muted,
                            cutoff_min,
                            cutoff_span,
                            sr,
                            &mut kick_pitch,
                            &mut kick_decay,
                            &mut kick_attack,
                            kick_pitch_env_amount,
                            &mut kick_drive,
                            &mut kick_level,
                            &mut kick_filter_type,
                            &mut kick_filter_cutoff,
                            &mut kick_filter_resonance,
                            &mut kick_pitch_base,
                            &mut kick_decay_base,
                            &mut kick_attack_base,
                            &mut kick_drive_base,
                            &mut kick_level_base,
                            &mut kick_filter_type_base,
                            &mut kick_filter_cutoff_base,
                            &mut kick_filter_resonance_base,
                            &mut decay_time,
                            &mut pitch_decay_time,
                            &mut env_coeff,
                            &mut attack_time,
                            &mut attack_samples,
                            &mut attack_step,
                            &mut pitch_coeff,
                            &mut base_freq,
                            &mut sweep,
                            &mut drive,
                            &mut kick_cutoff_hz,
                            &mut kick_q,
                        );
                        apply_snare_step_params(
                            track,
                            step_idx,
                            step_hold,
                            track_muted,
                            cutoff_min,
                            cutoff_span,
                            sr,
                            &mut snare_tone,
                            &mut snare_decay,
                            &mut snare_snappy,
                            &mut snare_attack,
                            &mut snare_drive,
                            &mut snare_level,
                            &mut snare_filter_type,
                            &mut snare_filter_cutoff,
                            &mut snare_filter_resonance,
                            &mut snare_tone_base,
                            &mut snare_decay_base,
                            &mut snare_snappy_base,
                            &mut snare_attack_base,
                            &mut snare_drive_base,
                            &mut snare_level_base,
                            &mut snare_filter_type_base,
                            &mut snare_filter_cutoff_base,
                            &mut snare_filter_resonance_base,
                            &mut snare_decay_time,
                            &mut snare_noise_decay_time,
                            &mut snare_env_coeff,
                            &mut snare_noise_coeff,
                            &mut snare_attack_time,
                            &mut snare_attack_samples,
                            &mut snare_attack_step,
                            &mut snare_freq,
                            &mut snare_cutoff_hz,
                            &mut snare_q,
                            &mut snare_drive_gain,
                        );
                        apply_clap_step_params(
                            track,
                            step_idx,
                            step_hold,
                            track_muted,
                            cutoff_min,
                            cutoff_span,
                            sr,
                            &mut clap_pitch,
                            &mut clap_decay,
                            &mut clap_tone,
                            &mut clap_drive,
                            &mut clap_level,
                            &mut clap_filter_type,
                            &mut clap_filter_cutoff,
                            &mut clap_filter_resonance,
                            &mut clap_pitch_base,
                            &mut clap_decay_base,
                            &mut clap_tone_base,
                            &mut clap_drive_base,
                            &mut clap_level_base,
                            &mut clap_filter_type_base,
                            &mut clap_filter_cutoff_base,
                            &mut clap_filter_resonance_base,
                            &mut clap_decay_time,
                            &mut clap_env_coeff,
                            &mut clap_burst_decay_time,
                            &mut clap_burst_inv,
                            &mut clap_cutoff_hz,
                            &mut clap_q,
                            &mut clap_drive_gain,
                        );
                        apply_hat_step_params(
                            track,
                            step_idx,
                            step_hold,
                            track_muted,
                            cutoff_min,
                            cutoff_span,
                            sr,
                            &mut hat_pitch,
                            &mut hat_decay,
                            &mut hat_tone,
                            &mut hat_drive,
                            &mut hat_level,
                            &mut hat_filter_type,
                            &mut hat_filter_cutoff,
                            &mut hat_filter_resonance,
                            &mut hat_pitch_base,
                            &mut hat_decay_base,
                            &mut hat_tone_base,
                            &mut hat_drive_base,
                            &mut hat_level_base,
                            &mut hat_filter_type_base,
                            &mut hat_filter_cutoff_base,
                            &mut hat_filter_resonance_base,
                            &mut hat_decay_time,
                            &mut hat_env_coeff,
                            &mut hat_attack_samples,
                            &mut hat_attack_step,
                            &mut hat_freq,
                            &mut hat_harmonicity,
                            &mut hat_mod_index,
                            &mut hat_cutoff_hz,
                            &mut hat_q,
                            &mut hat_drive_gain,
                        );
                        apply_perc1_step_params(
                            track,
                            step_idx,
                            step_hold,
                            track_muted,
                            cutoff_min,
                            cutoff_span,
                            sr,
                            &mut perc1_pitch,
                            &mut perc1_decay,
                            &mut perc1_tone,
                            &mut perc1_drive,
                            &mut perc1_level,
                            &mut perc1_filter_type,
                            &mut perc1_filter_cutoff,
                            &mut perc1_filter_resonance,
                            &mut perc1_pitch_base,
                            &mut perc1_decay_base,
                            &mut perc1_tone_base,
                            &mut perc1_drive_base,
                            &mut perc1_level_base,
                            &mut perc1_filter_type_base,
                            &mut perc1_filter_cutoff_base,
                            &mut perc1_filter_resonance_base,
                            &mut perc1_decay_time,
                            &mut perc1_decay_coeff,
                            &mut perc1_attack_time,
                            &mut perc1_attack_samples,
                            &mut perc1_attack_step,
                            &mut perc1_freq,
                            &mut perc1_cutoff_hz,
                            &mut perc1_q,
                            &mut perc1_drive_gain,
                            &mut perc1_damping,
                        );
                        apply_perc2_step_params(
                            track,
                            step_idx,
                            step_hold,
                            track_muted,
                            cutoff_min,
                            cutoff_span,
                            sr,
                            &mut perc2_pitch,
                            &mut perc2_decay,
                            &mut perc2_tone,
                            &mut perc2_drive,
                            &mut perc2_level,
                            &mut perc2_filter_type,
                            &mut perc2_filter_cutoff,
                            &mut perc2_filter_resonance,
                            &mut perc2_pitch_base,
                            &mut perc2_decay_base,
                            &mut perc2_tone_base,
                            &mut perc2_drive_base,
                            &mut perc2_level_base,
                            &mut perc2_filter_type_base,
                            &mut perc2_filter_cutoff_base,
                            &mut perc2_filter_resonance_base,
                            &mut perc2_decay_time,
                            &mut perc2_env_coeff,
                            &mut perc2_freq,
                            &mut perc2_mod_index,
                            &mut perc2_cutoff_hz,
                            &mut perc2_q,
                            &mut perc2_drive_gain,
                        );
                        apply_crash_step_params(
                            track,
                            step_idx,
                            step_hold,
                            track_muted,
                            cutoff_min,
                            cutoff_span,
                            sr,
                            &mut crash_pitch,
                            &mut crash_decay,
                            &mut crash_tone,
                            &mut crash_drive,
                            &mut crash_level,
                            &mut crash_filter_type,
                            &mut crash_filter_cutoff,
                            &mut crash_filter_resonance,
                            &mut crash_pitch_base,
                            &mut crash_decay_base,
                            &mut crash_tone_base,
                            &mut crash_drive_base,
                            &mut crash_level_base,
                            &mut crash_filter_type_base,
                            &mut crash_filter_cutoff_base,
                            &mut crash_filter_resonance_base,
                            &mut crash_decay_time,
                            &mut crash_env_coeff,
                            &mut crash_attack_samples,
                            &mut crash_attack_step,
                            &mut crash_freq,
                            &mut crash_harmonicity,
                            &mut crash_mod_index,
                            &mut crash_cutoff_hz,
                            &mut crash_q,
                            &mut crash_drive_gain,
                        );
                        for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                            apply_samp_step_params(
                                track,
                                samp_idx,
                                step_idx,
                                step_hold,
                                track_muted,
                                cutoff_min,
                                cutoff_span,
                                sr,
                                &mut samp_pitch[samp_idx],
                                &mut samp_attack[samp_idx],
                                &mut samp_decay[samp_idx],
                                &mut samp_drive[samp_idx],
                                &mut samp_level[samp_idx],
                                &mut samp_filter_type[samp_idx],
                                &mut samp_filter_cutoff[samp_idx],
                                &mut samp_filter_resonance[samp_idx],
                                &mut samp_pitch_base[samp_idx],
                                &mut samp_attack_base[samp_idx],
                                &mut samp_decay_base[samp_idx],
                                &mut samp_drive_base[samp_idx],
                                &mut samp_level_base[samp_idx],
                                &mut samp_filter_type_base[samp_idx],
                                &mut samp_filter_cutoff_base[samp_idx],
                                &mut samp_filter_resonance_base[samp_idx],
                                &mut samp_attack_samples[samp_idx],
                                &mut samp_attack_step[samp_idx],
                                &mut samp_decay_time[samp_idx],
                                &mut samp_decay_coeff[samp_idx],
                                &mut samp_rate[samp_idx],
                                &mut samp_drive_gain[samp_idx],
                                &mut samp_cutoff_hz[samp_idx],
                                &mut samp_q[samp_idx],
                                samp_sample_len[samp_idx],
                                samp_sample_rate[samp_idx],
                            );
                        }

                        let mut should_trigger = |active: bool, prob: f32| -> bool {
                            if !active {
                                false
                            } else if prob >= 1.0 {
                                true
                            } else if prob <= 0.0 {
                                false
                            } else {
                                syndrm_rand_unit(&mut rng_state) <= prob
                            }
                        };

                        let kick_trigger = should_trigger(
                            track.kick_lane_enabled.load(Ordering::Relaxed)
                                && track.kick_sequencer_grid[step_idx].load(Ordering::Relaxed),
                            kick_prob,
                        );
                        let snare_trigger = should_trigger(
                            track.snare_lane_enabled.load(Ordering::Relaxed)
                                && track.snare_sequencer_grid[step_idx].load(Ordering::Relaxed),
                            snare_prob,
                        );
                        let clap_trigger = should_trigger(
                            track.clap_lane_enabled.load(Ordering::Relaxed)
                                && track.clap_sequencer_grid[step_idx].load(Ordering::Relaxed),
                            clap_prob,
                        );
                        let hat_trigger = should_trigger(
                            track.hat_lane_enabled.load(Ordering::Relaxed)
                                && track.hat_sequencer_grid[step_idx].load(Ordering::Relaxed),
                            hat_prob,
                        );
                        let perc1_trigger = should_trigger(
                            track.perc1_lane_enabled.load(Ordering::Relaxed)
                                && track.perc1_sequencer_grid[step_idx].load(Ordering::Relaxed),
                            perc1_prob,
                        );
                        let perc2_trigger = should_trigger(
                            track.perc2_lane_enabled.load(Ordering::Relaxed)
                                && track.perc2_sequencer_grid[step_idx].load(Ordering::Relaxed),
                            perc2_prob,
                        );
                        let crash_trigger = should_trigger(
                            track.crash_lane_enabled.load(Ordering::Relaxed)
                                && track.crash_sequencer_grid[step_idx].load(Ordering::Relaxed),
                            crash_prob,
                        );
                        let mut samp_triggers = [false; SYNDRM_SAMPLE_CHANNELS];
                        for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                            samp_triggers[samp_idx] = should_trigger(
                                track.samp_lane_enabled[samp_idx].load(Ordering::Relaxed)
                                    && track.samp_sequencer_grid[samp_idx][step_idx]
                                        .load(Ordering::Relaxed),
                                samp_prob[samp_idx],
                            );
                        }

                        let mut cut_groups = [false; 15];
                        if kick_trigger {
                            if kick_cut_group > 0 && (kick_cut_group as usize) < cut_groups.len() {
                                cut_groups[kick_cut_group as usize] = true;
                            }
                        }
                        if snare_trigger {
                            if snare_cut_group > 0 && (snare_cut_group as usize) < cut_groups.len() {
                                cut_groups[snare_cut_group as usize] = true;
                            }
                        }
                        if clap_trigger {
                            if clap_cut_group > 0 && (clap_cut_group as usize) < cut_groups.len() {
                                cut_groups[clap_cut_group as usize] = true;
                            }
                        }
                        if hat_trigger {
                            if hat_cut_group > 0 && (hat_cut_group as usize) < cut_groups.len() {
                                cut_groups[hat_cut_group as usize] = true;
                            }
                        }
                        if perc1_trigger {
                            if perc1_cut_group > 0 && (perc1_cut_group as usize) < cut_groups.len() {
                                cut_groups[perc1_cut_group as usize] = true;
                            }
                        }
                        if perc2_trigger {
                            if perc2_cut_group > 0 && (perc2_cut_group as usize) < cut_groups.len() {
                                cut_groups[perc2_cut_group as usize] = true;
                            }
                        }
                        if crash_trigger {
                            if crash_cut_group > 0 && (crash_cut_group as usize) < cut_groups.len() {
                                cut_groups[crash_cut_group as usize] = true;
                            }
                        }
                        for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                            if samp_triggers[samp_idx] {
                                let cut_group = samp_cut_group[samp_idx];
                                if cut_group > 0 && (cut_group as usize) < cut_groups.len() {
                                    cut_groups[cut_group as usize] = true;
                                }
                            }
                        }

                        let should_cut = |cut_by: u32| -> bool {
                            if cut_by == 0 {
                                return false;
                            }
                            let idx = cut_by as usize;
                            idx < cut_groups.len() && cut_groups[idx]
                        };

                        if should_cut(kick_cut_by) {
                            env = 0.0;
                            pitch_env = 0.0;
                            attack_remaining = 0;
                        }
                        if should_cut(snare_cut_by) {
                            snare_env = 0.0;
                            snare_noise_env = 0.0;
                            snare_attack_remaining = 0;
                        }
                        if should_cut(clap_cut_by) {
                            clap_env = 0.0;
                            clap_phase = 0;
                        }
                        if should_cut(hat_cut_by) {
                            hat_env = 0.0;
                            hat_attack_remaining = 0;
                        }
                        if should_cut(perc1_cut_by) {
                            perc1_attack_remaining = 0;
                            perc1_delay_len = 1;
                            dsp_state.perc1_karplus_line.fill(0.0);
                            perc1_pos = 0;
                        }
                        if should_cut(perc2_cut_by) {
                            perc2_env = 0.0;
                        }
                        if should_cut(crash_cut_by) {
                            crash_env = 0.0;
                            crash_attack_remaining = 0;
                        }
                        for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                            if should_cut(samp_cut_by[samp_idx]) {
                                samp_env[samp_idx] = 0.0;
                                samp_attack_remaining[samp_idx] = 0;
                                samp_decay_remaining[samp_idx] = 0;
                            }
                        }

                        if kick_trigger {
                            pitch_env = 1.0;
                            if attack_samples > 0 {
                                attack_remaining = attack_samples;
                            } else {
                                env = 1.0;
                            }
                        }
                        if snare_trigger {
                            if snare_attack_samples > 0 {
                                snare_attack_remaining = snare_attack_samples;
                                snare_env = 0.0;
                                snare_noise_env = 0.0;
                            } else {
                                snare_env = 1.0;
                                snare_noise_env = 1.0;
                            }
                        }
                        if clap_trigger {
                            clap_env = 1.0;
                            clap_phase = 0;
                        }
                        if hat_trigger {
                            if hat_attack_samples > 0 {
                                hat_attack_remaining = hat_attack_samples;
                                hat_env = 0.0;
                            } else {
                                hat_env = 1.0;
                            }
                            // Reset MetalSynth phase state on each trigger to match Tone.js behavior.
                            for i in 0..METAL_INHARM_RATIOS.len() {
                                hat_phases[i] = 0.0;
                                hat_mod_phases[i] = 0.0;
                            }
                            hat_hp_x_prev = 0.0;
                            hat_hp_y_prev = 0.0;
                        }
                        if perc1_trigger {
                            if perc1_attack_samples > 0 {
                                perc1_attack_remaining = perc1_attack_samples;
                            } else {
                                perc1_attack_remaining = 1;
                            }
                        }
                        if perc2_trigger {
                            perc2_env = 1.0;
                            perc2_carrier_phase = 0.0;
                            perc2_mod_phase = 0.0;
                        }
                        if crash_trigger {
                            if crash_attack_samples > 0 {
                                crash_attack_remaining = crash_attack_samples;
                                crash_env = 0.0;
                            } else {
                                crash_env = 1.0;
                            }
                            for i in 0..METAL_INHARM_RATIOS.len() {
                                crash_phases[i] = 0.0;
                                crash_mod_phases[i] = 0.0;
                            }
                            crash_hp_x_prev = 0.0;
                            crash_hp_y_prev = 0.0;
                        }
                        for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                            if samp_triggers[samp_idx] {
                                samp_playhead[samp_idx] = 0.0;
                                if samp_attack_samples[samp_idx] > 0 {
                                    samp_attack_remaining[samp_idx] =
                                        samp_attack_samples[samp_idx];
                                    samp_env[samp_idx] = 0.0;
                                } else {
                                    samp_env[samp_idx] = 1.0;
                                    samp_attack_remaining[samp_idx] = 0;
                                }
                                samp_decay_remaining[samp_idx] =
                                    (samp_decay_time[samp_idx] * sr).round().max(0.0) as u32;
                            }
                        }

                        let kick_retrig_enabled = track.kick_step_retrig_enabled[step_idx]
                            .load(Ordering::Relaxed);
                        let kick_retrig_division = track.kick_step_retrig_division[step_idx]
                            .load(Ordering::Relaxed);
                        arm_retrig(
                            kick_retrig_enabled,
                            kick_retrig_division,
                            kick_trigger,
                            &mut kick_retrig_remaining,
                            &mut kick_retrig_timer,
                            &mut kick_retrig_interval,
                        );

                        let snare_retrig_enabled = track.snare_step_retrig_enabled[step_idx]
                            .load(Ordering::Relaxed);
                        let snare_retrig_division = track.snare_step_retrig_division[step_idx]
                            .load(Ordering::Relaxed);
                        arm_retrig(
                            snare_retrig_enabled,
                            snare_retrig_division,
                            snare_trigger,
                            &mut snare_retrig_remaining,
                            &mut snare_retrig_timer,
                            &mut snare_retrig_interval,
                        );

                        let clap_retrig_enabled = track.clap_step_retrig_enabled[step_idx]
                            .load(Ordering::Relaxed);
                        let clap_retrig_division = track.clap_step_retrig_division[step_idx]
                            .load(Ordering::Relaxed);
                        arm_retrig(
                            clap_retrig_enabled,
                            clap_retrig_division,
                            clap_trigger,
                            &mut clap_retrig_remaining,
                            &mut clap_retrig_timer,
                            &mut clap_retrig_interval,
                        );

                        let hat_retrig_enabled = track.hat_step_retrig_enabled[step_idx]
                            .load(Ordering::Relaxed);
                        let hat_retrig_division = track.hat_step_retrig_division[step_idx]
                            .load(Ordering::Relaxed);
                        arm_retrig(
                            hat_retrig_enabled,
                            hat_retrig_division,
                            hat_trigger,
                            &mut hat_retrig_remaining,
                            &mut hat_retrig_timer,
                            &mut hat_retrig_interval,
                        );

                        let perc1_retrig_enabled = track.perc1_step_retrig_enabled[step_idx]
                            .load(Ordering::Relaxed);
                        let perc1_retrig_division = track.perc1_step_retrig_division[step_idx]
                            .load(Ordering::Relaxed);
                        arm_retrig(
                            perc1_retrig_enabled,
                            perc1_retrig_division,
                            perc1_trigger,
                            &mut perc1_retrig_remaining,
                            &mut perc1_retrig_timer,
                            &mut perc1_retrig_interval,
                        );

                        let perc2_retrig_enabled = track.perc2_step_retrig_enabled[step_idx]
                            .load(Ordering::Relaxed);
                        let perc2_retrig_division = track.perc2_step_retrig_division[step_idx]
                            .load(Ordering::Relaxed);
                        arm_retrig(
                            perc2_retrig_enabled,
                            perc2_retrig_division,
                            perc2_trigger,
                            &mut perc2_retrig_remaining,
                            &mut perc2_retrig_timer,
                            &mut perc2_retrig_interval,
                        );

                        let crash_retrig_enabled = track.crash_step_retrig_enabled[step_idx]
                            .load(Ordering::Relaxed);
                        let crash_retrig_division = track.crash_step_retrig_division[step_idx]
                            .load(Ordering::Relaxed);
                        arm_retrig(
                            crash_retrig_enabled,
                            crash_retrig_division,
                            crash_trigger,
                            &mut crash_retrig_remaining,
                            &mut crash_retrig_timer,
                            &mut crash_retrig_interval,
                        );

                        for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                            let samp_retrig_enabled = track.samp_step_retrig_enabled[samp_idx]
                                [step_idx]
                                .load(Ordering::Relaxed);
                            let samp_retrig_division = track.samp_step_retrig_division[samp_idx]
                                [step_idx]
                                .load(Ordering::Relaxed);
                            arm_retrig(
                                samp_retrig_enabled,
                                samp_retrig_division,
                                samp_triggers[samp_idx],
                                &mut samp_retrig_remaining[samp_idx],
                                &mut samp_retrig_timer[samp_idx],
                                &mut samp_retrig_interval[samp_idx],
                            );
                        }
                    }
                }
            }

            if transport_running {
                if kick_retrig_remaining > 0 && kick_retrig_interval > 0.0 {
                    kick_retrig_timer -= 1.0;
                    if kick_retrig_timer <= 0.0 {
                        if attack_samples > 0 {
                            attack_remaining = attack_samples;
                        } else {
                            env = 1.0;
                        }
                        pitch_env = 1.0;
                        kick_retrig_remaining = kick_retrig_remaining.saturating_sub(1);
                        kick_retrig_timer += kick_retrig_interval;
                    }
                }
                if snare_retrig_remaining > 0 && snare_retrig_interval > 0.0 {
                    snare_retrig_timer -= 1.0;
                    if snare_retrig_timer <= 0.0 {
                        if snare_attack_samples > 0 {
                            snare_attack_remaining = snare_attack_samples;
                            snare_env = 0.0;
                            snare_noise_env = 0.0;
                        } else {
                            snare_env = 1.0;
                            snare_noise_env = 1.0;
                        }
                        snare_retrig_remaining = snare_retrig_remaining.saturating_sub(1);
                        snare_retrig_timer += snare_retrig_interval;
                    }
                }
                if clap_retrig_remaining > 0 && clap_retrig_interval > 0.0 {
                    clap_retrig_timer -= 1.0;
                    if clap_retrig_timer <= 0.0 {
                        clap_env = 1.0;
                        clap_phase = 0;
                        clap_retrig_remaining = clap_retrig_remaining.saturating_sub(1);
                        clap_retrig_timer += clap_retrig_interval;
                    }
                }
                if hat_retrig_remaining > 0 && hat_retrig_interval > 0.0 {
                    hat_retrig_timer -= 1.0;
                    if hat_retrig_timer <= 0.0 {
                        if hat_attack_samples > 0 {
                            hat_attack_remaining = hat_attack_samples;
                            hat_env = 0.0;
                        } else {
                            hat_env = 1.0;
                        }
                        for i in 0..METAL_INHARM_RATIOS.len() {
                            hat_phases[i] = 0.0;
                            hat_mod_phases[i] = 0.0;
                        }
                        hat_hp_x_prev = 0.0;
                        hat_hp_y_prev = 0.0;
                        hat_retrig_remaining = hat_retrig_remaining.saturating_sub(1);
                        hat_retrig_timer += hat_retrig_interval;
                    }
                }
                if perc1_retrig_remaining > 0 && perc1_retrig_interval > 0.0 {
                    perc1_retrig_timer -= 1.0;
                    if perc1_retrig_timer <= 0.0 {
                        if perc1_attack_samples > 0 {
                            perc1_attack_remaining = perc1_attack_samples;
                        } else {
                            perc1_attack_remaining = 1;
                        }
                        perc1_retrig_remaining = perc1_retrig_remaining.saturating_sub(1);
                        perc1_retrig_timer += perc1_retrig_interval;
                    }
                }
                if perc2_retrig_remaining > 0 && perc2_retrig_interval > 0.0 {
                    perc2_retrig_timer -= 1.0;
                    if perc2_retrig_timer <= 0.0 {
                        perc2_env = 1.0;
                        perc2_carrier_phase = 0.0;
                        perc2_mod_phase = 0.0;
                        perc2_retrig_remaining = perc2_retrig_remaining.saturating_sub(1);
                        perc2_retrig_timer += perc2_retrig_interval;
                    }
                }
                if crash_retrig_remaining > 0 && crash_retrig_interval > 0.0 {
                    crash_retrig_timer -= 1.0;
                    if crash_retrig_timer <= 0.0 {
                        if crash_attack_samples > 0 {
                            crash_attack_remaining = crash_attack_samples;
                            crash_env = 0.0;
                        } else {
                            crash_env = 1.0;
                        }
                        for i in 0..METAL_INHARM_RATIOS.len() {
                            crash_phases[i] = 0.0;
                            crash_mod_phases[i] = 0.0;
                        }
                        crash_hp_x_prev = 0.0;
                        crash_hp_y_prev = 0.0;
                        crash_retrig_remaining = crash_retrig_remaining.saturating_sub(1);
                        crash_retrig_timer += crash_retrig_interval;
                    }
                }
                for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                    if samp_retrig_remaining[samp_idx] > 0
                        && samp_retrig_interval[samp_idx] > 0.0
                    {
                        samp_retrig_timer[samp_idx] -= 1.0;
                        if samp_retrig_timer[samp_idx] <= 0.0 {
                            samp_playhead[samp_idx] = 0.0;
                            if samp_attack_samples[samp_idx] > 0 {
                                samp_attack_remaining[samp_idx] = samp_attack_samples[samp_idx];
                                samp_env[samp_idx] = 0.0;
                            } else {
                                samp_env[samp_idx] = 1.0;
                                samp_attack_remaining[samp_idx] = 0;
                            }
                            samp_decay_remaining[samp_idx] =
                                (samp_decay_time[samp_idx] * sr).round().max(0.0) as u32;
                            samp_retrig_remaining[samp_idx] =
                                samp_retrig_remaining[samp_idx].saturating_sub(1);
                            samp_retrig_timer[samp_idx] += samp_retrig_interval[samp_idx];
                        }
                    }
                }
            }

            if attack_remaining > 0 {
                env = (env + (1.0 - env) * attack_step).min(1.0);
                attack_remaining = attack_remaining.saturating_sub(1);
            } else {
                env *= env_coeff;
            }
            pitch_env *= pitch_coeff;
            if snare_attack_remaining > 0 {
                snare_env = (snare_env + (1.0 - snare_env) * snare_attack_step).min(1.0);
                snare_noise_env =
                    (snare_noise_env + (1.0 - snare_noise_env) * snare_attack_step).min(1.0);
                snare_attack_remaining = snare_attack_remaining.saturating_sub(1);
            } else {
                snare_env *= snare_env_coeff;
                snare_noise_env *= snare_noise_coeff;
            }
            if clap_env > 0.0 {
                clap_env *= clap_env_coeff;
                if clap_env < 1.0e-5 {
                    clap_env = 0.0;
                    clap_phase = 0;
                }
            }
            if hat_attack_remaining > 0 {
                hat_env = (hat_env + (1.0 - hat_env) * hat_attack_step).min(1.0);
                hat_attack_remaining = hat_attack_remaining.saturating_sub(1);
            } else {
                hat_env *= hat_env_coeff;
            }
            if perc2_env > 0.0 {
                perc2_env *= perc2_env_coeff;
                if perc2_env < 1.0e-5 {
                    perc2_env = 0.0;
                }
            }
            if crash_attack_remaining > 0 {
                crash_env = (crash_env + (1.0 - crash_env) * crash_attack_step).min(1.0);
                crash_attack_remaining = crash_attack_remaining.saturating_sub(1);
            } else {
                crash_env *= crash_env_coeff;
            }
            for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                if samp_attack_remaining[samp_idx] > 0 {
                    samp_env[samp_idx] =
                        (samp_env[samp_idx] + (1.0 - samp_env[samp_idx]) * samp_attack_step[samp_idx])
                            .min(1.0);
                    samp_attack_remaining[samp_idx] =
                        samp_attack_remaining[samp_idx].saturating_sub(1);
                } else if samp_env[samp_idx] > 0.0 {
                    if samp_decay_coeff[samp_idx] > 0.0 {
                        samp_env[samp_idx] *= samp_decay_coeff[samp_idx];
                        if samp_env[samp_idx] < 1.0e-5 {
                            samp_env[samp_idx] = 0.0;
                        }
                    } else {
                        samp_env[samp_idx] = 0.0;
                    }
                }
            }

            let freq = base_freq + pitch_env * sweep;
            let mut osc_out = [0.0f32];
            dsp_state.kick_osc.tick(&[freq], &mut osc_out);
            let mut sample = osc_out[0] * env;
            if kick_filter_pre_drive {
                sample = Self::apply_syndrm_filter(
                    kick_filter_type,
                    sample,
                    kick_cutoff_hz,
                    kick_q,
                    &mut *dsp_state.kick_filter_moog,
                    &mut *dsp_state.kick_filter_lp,
                    &mut *dsp_state.kick_filter_hp,
                    &mut *dsp_state.kick_filter_bp,
                );
            }
            if kick_drive > 0.0 {
                let mut drive_out = [0.0f32];
                dsp_state.kick_drive.tick(&[sample * drive], &mut drive_out);
                sample = drive_out[0];
            }
            if !kick_filter_pre_drive {
                sample = Self::apply_syndrm_filter(
                    kick_filter_type,
                    sample,
                    kick_cutoff_hz,
                    kick_q,
                    &mut *dsp_state.kick_filter_moog,
                    &mut *dsp_state.kick_filter_lp,
                    &mut *dsp_state.kick_filter_hp,
                    &mut *dsp_state.kick_filter_bp,
                );
            }
            sample *= kick_level;

            if snare_env > 0.0 || snare_noise_env > 0.0 {
                let mut tone_out = [0.0f32];
                dsp_state.snare_osc.tick(&[snare_freq], &mut tone_out);
                let mut noise_out = [0.0f32];
                dsp_state.snare_noise.tick(&[], &mut noise_out);
                let tone_sample = tone_out[0] * snare_env;
                let noise_sample = noise_out[0] * snare_noise_env;
                let mut snare_sample =
                    tone_sample * (1.0 - snare_snappy) + noise_sample * snare_snappy;
                if snare_filter_pre_drive {
                    snare_sample = Self::apply_syndrm_filter(
                        snare_filter_type,
                        snare_sample,
                        snare_cutoff_hz,
                        snare_q,
                        &mut *dsp_state.snare_filter_moog,
                        &mut *dsp_state.snare_filter_lp,
                        &mut *dsp_state.snare_filter_hp,
                        &mut *dsp_state.snare_filter_bp,
                    );
                }
                let mut drive_out = [0.0f32];
                dsp_state
                    .snare_drive
                    .tick(&[snare_sample * snare_drive_gain], &mut drive_out);
                snare_sample = drive_out[0];
                if !snare_filter_pre_drive {
                    snare_sample = Self::apply_syndrm_filter(
                        snare_filter_type,
                        snare_sample,
                        snare_cutoff_hz,
                        snare_q,
                        &mut *dsp_state.snare_filter_moog,
                        &mut *dsp_state.snare_filter_lp,
                        &mut *dsp_state.snare_filter_hp,
                        &mut *dsp_state.snare_filter_bp,
                    );
                }
                sample += snare_sample * snare_level;
            }

            if clap_env > 0.0 {
                let mut noise_out = [0.0f32];
                dsp_state.clap_noise.tick(&[], &mut noise_out);
                let phase = clap_phase;
                let mut burst_env = 0.0f32;
                let t = phase as f32;
                burst_env += (-t * clap_burst_inv).exp();
                if phase >= clap_burst_delay_1 {
                    let dt = (phase - clap_burst_delay_1) as f32;
                    burst_env += (-dt * clap_burst_inv).exp();
                }
                if phase >= clap_burst_delay_2 {
                    let dt = (phase - clap_burst_delay_2) as f32;
                    burst_env += (-dt * clap_burst_inv).exp();
                }
                if phase >= clap_burst_delay_3 {
                    let dt = (phase - clap_burst_delay_3) as f32;
                    burst_env += (-dt * clap_burst_inv).exp();
                }

                let mut clap_sample = noise_out[0] * clap_env * burst_env;
                if clap_filter_pre_drive {
                    clap_sample = Self::apply_syndrm_filter(
                        clap_filter_type,
                        clap_sample,
                        clap_cutoff_hz,
                        clap_q,
                        &mut *dsp_state.clap_filter_moog,
                        &mut *dsp_state.clap_filter_lp,
                        &mut *dsp_state.clap_filter_hp,
                        &mut *dsp_state.clap_filter_bp,
                    );
                }
                if clap_drive > 0.0 {
                    let mut drive_out = [0.0f32];
                    dsp_state
                        .clap_drive
                        .tick(&[clap_sample * clap_drive_gain], &mut drive_out);
                    clap_sample = drive_out[0];
                }
                if !clap_filter_pre_drive {
                    clap_sample = Self::apply_syndrm_filter(
                        clap_filter_type,
                        clap_sample,
                        clap_cutoff_hz,
                        clap_q,
                        &mut *dsp_state.clap_filter_moog,
                        &mut *dsp_state.clap_filter_lp,
                        &mut *dsp_state.clap_filter_hp,
                        &mut *dsp_state.clap_filter_bp,
                    );
                }
                sample += clap_sample * clap_level;
                clap_phase = clap_phase.saturating_add(1);
            }

            if hat_env > 0.0 {
                let mut osc_sum = 0.0f32;
                for i in 0..METAL_INHARM_RATIOS.len() {
                    let ratio = METAL_INHARM_RATIOS[i];
                    let carrier_freq = hat_freq * ratio;
                    let mod_freq = carrier_freq * hat_harmonicity;
                    let mod_phase = hat_mod_phases[i];
                    let mod_signal = if (mod_phase * 2.0 * PI).sin() >= 0.0 {
                        1.0
                    } else {
                        -1.0
                    };
                    let carrier_phase = hat_phases[i];
                    let phase_mod = carrier_phase * 2.0 * PI + hat_mod_index * mod_signal;
                    let carrier = if phase_mod.sin() >= 0.0 { 1.0 } else { -1.0 };
                    osc_sum += carrier;
                    let mut next_mod = mod_phase + mod_freq / sr;
                    if next_mod >= 1.0 {
                        next_mod -= 1.0;
                    }
                    hat_mod_phases[i] = next_mod;
                    let mut next_carrier = carrier_phase + carrier_freq / sr;
                    if next_carrier >= 1.0 {
                        next_carrier -= 1.0;
                    }
                    hat_phases[i] = next_carrier;
                }
                osc_sum *= 1.0 / METAL_INHARM_RATIOS.len() as f32;

                let hp_min = METAL_RESONANCE_HZ;
                let hp_max = hp_min * 2.0f32.powf(METAL_OCTAVES);
                let hp_cutoff = hp_min + (hp_max - hp_min) * hat_env;
                let hp_alpha = (-2.0 * PI * hp_cutoff / sr).exp();
                let hp_out = hp_alpha * (hat_hp_y_prev + osc_sum - hat_hp_x_prev);
                hat_hp_x_prev = osc_sum;
                hat_hp_y_prev = hp_out;

                let mut hat_sample = hp_out * hat_env;
                if hat_filter_pre_drive {
                    hat_sample = Self::apply_syndrm_filter(
                        hat_filter_type,
                        hat_sample,
                        hat_cutoff_hz,
                        hat_q,
                        &mut *dsp_state.hat_filter_moog,
                        &mut *dsp_state.hat_filter_lp,
                        &mut *dsp_state.hat_filter_hp,
                        &mut *dsp_state.hat_filter_bp,
                    );
                }
                if hat_drive > 0.0 {
                    let mut drive_out = [0.0f32];
                    dsp_state
                        .hat_drive
                        .tick(&[hat_sample * hat_drive_gain], &mut drive_out);
                    hat_sample = drive_out[0];
                }
                if !hat_filter_pre_drive {
                    hat_sample = Self::apply_syndrm_filter(
                        hat_filter_type,
                        hat_sample,
                        hat_cutoff_hz,
                        hat_q,
                        &mut *dsp_state.hat_filter_moog,
                        &mut *dsp_state.hat_filter_lp,
                        &mut *dsp_state.hat_filter_hp,
                        &mut *dsp_state.hat_filter_bp,
                    );
                }
                sample += hat_sample * hat_level;
            }
            if perc1_attack_remaining > 0 || perc1_delay_len > 1 {
                let target_delay = ((sr / perc1_freq).round() as usize)
                    .clamp(2, perc1_line_len - 1);
                if target_delay != perc1_delay_len {
                    perc1_delay_len = target_delay;
                    if perc1_pos >= perc1_delay_len {
                        perc1_pos %= perc1_delay_len;
                    }
                }

                let excite = if perc1_attack_remaining > 0 {
                    let mut noise_out = [0.0f32];
                    dsp_state.perc1_noise.tick(&[], &mut noise_out);
                    perc1_attack_remaining = perc1_attack_remaining.saturating_sub(1);
                    noise_out[0] * (0.3 + perc1_tone * 0.7)
                } else {
                    0.0
                };

                let idx = perc1_pos;
                let next_idx = if idx + 1 >= perc1_delay_len { 0 } else { idx + 1 };
                let y = dsp_state.perc1_karplus_line[idx];
                let next = dsp_state.perc1_karplus_line[next_idx];
                let filtered = (y + next) * 0.5;
                dsp_state.perc1_karplus_line[idx] =
                    filtered * perc1_decay_coeff * perc1_damping + excite;
                perc1_pos = if idx + 1 >= perc1_delay_len { 0 } else { idx + 1 };

                let mut perc1_sample = y;
                if perc1_filter_pre_drive {
                    perc1_sample = Self::apply_syndrm_filter(
                        perc1_filter_type,
                        perc1_sample,
                        perc1_cutoff_hz,
                        perc1_q,
                        &mut *dsp_state.perc1_filter_moog,
                        &mut *dsp_state.perc1_filter_lp,
                        &mut *dsp_state.perc1_filter_hp,
                        &mut *dsp_state.perc1_filter_bp,
                    );
                }
                if perc1_drive > 0.0 {
                    let mut drive_out = [0.0f32];
                    dsp_state
                        .perc1_drive
                        .tick(&[perc1_sample * perc1_drive_gain], &mut drive_out);
                    perc1_sample = drive_out[0];
                }
                if !perc1_filter_pre_drive {
                    perc1_sample = Self::apply_syndrm_filter(
                        perc1_filter_type,
                        perc1_sample,
                        perc1_cutoff_hz,
                        perc1_q,
                        &mut *dsp_state.perc1_filter_moog,
                        &mut *dsp_state.perc1_filter_lp,
                        &mut *dsp_state.perc1_filter_hp,
                        &mut *dsp_state.perc1_filter_bp,
                    );
                }
                sample += perc1_sample * perc1_level;
            }
            if perc2_env > 0.0 {
                let mod_freq = perc2_freq;
                let mod_signal = (perc2_mod_phase * 2.0 * PI).sin();
                let phase_mod = perc2_carrier_phase * 2.0 * PI + perc2_mod_index * mod_signal;
                let mut perc2_sample = phase_mod.sin() * perc2_env;
                if perc2_filter_pre_drive {
                    perc2_sample = Self::apply_syndrm_filter(
                        perc2_filter_type,
                        perc2_sample,
                        perc2_cutoff_hz,
                        perc2_q,
                        &mut *dsp_state.perc2_filter_moog,
                        &mut *dsp_state.perc2_filter_lp,
                        &mut *dsp_state.perc2_filter_hp,
                        &mut *dsp_state.perc2_filter_bp,
                    );
                }
                if perc2_drive > 0.0 {
                    let mut drive_out = [0.0f32];
                    dsp_state
                        .perc2_drive
                        .tick(&[perc2_sample * perc2_drive_gain], &mut drive_out);
                    perc2_sample = drive_out[0];
                }
                if !perc2_filter_pre_drive {
                    perc2_sample = Self::apply_syndrm_filter(
                        perc2_filter_type,
                        perc2_sample,
                        perc2_cutoff_hz,
                        perc2_q,
                        &mut *dsp_state.perc2_filter_moog,
                        &mut *dsp_state.perc2_filter_lp,
                        &mut *dsp_state.perc2_filter_hp,
                        &mut *dsp_state.perc2_filter_bp,
                    );
                }
                sample += perc2_sample * perc2_level;

                perc2_carrier_phase += perc2_freq / sr;
                if perc2_carrier_phase >= 1.0 {
                    perc2_carrier_phase -= 1.0;
                }
                perc2_mod_phase += mod_freq / sr;
                if perc2_mod_phase >= 1.0 {
                    perc2_mod_phase -= 1.0;
                }
            }
            if crash_env > 0.0 {
                let mut osc_sum = 0.0f32;
                for i in 0..METAL_INHARM_RATIOS.len() {
                    let ratio = METAL_INHARM_RATIOS[i];
                    let carrier_freq = crash_freq * ratio;
                    let mod_freq = carrier_freq * crash_harmonicity;
                    let mod_phase = crash_mod_phases[i];
                    let mod_signal = if (mod_phase * 2.0 * PI).sin() >= 0.0 {
                        1.0
                    } else {
                        -1.0
                    };
                    let carrier_phase = crash_phases[i];
                    let phase_mod = carrier_phase * 2.0 * PI + crash_mod_index * mod_signal;
                    let carrier = if phase_mod.sin() >= 0.0 { 1.0 } else { -1.0 };
                    osc_sum += carrier;
                    let mut next_mod = mod_phase + mod_freq / sr;
                    if next_mod >= 1.0 {
                        next_mod -= 1.0;
                    }
                    crash_mod_phases[i] = next_mod;
                    let mut next_carrier = carrier_phase + carrier_freq / sr;
                    if next_carrier >= 1.0 {
                        next_carrier -= 1.0;
                    }
                    crash_phases[i] = next_carrier;
                }
                osc_sum *= 1.0 / METAL_INHARM_RATIOS.len() as f32;

                let hp_min = METAL_RESONANCE_HZ;
                let hp_max = hp_min * 2.0f32.powf(METAL_OCTAVES);
                let hp_cutoff = hp_min + (hp_max - hp_min) * crash_env;
                let hp_alpha = (-2.0 * PI * hp_cutoff / sr).exp();
                let hp_out = hp_alpha * (crash_hp_y_prev + osc_sum - crash_hp_x_prev);
                crash_hp_x_prev = osc_sum;
                crash_hp_y_prev = hp_out;

                let mut crash_sample = hp_out * crash_env;
                if crash_filter_pre_drive {
                    crash_sample = Self::apply_syndrm_filter(
                        crash_filter_type,
                        crash_sample,
                        crash_cutoff_hz,
                        crash_q,
                        &mut *dsp_state.crash_filter_moog,
                        &mut *dsp_state.crash_filter_lp,
                        &mut *dsp_state.crash_filter_hp,
                        &mut *dsp_state.crash_filter_bp,
                    );
                }
                if crash_drive > 0.0 {
                    let mut drive_out = [0.0f32];
                    dsp_state
                        .crash_drive
                        .tick(&[crash_sample * crash_drive_gain], &mut drive_out);
                    crash_sample = drive_out[0];
                }
                if !crash_filter_pre_drive {
                    crash_sample = Self::apply_syndrm_filter(
                        crash_filter_type,
                        crash_sample,
                        crash_cutoff_hz,
                        crash_q,
                        &mut *dsp_state.crash_filter_moog,
                        &mut *dsp_state.crash_filter_lp,
                        &mut *dsp_state.crash_filter_hp,
                        &mut *dsp_state.crash_filter_bp,
                    );
                }
                sample += crash_sample * crash_level;
            }
            crash_phase = crash_phases[0];
            hat_phase = hat_phases[0];

            for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
                if samp_env[samp_idx] <= 0.0 && samp_attack_remaining[samp_idx] == 0 {
                    continue;
                }
                let Some(samples) = samp_samples[samp_idx].as_ref() else {
                    continue;
                };
                if samples.is_empty() || samp_sample_len[samp_idx] == 0 {
                    continue;
                }
                let playhead = samp_playhead[samp_idx];
                if playhead >= samp_sample_len[samp_idx] as f32 {
                    samp_env[samp_idx] = 0.0;
                    continue;
                }
                let idx = playhead.floor() as usize;
                let frac = playhead - idx as f32;
                let mut frame = 0.0f32;
                let mut count = 0.0f32;
                for channel in samples.iter() {
                    if channel.is_empty() {
                        continue;
                    }
                    let a = *channel.get(idx).unwrap_or(&0.0);
                    let b = *channel.get(idx + 1).unwrap_or(&a);
                    frame += a + (b - a) * frac;
                    count += 1.0;
                }
                if count > 0.0 {
                    let mut samp_sample = (frame / count) * samp_env[samp_idx];
                    if samp_filter_pre_drive[samp_idx] {
                        samp_sample = Self::apply_syndrm_filter(
                            samp_filter_type[samp_idx],
                            samp_sample,
                            samp_cutoff_hz[samp_idx],
                            samp_q[samp_idx],
                            &mut *dsp_state.samp_filter_moog[samp_idx],
                            &mut *dsp_state.samp_filter_lp[samp_idx],
                            &mut *dsp_state.samp_filter_hp[samp_idx],
                            &mut *dsp_state.samp_filter_bp[samp_idx],
                        );
                    }
                    if samp_drive[samp_idx] > 0.0 {
                        let mut drive_out = [0.0f32];
                        dsp_state.samp_drive[samp_idx]
                            .tick(&[samp_sample * samp_drive_gain[samp_idx]], &mut drive_out);
                        samp_sample = drive_out[0];
                    }
                    if !samp_filter_pre_drive[samp_idx] {
                        samp_sample = Self::apply_syndrm_filter(
                            samp_filter_type[samp_idx],
                            samp_sample,
                            samp_cutoff_hz[samp_idx],
                            samp_q[samp_idx],
                            &mut *dsp_state.samp_filter_moog[samp_idx],
                            &mut *dsp_state.samp_filter_lp[samp_idx],
                            &mut *dsp_state.samp_filter_hp[samp_idx],
                            &mut *dsp_state.samp_filter_bp[samp_idx],
                        );
                    }
                    sample += samp_sample * samp_level[samp_idx];
                }
                let rate = samp_rate[samp_idx] * samp_sample_rate[samp_idx] as f32 / sr;
                samp_playhead[samp_idx] = playhead + rate.max(0.0);
            }

            for channel in output.iter_mut() {
                channel[sample_idx] += sample;
            }
        }

        track
            .kick_sequencer_phase
            .store(sequencer_phase.round().max(0.0) as u32, Ordering::Relaxed);
        track
            .snare_sequencer_phase
            .store(sequencer_phase.round().max(0.0) as u32, Ordering::Relaxed);
        track
            .clap_sequencer_phase
            .store(sequencer_phase.round().max(0.0) as u32, Ordering::Relaxed);
        track
            .hat_sequencer_phase
            .store(sequencer_phase.round().max(0.0) as u32, Ordering::Relaxed);
        track
            .perc1_sequencer_phase
            .store(sequencer_phase.round().max(0.0) as u32, Ordering::Relaxed);
        track
            .perc2_sequencer_phase
            .store(sequencer_phase.round().max(0.0) as u32, Ordering::Relaxed);
        track
            .crash_sequencer_phase
            .store(sequencer_phase.round().max(0.0) as u32, Ordering::Relaxed);
        track.kick_env.store(env.to_bits(), Ordering::Relaxed);
        track
            .kick_pitch_env
            .store(pitch_env.to_bits(), Ordering::Relaxed);
        track
            .kick_attack_remaining
            .store(attack_remaining, Ordering::Relaxed);
        track.snare_env.store(snare_env.to_bits(), Ordering::Relaxed);
        track
            .snare_noise_env
            .store(snare_noise_env.to_bits(), Ordering::Relaxed);
        track
            .snare_attack_remaining
            .store(snare_attack_remaining, Ordering::Relaxed);
        track.clap_env.store(clap_env.to_bits(), Ordering::Relaxed);
        track.clap_phase.store(clap_phase, Ordering::Relaxed);
        track.hat_env.store(hat_env.to_bits(), Ordering::Relaxed);
        track
            .hat_attack_remaining
            .store(hat_attack_remaining, Ordering::Relaxed);
        track.hat_phase.store(hat_phase.to_bits(), Ordering::Relaxed);
        for i in 0..METAL_INHARM_RATIOS.len() {
            track.hat_phases[i].store(hat_phases[i].to_bits(), Ordering::Relaxed);
            track
                .hat_mod_phases[i]
                .store(hat_mod_phases[i].to_bits(), Ordering::Relaxed);
        }
        track
            .hat_hp_x_prev
            .store(hat_hp_x_prev.to_bits(), Ordering::Relaxed);
        track
            .hat_hp_y_prev
            .store(hat_hp_y_prev.to_bits(), Ordering::Relaxed);
        track
            .perc1_attack_remaining
            .store(perc1_attack_remaining, Ordering::Relaxed);
        track.perc2_env.store(perc2_env.to_bits(), Ordering::Relaxed);
        track
            .perc2_carrier_phase
            .store(perc2_carrier_phase.to_bits(), Ordering::Relaxed);
        track
            .perc2_mod_phase
            .store(perc2_mod_phase.to_bits(), Ordering::Relaxed);
        track.crash_env.store(crash_env.to_bits(), Ordering::Relaxed);
        track
            .crash_attack_remaining
            .store(crash_attack_remaining, Ordering::Relaxed);
        track.crash_phase.store(crash_phase.to_bits(), Ordering::Relaxed);
        for i in 0..METAL_INHARM_RATIOS.len() {
            track
                .crash_phases[i]
                .store(crash_phases[i].to_bits(), Ordering::Relaxed);
            track
                .crash_mod_phases[i]
                .store(crash_mod_phases[i].to_bits(), Ordering::Relaxed);
        }
        track
            .crash_hp_x_prev
            .store(crash_hp_x_prev.to_bits(), Ordering::Relaxed);
        track
            .crash_hp_y_prev
            .store(crash_hp_y_prev.to_bits(), Ordering::Relaxed);
        track
            .kick_retrig_remaining
            .store(kick_retrig_remaining, Ordering::Relaxed);
        track
            .kick_retrig_timer
            .store(kick_retrig_timer.to_bits(), Ordering::Relaxed);
        track
            .snare_retrig_remaining
            .store(snare_retrig_remaining, Ordering::Relaxed);
        track
            .snare_retrig_timer
            .store(snare_retrig_timer.to_bits(), Ordering::Relaxed);
        track
            .clap_retrig_remaining
            .store(clap_retrig_remaining, Ordering::Relaxed);
        track
            .clap_retrig_timer
            .store(clap_retrig_timer.to_bits(), Ordering::Relaxed);
        track
            .hat_retrig_remaining
            .store(hat_retrig_remaining, Ordering::Relaxed);
        track
            .hat_retrig_timer
            .store(hat_retrig_timer.to_bits(), Ordering::Relaxed);
        track
            .perc1_retrig_remaining
            .store(perc1_retrig_remaining, Ordering::Relaxed);
        track
            .perc1_retrig_timer
            .store(perc1_retrig_timer.to_bits(), Ordering::Relaxed);
        track
            .perc2_retrig_remaining
            .store(perc2_retrig_remaining, Ordering::Relaxed);
        track
            .perc2_retrig_timer
            .store(perc2_retrig_timer.to_bits(), Ordering::Relaxed);
        track
            .crash_retrig_remaining
            .store(crash_retrig_remaining, Ordering::Relaxed);
        track
            .crash_retrig_timer
            .store(crash_retrig_timer.to_bits(), Ordering::Relaxed);
        for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
            track
                .samp_sequencer_phase[samp_idx]
                .store(sequencer_phase.round().max(0.0) as u32, Ordering::Relaxed);
            track
                .samp_env[samp_idx]
                .store(samp_env[samp_idx].to_bits(), Ordering::Relaxed);
            track
                .samp_playhead[samp_idx]
                .store(samp_playhead[samp_idx].to_bits(), Ordering::Relaxed);
            track
                .samp_attack_remaining[samp_idx]
                .store(samp_attack_remaining[samp_idx], Ordering::Relaxed);
            track
                .samp_decay_remaining[samp_idx]
                .store(samp_decay_remaining[samp_idx], Ordering::Relaxed);
            track
                .samp_retrig_remaining[samp_idx]
                .store(samp_retrig_remaining[samp_idx], Ordering::Relaxed);
            track
                .samp_retrig_timer[samp_idx]
                .store(samp_retrig_timer[samp_idx].to_bits(), Ordering::Relaxed);
        }
        track.syndrm_rng_state.store(rng_state, Ordering::Relaxed);
        dsp_state.perc1_karplus_pos = perc1_pos;
        dsp_state.perc1_karplus_delay = perc1_delay_len;
    }

    fn apply_syndrm_filter(
        filter_type: u32,
        sample: f32,
        cutoff_hz: f32,
        q: f32,
        moog: &mut dyn AudioUnit,
        lp: &mut dyn AudioUnit,
        hp: &mut dyn AudioUnit,
        bp: &mut dyn AudioUnit,
    ) -> f32 {
        let mut out = [0.0f32];
        match filter_type {
            0 => {
                moog.tick(&[sample, cutoff_hz, q], &mut out);
                out[0]
            }
            1 => {
                lp.tick(&[sample, cutoff_hz, q], &mut out);
                out[0]
            }
            2 => {
                hp.tick(&[sample, cutoff_hz, q], &mut out);
                out[0]
            }
            3 => {
                bp.tick(&[sample, cutoff_hz, q], &mut out);
                out[0]
            }
            _ => sample,
        }
    }

    fn process_fmmi(
        track: &Track,
        track_output: &mut [Vec<f32>],
        num_buffer_samples: usize,
        global_tempo: &AtomicU32,
        _master_step: i32,
        master_phase: f32,
        master_step_count: i64,
        samples_per_step: f32,
        sample_rate: f32,
        transport_running: bool,
        dsp_state: &mut FmmiDspState,
    ) {
        let sr = sample_rate.max(1.0);
        let tempo_bits = global_tempo.load(Ordering::Relaxed);
        let tempo_raw = f32::from_bits(tempo_bits);
        let _tempo = if tempo_raw.is_finite() {
            tempo_raw.clamp(20.0, 240.0)
        } else {
            120.0
        };
        let poly_enabled = track.fmmi_poly_enabled.load(Ordering::Relaxed);

        if poly_enabled {
            let mut max_active_step = None;
            for i in 0..FMMI_STEPS {
                if track.fmmi_sequencer_grid[i].load(Ordering::Relaxed) {
                    max_active_step = Some(i);
                }
            }
            let mut loop_steps = FMMI_PAGE_SIZE;
            if let Some(max_step) = max_active_step {
                loop_steps = ((max_step / FMMI_PAGE_SIZE) + 1) * FMMI_PAGE_SIZE;
            }
            let loop_steps_i32 = loop_steps.max(1) as i32;

            let mut sequencer_phase = if transport_running {
                master_phase
            } else {
                f32::from_bits(track.fmmi_sequencer_phase.load(Ordering::Relaxed))
            };
            let mut current_step = if transport_running {
                (master_step_count as i32).rem_euclid(loop_steps_i32)
            } else {
                let step = track.fmmi_sequencer_step.load(Ordering::Relaxed);
                if step < 0 {
                    step
                } else {
                    step.rem_euclid(loop_steps_i32)
                }
            };
            if transport_running {
                track.fmmi_sequencer_step.store(current_step, Ordering::Relaxed);
            }

            let car_wave = track.fmmi_car_wave.load(Ordering::Relaxed);
            let car_freq = f32::from_bits(track.fmmi_car_freq.load(Ordering::Relaxed))
                .clamp(10.0, 20000.0);
            let car_detune = f32::from_bits(track.fmmi_car_detune.load(Ordering::Relaxed))
                .clamp(-1200.0, 1200.0);
            let mod_wave = track.fmmi_mod_wave.load(Ordering::Relaxed);
            let mod_mode = track.fmmi_mod_mode.load(Ordering::Relaxed);
            let mod_value = f32::from_bits(track.fmmi_mod_value.load(Ordering::Relaxed));
            let mod_detune = f32::from_bits(track.fmmi_mod_detune.load(Ordering::Relaxed))
                .clamp(-1200.0, 1200.0);
            let index = f32::from_bits(track.fmmi_index.load(Ordering::Relaxed)).max(0.0);
            let feedback = f32::from_bits(track.fmmi_feedback.load(Ordering::Relaxed)).max(0.0);
            let drive = f32::from_bits(track.fmmi_drive.load(Ordering::Relaxed)).clamp(0.0, 1.0);
            let out_level = f32::from_bits(track.fmmi_out_level.load(Ordering::Relaxed))
                .clamp(0.0, 1.5);
            let amp_attack = f32::from_bits(track.fmmi_amp_attack.load(Ordering::Relaxed))
                .clamp(0.0, 127.0);
            let amp_decay = f32::from_bits(track.fmmi_amp_decay.load(Ordering::Relaxed))
                .clamp(0.0, 127.0);
            let amp_sustain = f32::from_bits(track.fmmi_amp_sustain.load(Ordering::Relaxed))
                .clamp(0.0, 127.0);
            let amp_release = f32::from_bits(track.fmmi_amp_release.load(Ordering::Relaxed))
                .clamp(0.0, 127.0);
            let gate_length_override =
                f32::from_bits(track.fmmi_gate_length.load(Ordering::Relaxed));
            let prob = f32::from_bits(track.fmmi_prob.load(Ordering::Relaxed)).clamp(0.0, 1.0);
            let mut rng_state = track.fmmi_rng_state.load(Ordering::Relaxed);

            let default_gate_ms = if gate_length_override.is_finite() && gate_length_override >= 0.0
            {
                gate_length_override
            } else {
                (samples_per_step / sr).max(0.0) * 1000.0
            };

            let mut current_car_freq =
                f32::from_bits(track.fmmi_current_car_freq.load(Ordering::Relaxed));
            let mut current_car_wave = car_wave;
            let mut current_car_detune =
                f32::from_bits(track.fmmi_current_car_detune.load(Ordering::Relaxed));
            let mut current_mod_value =
                f32::from_bits(track.fmmi_current_mod_value.load(Ordering::Relaxed));
            let mut current_mod_wave = mod_wave;
            let mut current_mod_mode = mod_mode;
            let mut current_mod_detune =
                f32::from_bits(track.fmmi_current_mod_detune.load(Ordering::Relaxed));
            let mut current_index =
                f32::from_bits(track.fmmi_current_index.load(Ordering::Relaxed));
            let mut current_feedback =
                f32::from_bits(track.fmmi_current_feedback.load(Ordering::Relaxed));
            let mut current_drive =
                f32::from_bits(track.fmmi_current_drive.load(Ordering::Relaxed));
            let mut current_out_level =
                f32::from_bits(track.fmmi_current_out_level.load(Ordering::Relaxed));

            if !current_car_freq.is_finite() {
                current_car_freq = car_freq;
            }
            if !current_car_detune.is_finite() {
                current_car_detune = car_detune;
            }
            if !current_mod_value.is_finite() {
                current_mod_value = mod_value;
            }
            if !current_mod_detune.is_finite() {
                current_mod_detune = mod_detune;
            }
            if !current_index.is_finite() {
                current_index = index;
            }
            if !current_feedback.is_finite() {
                current_feedback = feedback;
            }
            if !current_drive.is_finite() {
                current_drive = drive;
            }
            if !current_out_level.is_finite() {
                current_out_level = out_level;
            }

            let mut current_amp_attack = amp_attack;
            let mut current_amp_decay = amp_decay;
            let mut current_amp_sustain = amp_sustain;
            let mut current_amp_release = amp_release;
            let mut current_gate_length = default_gate_ms;

            let keybed_triggered = track.fmmi_keybed_trigger.swap(false, Ordering::Relaxed);
            if keybed_triggered {
                let note = track.fmmi_keybed_note.load(Ordering::Relaxed);
                let freq = fmmi_midi_to_freq(note);
                current_car_freq = freq;
                current_car_wave = car_wave;
                current_car_detune = car_detune;
                current_mod_value = mod_value;
                current_mod_wave = mod_wave;
                current_mod_mode = mod_mode;
                current_mod_detune = mod_detune;
                current_index = index;
                current_feedback = feedback;
                current_drive = drive;
                current_out_level = out_level;
                current_amp_attack = amp_attack;
                current_amp_decay = amp_decay;
                current_amp_sustain = amp_sustain;
                current_amp_release = amp_release;
                current_gate_length = default_gate_ms;

                fmmi_trigger_voice(
                    dsp_state,
                    sr,
                    default_gate_ms,
                    current_car_wave,
                    current_car_freq,
                    current_car_detune,
                    current_mod_wave,
                    current_mod_mode,
                    current_mod_value,
                    current_mod_detune,
                    current_index,
                    current_feedback,
                    current_drive,
                    current_out_level,
                    current_amp_attack,
                    current_amp_decay,
                    current_amp_sustain,
                    current_amp_release,
                    current_gate_length,
                );
            }

            let output = track_output;
            let num_channels = output.len().max(1);

            for sample_idx in 0..num_buffer_samples {
                if transport_running {
                    sequencer_phase += 1.0;
                    if sequencer_phase >= samples_per_step {
                        sequencer_phase -= samples_per_step;
                        current_step = (current_step + 1).rem_euclid(loop_steps_i32);
                        track
                            .fmmi_sequencer_step
                            .store(current_step, Ordering::Relaxed);

                        let step_idx = current_step.max(0) as usize;
                        if step_idx < FMMI_STEPS
                            && track.fmmi_sequencer_grid[step_idx].load(Ordering::Relaxed)
                            && (prob >= 1.0 || fmmi_rand_unit(&mut rng_state) <= prob)
                        {
                            let step_note =
                                track.fmmi_step_note[step_idx].load(Ordering::Relaxed);
                            let step_car_wave =
                                track.fmmi_step_car_wave[step_idx].load(Ordering::Relaxed);
                            let step_mod_wave =
                                track.fmmi_step_mod_wave[step_idx].load(Ordering::Relaxed);
                            let step_mod_mode =
                                track.fmmi_step_mod_mode[step_idx].load(Ordering::Relaxed);
                            if step_note >= FMMI_NOTE_BASE && step_note <= FMMI_NOTE_MAX {
                                current_car_freq = fmmi_midi_to_freq(step_note);
                            } else {
                                current_car_freq = car_freq;
                            }
                            let step_car_freq = f32::from_bits(
                                track.fmmi_step_car_freq[step_idx].load(Ordering::Relaxed),
                            );
                            let step_car_detune = f32::from_bits(
                                track.fmmi_step_car_detune[step_idx].load(Ordering::Relaxed),
                            );
                            let step_mod = f32::from_bits(
                                track.fmmi_step_mod_value[step_idx].load(Ordering::Relaxed),
                            );
                            let step_mod_detune = f32::from_bits(
                                track.fmmi_step_mod_detune[step_idx].load(Ordering::Relaxed),
                            );
                            let step_index = f32::from_bits(
                                track.fmmi_step_index[step_idx].load(Ordering::Relaxed),
                            );
                            let step_feedback = f32::from_bits(
                                track.fmmi_step_feedback[step_idx].load(Ordering::Relaxed),
                            );
                            let step_drive = f32::from_bits(
                                track.fmmi_step_drive[step_idx].load(Ordering::Relaxed),
                            );
                            let step_out_level = f32::from_bits(
                                track.fmmi_step_out_level[step_idx].load(Ordering::Relaxed),
                            );
                            let step_amp_attack = f32::from_bits(
                                track.fmmi_step_amp_attack[step_idx].load(Ordering::Relaxed),
                            );
                            let step_amp_decay = f32::from_bits(
                                track.fmmi_step_amp_decay[step_idx].load(Ordering::Relaxed),
                            );
                            let step_amp_sustain = f32::from_bits(
                                track.fmmi_step_amp_sustain[step_idx].load(Ordering::Relaxed),
                            );
                            let step_amp_release = f32::from_bits(
                                track.fmmi_step_amp_release[step_idx].load(Ordering::Relaxed),
                            );
                            let step_gate_length = f32::from_bits(
                                track.fmmi_step_gate_length[step_idx].load(Ordering::Relaxed),
                            );

                            if step_car_freq >= 0.0 {
                                current_car_freq = step_car_freq;
                            }
                            if (0..=3).contains(&step_car_wave) {
                                current_car_wave = step_car_wave as u32;
                            } else {
                                current_car_wave = car_wave;
                            }
                            if (0..=3).contains(&step_mod_wave) {
                                current_mod_wave = step_mod_wave as u32;
                            } else {
                                current_mod_wave = mod_wave;
                            }
                            if (0..=1).contains(&step_mod_mode) {
                                current_mod_mode = step_mod_mode as u32;
                            } else {
                                current_mod_mode = mod_mode;
                            }
                            current_car_detune = if step_car_detune >= 0.0 {
                                step_car_detune
                            } else {
                                car_detune
                            };
                            current_mod_value = if step_mod >= 0.0 { step_mod } else { mod_value };
                            current_mod_detune =
                                if step_mod_detune >= 0.0 { step_mod_detune } else { mod_detune };
                            current_index = if step_index >= 0.0 { step_index } else { index };
                            current_feedback =
                                if step_feedback >= 0.0 { step_feedback } else { feedback };
                            current_drive = if step_drive >= 0.0 { step_drive } else { drive };
                            current_out_level =
                                if step_out_level >= 0.0 { step_out_level } else { out_level };
                            current_amp_attack =
                                if step_amp_attack >= 0.0 { step_amp_attack } else { amp_attack };
                            current_amp_decay =
                                if step_amp_decay >= 0.0 { step_amp_decay } else { amp_decay };
                            current_amp_sustain = if step_amp_sustain >= 0.0 {
                                step_amp_sustain
                            } else {
                                amp_sustain
                            };
                            current_amp_release = if step_amp_release >= 0.0 {
                                step_amp_release
                            } else {
                                amp_release
                            };
                            current_gate_length = if step_gate_length >= 0.0 {
                                step_gate_length
                            } else {
                                default_gate_ms
                            };

                            fmmi_trigger_voice(
                                dsp_state,
                                sr,
                                default_gate_ms,
                                current_car_wave,
                                current_car_freq,
                                current_car_detune,
                                current_mod_wave,
                                current_mod_mode,
                                current_mod_value,
                                current_mod_detune,
                                current_index,
                                current_feedback,
                                current_drive,
                                current_out_level,
                                current_amp_attack,
                                current_amp_decay,
                                current_amp_sustain,
                                current_amp_release,
                                current_gate_length,
                            );
                        }
                    }
                }

                let mut sample_sum = 0.0f32;
                for voice in dsp_state.voices.iter_mut() {
                    if !voice.active {
                        continue;
                    }

                    let gate_on = voice.gate_hold > 0;
                    if voice.gate_hold > 0 {
                        voice.gate_hold = voice.gate_hold.saturating_sub(1);
                    }

                    if voice.gate_stage == 1 {
                        voice.gate_level =
                            (voice.gate_pos as f32 / voice.attack_samples as f32)
                                .clamp(0.0, 1.0);
                        voice.gate_pos = voice.gate_pos.saturating_add(1);
                        if voice.gate_pos >= voice.attack_samples {
                            voice.gate_stage = 2;
                            voice.gate_pos = 0;
                            voice.gate_level = 1.0;
                        }
                    } else if voice.gate_stage == 2 {
                        voice.gate_level = (1.0
                            - (1.0 - voice.sustain_level)
                                * (voice.gate_pos as f32 / voice.decay_samples as f32))
                            .clamp(0.0, 1.0);
                        voice.gate_pos = voice.gate_pos.saturating_add(1);
                        if voice.gate_pos >= voice.decay_samples {
                            voice.gate_stage = 3;
                            voice.gate_pos = 0;
                            voice.gate_level = voice.sustain_level;
                        }
                    } else if voice.gate_stage == 3 {
                        voice.gate_level = voice.sustain_level;
                        if !gate_on {
                            voice.gate_stage = 4;
                            voice.gate_pos = 0;
                        }
                    } else if voice.gate_stage == 4 {
                        voice.gate_level = (voice.gate_level
                            * (1.0 - (1.0 / voice.release_samples as f32)))
                            .max(0.0);
                        voice.gate_pos = voice.gate_pos.saturating_add(1);
                        if voice.gate_pos >= voice.release_samples || voice.gate_level <= 1.0e-4 {
                            voice.gate_stage = 0;
                            voice.gate_pos = 0;
                            voice.gate_level = 0.0;
                        }
                    } else {
                        voice.gate_level = 0.0;
                        if gate_on {
                            voice.gate_stage = 1;
                            voice.gate_pos = 0;
                        }
                    }

                    if voice.gate_stage == 0 && voice.gate_level <= 1.0e-4 {
                        voice.active = false;
                        continue;
                    }

                    let car_detune_ratio = 2.0f32.powf(voice.car_detune / 1200.0);
                    let mod_detune_ratio = 2.0f32.powf(voice.mod_detune / 1200.0);
                    let mut mod_freq = if voice.mod_mode == 1 {
                        (voice.car_freq * voice.mod_value).max(0.1)
                    } else {
                        voice.mod_value.max(0.1)
                    };
                    mod_freq = (mod_freq * mod_detune_ratio).clamp(0.1, 20_000.0);
                    let base_car_freq = (voice.car_freq * car_detune_ratio).clamp(0.1, 20_000.0);

                    voice.mod_phase += mod_freq / sr;
                    if voice.mod_phase >= 1.0 {
                        voice.mod_phase -= 1.0;
                    }
                    let mod_signal = fmmi_waveform_value(voice.mod_wave, voice.mod_phase);

                    let fm = (mod_signal + voice.feedback * voice.last_carrier) * voice.index;
                    let inst_freq = (base_car_freq + fm).clamp(0.1, 20_000.0);

                    voice.car_phase += inst_freq / sr;
                    if voice.car_phase >= 1.0 {
                        voice.car_phase -= 1.0;
                    }
                    let mut sample = fmmi_waveform_value(voice.car_wave, voice.car_phase);
                    voice.last_carrier = sample;

                    sample *= voice.gate_level;
                    if voice.drive > 0.0 {
                        let pre = 1.0 + voice.drive * 20.0;
                        sample = (sample * pre).tanh();
                    }
                    sample *= voice.out_level;
                    sample_sum += sample;
                }

                if num_channels >= 2 {
                    output[0][sample_idx] += sample_sum;
                    output[1][sample_idx] += sample_sum;
                } else {
                    output[0][sample_idx] += sample_sum;
                }
            }

            track
                .fmmi_sequencer_phase
                .store(sequencer_phase.round().max(0.0) as u32, Ordering::Relaxed);
            track
                .fmmi_current_car_freq
                .store(current_car_freq.to_bits(), Ordering::Relaxed);
            track
                .fmmi_current_car_detune
                .store(current_car_detune.to_bits(), Ordering::Relaxed);
            track
                .fmmi_current_mod_value
                .store(current_mod_value.to_bits(), Ordering::Relaxed);
            track
                .fmmi_current_mod_detune
                .store(current_mod_detune.to_bits(), Ordering::Relaxed);
            track
                .fmmi_current_index
                .store(current_index.to_bits(), Ordering::Relaxed);
            track
                .fmmi_current_feedback
                .store(current_feedback.to_bits(), Ordering::Relaxed);
            track
                .fmmi_current_drive
                .store(current_drive.to_bits(), Ordering::Relaxed);
            track
                .fmmi_current_out_level
                .store(current_out_level.to_bits(), Ordering::Relaxed);
            track.fmmi_gate_level.store(0.0f32.to_bits(), Ordering::Relaxed);
            track.fmmi_gate_stage.store(0, Ordering::Relaxed);
            track.fmmi_gate_pos.store(0, Ordering::Relaxed);
            track.fmmi_gate_hold.store(0, Ordering::Relaxed);
            track.fmmi_rng_state.store(rng_state, Ordering::Relaxed);
            return;
        }

        let mut max_active_step = None;
        for i in 0..FMMI_STEPS {
            if track.fmmi_sequencer_grid[i].load(Ordering::Relaxed) {
                max_active_step = Some(i);
            }
        }
        let mut loop_steps = FMMI_PAGE_SIZE;
        if let Some(max_step) = max_active_step {
            loop_steps = ((max_step / FMMI_PAGE_SIZE) + 1) * FMMI_PAGE_SIZE;
        }
        let loop_steps_i32 = loop_steps.max(1) as i32;

        let mut sequencer_phase = if transport_running {
            master_phase
        } else {
            f32::from_bits(track.fmmi_sequencer_phase.load(Ordering::Relaxed))
        };
        let mut current_step = if transport_running {
            (master_step_count as i32).rem_euclid(loop_steps_i32)
        } else {
            let step = track.fmmi_sequencer_step.load(Ordering::Relaxed);
            if step < 0 { step } else { step.rem_euclid(loop_steps_i32) }
        };
        if transport_running {
            track.fmmi_sequencer_step.store(current_step, Ordering::Relaxed);
        }

        let car_wave = track.fmmi_car_wave.load(Ordering::Relaxed);
        let car_freq = f32::from_bits(track.fmmi_car_freq.load(Ordering::Relaxed))
            .clamp(10.0, 20000.0);
        let car_detune = f32::from_bits(track.fmmi_car_detune.load(Ordering::Relaxed))
            .clamp(-1200.0, 1200.0);
        let mod_wave = track.fmmi_mod_wave.load(Ordering::Relaxed);
        let mod_mode = track.fmmi_mod_mode.load(Ordering::Relaxed);
        let mod_value = f32::from_bits(track.fmmi_mod_value.load(Ordering::Relaxed));
        let mod_detune = f32::from_bits(track.fmmi_mod_detune.load(Ordering::Relaxed))
            .clamp(-1200.0, 1200.0);
        let index = f32::from_bits(track.fmmi_index.load(Ordering::Relaxed)).max(0.0);
        let feedback = f32::from_bits(track.fmmi_feedback.load(Ordering::Relaxed)).max(0.0);
        let drive = f32::from_bits(track.fmmi_drive.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let out_level = f32::from_bits(track.fmmi_out_level.load(Ordering::Relaxed))
            .clamp(0.0, 1.5);
        let amp_attack = f32::from_bits(track.fmmi_amp_attack.load(Ordering::Relaxed))
            .clamp(0.0, 127.0);
        let amp_decay = f32::from_bits(track.fmmi_amp_decay.load(Ordering::Relaxed))
            .clamp(0.0, 127.0);
        let amp_sustain = f32::from_bits(track.fmmi_amp_sustain.load(Ordering::Relaxed))
            .clamp(0.0, 127.0);
        let amp_release = f32::from_bits(track.fmmi_amp_release.load(Ordering::Relaxed))
            .clamp(0.0, 127.0);
        let gate_length_override =
            f32::from_bits(track.fmmi_gate_length.load(Ordering::Relaxed));
        let prob = f32::from_bits(track.fmmi_prob.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mut rng_state = track.fmmi_rng_state.load(Ordering::Relaxed);

        let mut current_car_freq =
            f32::from_bits(track.fmmi_current_car_freq.load(Ordering::Relaxed));
        let mut current_car_wave = car_wave;
        let mut current_car_detune =
            f32::from_bits(track.fmmi_current_car_detune.load(Ordering::Relaxed));
        let mut current_mod_value =
            f32::from_bits(track.fmmi_current_mod_value.load(Ordering::Relaxed));
        let mut current_mod_wave = mod_wave;
        let mut current_mod_mode = mod_mode;
        let mut current_mod_detune =
            f32::from_bits(track.fmmi_current_mod_detune.load(Ordering::Relaxed));
        let mut current_index =
            f32::from_bits(track.fmmi_current_index.load(Ordering::Relaxed));
        let mut current_feedback =
            f32::from_bits(track.fmmi_current_feedback.load(Ordering::Relaxed));
        let mut current_drive =
            f32::from_bits(track.fmmi_current_drive.load(Ordering::Relaxed));
        let mut current_out_level =
            f32::from_bits(track.fmmi_current_out_level.load(Ordering::Relaxed));

        if !current_car_freq.is_finite() { current_car_freq = car_freq; }
        if !current_car_detune.is_finite() { current_car_detune = car_detune; }
        if !current_mod_value.is_finite() { current_mod_value = mod_value; }
        if !current_mod_detune.is_finite() { current_mod_detune = mod_detune; }
        if !current_index.is_finite() { current_index = index; }
        if !current_feedback.is_finite() { current_feedback = feedback; }
        if !current_drive.is_finite() { current_drive = drive; }
        if !current_out_level.is_finite() { current_out_level = out_level; }

        let mut car_phase = f32::from_bits(track.fmmi_car_phase.load(Ordering::Relaxed));
        let mut mod_phase = f32::from_bits(track.fmmi_mod_phase.load(Ordering::Relaxed));
        let mut gate_level = f32::from_bits(track.fmmi_gate_level.load(Ordering::Relaxed));
        let mut gate_stage = track.fmmi_gate_stage.load(Ordering::Relaxed);
        let mut gate_pos = track.fmmi_gate_pos.load(Ordering::Relaxed);
        let mut gate_hold = track.fmmi_gate_hold.load(Ordering::Relaxed);
        let mut last_carrier = f32::from_bits(track.fmmi_last_carrier.load(Ordering::Relaxed));

        let mut current_amp_attack = amp_attack;
        let mut current_amp_decay = amp_decay;
        let mut current_amp_sustain = amp_sustain;
        let mut current_amp_release = amp_release;
        let default_gate_ms = if gate_length_override.is_finite() && gate_length_override >= 0.0
        {
            gate_length_override
        } else {
            (samples_per_step / sr).max(0.0) * 1000.0
        };
        let mut current_gate_length = default_gate_ms;
        let mut attack_samples = 1u32;
        let mut decay_samples = 1u32;
        let mut release_samples = 1u32;
        let mut sustain_level = 1.0f32;
        let mut hold_samples = ((default_gate_ms / 1000.0) * sr).round().max(0.0) as u32;
        let compute_env = |attack: f32,
                           decay: f32,
                           sustain: f32,
                           release: f32,
                           gate_len: f32| {
            let attack_time = (attack / 127.0).clamp(0.0, 1.0) * 2.0;
            let decay_time = (decay / 127.0).clamp(0.0, 1.0) * 2.0;
            let release_time = (release / 127.0).clamp(0.0, 1.0) * 2.0;
            let attack_samples = (attack_time * sr).round().max(1.0) as u32;
            let decay_samples = (decay_time * sr).round().max(1.0) as u32;
            let release_samples = (release_time * sr).round().max(1.0) as u32;
            let sustain_level = (sustain / 127.0).clamp(0.0, 1.0);
            let gate_len_ms = if gate_len.is_finite() {
                gate_len.max(0.0)
            } else {
                default_gate_ms
            };
            let hold_samples = ((gate_len_ms / 1000.0) * sr).round().max(0.0) as u32;
            (attack_samples, decay_samples, release_samples, sustain_level, hold_samples)
        };
        {
            let (a, d, r, s, h) = compute_env(
                current_amp_attack,
                current_amp_decay,
                current_amp_sustain,
                current_amp_release,
                current_gate_length,
            );
            attack_samples = a;
            decay_samples = d;
            release_samples = r;
            sustain_level = s;
            hold_samples = h;
        }

        let keybed_triggered = track.fmmi_keybed_trigger.swap(false, Ordering::Relaxed);
        if keybed_triggered {
            let note = track.fmmi_keybed_note.load(Ordering::Relaxed);
            let freq = fmmi_midi_to_freq(note);
            current_car_freq = freq;
            current_car_wave = car_wave;
            current_car_detune = car_detune;
            current_mod_value = mod_value;
            current_mod_wave = mod_wave;
            current_mod_mode = mod_mode;
            current_mod_detune = mod_detune;
            current_index = index;
            current_feedback = feedback;
            current_drive = drive;
            current_out_level = out_level;
            current_amp_attack = amp_attack;
            current_amp_decay = amp_decay;
            current_amp_sustain = amp_sustain;
            current_amp_release = amp_release;
            current_gate_length = default_gate_ms;
            {
                let (a, d, r, s, h) = compute_env(
                    current_amp_attack,
                    current_amp_decay,
                    current_amp_sustain,
                    current_amp_release,
                    current_gate_length,
                );
                attack_samples = a;
                decay_samples = d;
                release_samples = r;
                sustain_level = s;
                hold_samples = h;
            }
            track.fmmi_gate_stage.store(1, Ordering::Relaxed);
            track.fmmi_gate_pos.store(0, Ordering::Relaxed);
            track.fmmi_gate_level.store(0.0f32.to_bits(), Ordering::Relaxed);
            track.fmmi_gate_hold.store(hold_samples, Ordering::Relaxed);
            gate_hold = hold_samples;
        }

        if gate_stage == 0 {
            current_car_freq = car_freq;
            current_car_wave = car_wave;
            current_car_detune = car_detune;
            current_mod_value = mod_value;
            current_mod_wave = mod_wave;
            current_mod_mode = mod_mode;
            current_mod_detune = mod_detune;
            current_index = index;
            current_feedback = feedback;
            current_drive = drive;
            current_out_level = out_level;
        }

        let output = track_output;
        let num_channels = output.len().max(1);

        for sample_idx in 0..num_buffer_samples {
            if transport_running {
                sequencer_phase += 1.0;
                if sequencer_phase >= samples_per_step {
                    sequencer_phase -= samples_per_step;
                    current_step = (current_step + 1).rem_euclid(loop_steps_i32);
                    track
                        .fmmi_sequencer_step
                        .store(current_step, Ordering::Relaxed);

                    let step_idx = current_step.max(0) as usize;
                    if step_idx < FMMI_STEPS
                        && track.fmmi_sequencer_grid[step_idx].load(Ordering::Relaxed)
                        && (prob >= 1.0 || fmmi_rand_unit(&mut rng_state) <= prob)
                    {
                        let step_note = track.fmmi_step_note[step_idx].load(Ordering::Relaxed);
                        let step_car_wave =
                            track.fmmi_step_car_wave[step_idx].load(Ordering::Relaxed);
                        let step_mod_wave =
                            track.fmmi_step_mod_wave[step_idx].load(Ordering::Relaxed);
                        let step_mod_mode =
                            track.fmmi_step_mod_mode[step_idx].load(Ordering::Relaxed);
                        if step_note >= FMMI_NOTE_BASE && step_note <= FMMI_NOTE_MAX {
                            current_car_freq = fmmi_midi_to_freq(step_note);
                        } else {
                            current_car_freq = car_freq;
                        }
                        let step_car_freq = f32::from_bits(
                            track.fmmi_step_car_freq[step_idx].load(Ordering::Relaxed),
                        );
                        let step_car_detune = f32::from_bits(
                            track.fmmi_step_car_detune[step_idx].load(Ordering::Relaxed),
                        );
                        let step_mod = f32::from_bits(
                            track.fmmi_step_mod_value[step_idx].load(Ordering::Relaxed),
                        );
                        let step_mod_detune = f32::from_bits(
                            track.fmmi_step_mod_detune[step_idx].load(Ordering::Relaxed),
                        );
                        let step_index = f32::from_bits(
                            track.fmmi_step_index[step_idx].load(Ordering::Relaxed),
                        );
                        let step_feedback = f32::from_bits(
                            track.fmmi_step_feedback[step_idx].load(Ordering::Relaxed),
                        );
                        let step_drive = f32::from_bits(
                            track.fmmi_step_drive[step_idx].load(Ordering::Relaxed),
                        );
                        let step_out_level = f32::from_bits(
                            track.fmmi_step_out_level[step_idx].load(Ordering::Relaxed),
                        );
                        let step_amp_attack = f32::from_bits(
                            track.fmmi_step_amp_attack[step_idx].load(Ordering::Relaxed),
                        );
                        let step_amp_decay = f32::from_bits(
                            track.fmmi_step_amp_decay[step_idx].load(Ordering::Relaxed),
                        );
                        let step_amp_sustain = f32::from_bits(
                            track.fmmi_step_amp_sustain[step_idx].load(Ordering::Relaxed),
                        );
                        let step_amp_release = f32::from_bits(
                            track.fmmi_step_amp_release[step_idx].load(Ordering::Relaxed),
                        );
                        let step_gate_length = f32::from_bits(
                            track.fmmi_step_gate_length[step_idx].load(Ordering::Relaxed),
                        );

                        if step_car_freq >= 0.0 {
                            current_car_freq = step_car_freq;
                        }
                        if (0..=3).contains(&step_car_wave) {
                            current_car_wave = step_car_wave as u32;
                        } else {
                            current_car_wave = car_wave;
                        }
                        if (0..=3).contains(&step_mod_wave) {
                            current_mod_wave = step_mod_wave as u32;
                        } else {
                            current_mod_wave = mod_wave;
                        }
                        if (0..=1).contains(&step_mod_mode) {
                            current_mod_mode = step_mod_mode as u32;
                        } else {
                            current_mod_mode = mod_mode;
                        }
                        current_car_detune =
                            if step_car_detune >= 0.0 { step_car_detune } else { car_detune };

                        current_mod_value = if step_mod >= 0.0 { step_mod } else { mod_value };
                        current_mod_detune =
                            if step_mod_detune >= 0.0 { step_mod_detune } else { mod_detune };
                        current_index = if step_index >= 0.0 { step_index } else { index };
                        current_feedback =
                            if step_feedback >= 0.0 { step_feedback } else { feedback };
                        current_drive = if step_drive >= 0.0 { step_drive } else { drive };
                        current_out_level =
                            if step_out_level >= 0.0 { step_out_level } else { out_level };
                        current_amp_attack =
                            if step_amp_attack >= 0.0 { step_amp_attack } else { amp_attack };
                        current_amp_decay =
                            if step_amp_decay >= 0.0 { step_amp_decay } else { amp_decay };
                        current_amp_sustain =
                            if step_amp_sustain >= 0.0 { step_amp_sustain } else { amp_sustain };
                        current_amp_release =
                            if step_amp_release >= 0.0 { step_amp_release } else { amp_release };
                        current_gate_length = if step_gate_length >= 0.0 {
                            step_gate_length
                        } else {
                            default_gate_ms
                        };

                        {
                            let (a, d, r, s, h) = compute_env(
                                current_amp_attack,
                                current_amp_decay,
                                current_amp_sustain,
                                current_amp_release,
                                current_gate_length,
                            );
                            attack_samples = a;
                            decay_samples = d;
                            release_samples = r;
                            sustain_level = s;
                            hold_samples = h;
                        }

                        gate_stage = 1;
                        gate_pos = 0;
                        gate_level = 0.0;
                        gate_hold = hold_samples;
                    }
                }
            }

            let gate_on = gate_hold > 0;
            if gate_hold > 0 {
                gate_hold = gate_hold.saturating_sub(1);
            }

            if gate_stage == 1 {
                gate_level = (gate_pos as f32 / attack_samples as f32).clamp(0.0, 1.0);
                gate_pos = gate_pos.saturating_add(1);
                if gate_pos >= attack_samples {
                    gate_stage = 2;
                    gate_pos = 0;
                    gate_level = 1.0;
                }
            } else if gate_stage == 2 {
                gate_level = (1.0 - (1.0 - sustain_level) * (gate_pos as f32 / decay_samples as f32))
                    .clamp(0.0, 1.0);
                gate_pos = gate_pos.saturating_add(1);
                if gate_pos >= decay_samples {
                    gate_stage = 3;
                    gate_pos = 0;
                    gate_level = sustain_level;
                }
            } else if gate_stage == 3 {
                gate_level = sustain_level;
                if !gate_on {
                    gate_stage = 4;
                    gate_pos = 0;
                }
            } else if gate_stage == 4 {
                gate_level =
                    (gate_level * (1.0 - (1.0 / release_samples as f32))).max(0.0);
                gate_pos = gate_pos.saturating_add(1);
                if gate_pos >= release_samples || gate_level <= 1.0e-4 {
                    gate_stage = 0;
                    gate_pos = 0;
                    gate_level = 0.0;
                }
            } else {
                gate_level = 0.0;
                if gate_on {
                    gate_stage = 1;
                    gate_pos = 0;
                }
            }

            let car_detune_ratio = 2.0f32.powf(current_car_detune / 1200.0);
            let mod_detune_ratio = 2.0f32.powf(current_mod_detune / 1200.0);
            let mut mod_freq = if current_mod_mode == 1 {
                (current_car_freq * current_mod_value).max(0.1)
            } else {
                current_mod_value.max(0.1)
            };
            mod_freq = (mod_freq * mod_detune_ratio).clamp(0.1, 20_000.0);
            let base_car_freq = (current_car_freq * car_detune_ratio).clamp(0.1, 20_000.0);

            mod_phase += mod_freq / sr;
            if mod_phase >= 1.0 { mod_phase -= 1.0; }
            let mod_signal = fmmi_waveform_value(current_mod_wave, mod_phase);

            let fm = (mod_signal + current_feedback * last_carrier) * current_index;
            let inst_freq = (base_car_freq + fm).clamp(0.1, 20_000.0);

            car_phase += inst_freq / sr;
            if car_phase >= 1.0 { car_phase -= 1.0; }
            let mut sample = fmmi_waveform_value(current_car_wave, car_phase);
            last_carrier = sample;

            sample *= gate_level;
            if current_drive > 0.0 {
                let pre = 1.0 + current_drive * 20.0;
                sample = (sample * pre).tanh();
            }
            sample *= current_out_level;

            if num_channels >= 2 {
                output[0][sample_idx] += sample;
                output[1][sample_idx] += sample;
            } else {
                output[0][sample_idx] += sample;
            }
        }

        track
            .fmmi_sequencer_phase
            .store(sequencer_phase.round().max(0.0) as u32, Ordering::Relaxed);
        track
            .fmmi_current_car_freq
            .store(current_car_freq.to_bits(), Ordering::Relaxed);
        track
            .fmmi_current_car_detune
            .store(current_car_detune.to_bits(), Ordering::Relaxed);
        track
            .fmmi_current_mod_value
            .store(current_mod_value.to_bits(), Ordering::Relaxed);
        track
            .fmmi_current_mod_detune
            .store(current_mod_detune.to_bits(), Ordering::Relaxed);
        track
            .fmmi_current_index
            .store(current_index.to_bits(), Ordering::Relaxed);
        track
            .fmmi_current_feedback
            .store(current_feedback.to_bits(), Ordering::Relaxed);
        track
            .fmmi_current_drive
            .store(current_drive.to_bits(), Ordering::Relaxed);
        track
            .fmmi_current_out_level
            .store(current_out_level.to_bits(), Ordering::Relaxed);
        track.fmmi_car_phase.store(car_phase.to_bits(), Ordering::Relaxed);
        track.fmmi_mod_phase.store(mod_phase.to_bits(), Ordering::Relaxed);
        track.fmmi_gate_level.store(gate_level.to_bits(), Ordering::Relaxed);
        track.fmmi_gate_stage.store(gate_stage, Ordering::Relaxed);
        track.fmmi_gate_pos.store(gate_pos, Ordering::Relaxed);
        track.fmmi_gate_hold.store(gate_hold, Ordering::Relaxed);
        track.fmmi_last_carrier.store(last_carrier.to_bits(), Ordering::Relaxed);
        track.fmmi_rng_state.store(rng_state, Ordering::Relaxed);
    }

    fn process_monomi(
        track: &Track,
        track_output: &mut [Vec<f32>],
        num_buffer_samples: usize,
        global_tempo: &AtomicU32,
        _master_step: i32,
        master_phase: f32,
        master_step_count: i64,
        samples_per_step: f32,
        sample_rate: f32,
        transport_running: bool,
        dsp_state: &mut MonomiDspState,
    ) {
        let sr = sample_rate.max(1.0);
        if (dsp_state.sample_rate - sr).abs() > f32::EPSILON {
            dsp_state.sample_rate = sr;
            let sr_f64 = sr as f64;
            for unit in dsp_state.filter_lp.iter_mut() {
                unit.set_sample_rate(sr_f64);
            }
            for unit in dsp_state.filter_hp.iter_mut() {
                unit.set_sample_rate(sr_f64);
            }
            for unit in dsp_state.filter_moog.iter_mut() {
                unit.set_sample_rate(sr_f64);
            }
        }

        let tempo_bits = global_tempo.load(Ordering::Relaxed);
        let tempo_raw = f32::from_bits(tempo_bits);
        let tempo = if tempo_raw.is_finite() {
            tempo_raw.clamp(20.0, 240.0)
        } else {
            120.0
        };
        let step_sec = (samples_per_step / sr).max(0.0001);

        let mut max_step: Option<usize> = None;
        for i in 0..MONOMI_STEPS {
            if track.monomi_sequencer_grid[i].load(Ordering::Relaxed) {
                let gate_steps = f32::from_bits(track.monomi_step_gate[i].load(Ordering::Relaxed));
                let gate_steps = if gate_steps >= 0.0 { gate_steps } else { 1.0 };
                let gate_steps = gate_steps.clamp(1.0, 128.0);
                let mut next_active = None;
                for j in (i + 1)..MONOMI_STEPS {
                    if track.monomi_sequencer_grid[j].load(Ordering::Relaxed) {
                        next_active = Some(j);
                        break;
                    }
                }
                let tail = if let Some(next_idx) = next_active {
                    gate_steps.min((next_idx - i) as f32)
                } else {
                    gate_steps
                };
                let end_idx = i + tail.max(1.0) as usize - 1;
                max_step = Some(max_step.map(|m| m.max(end_idx)).unwrap_or(end_idx));
            }
        }
        let loop_steps = if let Some(max_idx) = max_step {
            ((max_idx / MONOMI_PAGE_SIZE) + 1) * MONOMI_PAGE_SIZE
        } else {
            MONOMI_PAGE_SIZE
        };
        let loop_steps_i32 = loop_steps.max(1) as i32;

        let mut sequencer_phase = if transport_running {
            master_phase
        } else {
            f32::from_bits(track.monomi_sequencer_phase.load(Ordering::Relaxed))
        };
        let mut current_step = if transport_running {
            (master_step_count as i32).rem_euclid(loop_steps_i32)
        } else {
            let step = track.monomi_sequencer_step.load(Ordering::Relaxed);
            if step < 0 { step } else { step.rem_euclid(loop_steps_i32) }
        };
        if transport_running {
            track.monomi_sequencer_step.store(current_step, Ordering::Relaxed);
        }

        let cutoff = f32::from_bits(track.monomi_cutoff.load(Ordering::Relaxed))
            .clamp(20.0, 12_000.0);
        let filter_mode = track.monomi_filter_mode.load(Ordering::Relaxed);
        let resonance_max = if filter_mode == 0 { 1.0 } else { 8.0 };
        let resonance = f32::from_bits(track.monomi_resonance.load(Ordering::Relaxed))
            .clamp(0.0, resonance_max);
        let filter_morph = f32::from_bits(track.monomi_filter_morph.load(Ordering::Relaxed))
            .clamp(0.0, 1.0);
        let volume = f32::from_bits(track.monomi_volume.load(Ordering::Relaxed))
            .clamp(0.0, 1.0);

        let amp_attack = f32::from_bits(track.monomi_amp_attack.load(Ordering::Relaxed));
        let amp_decay = f32::from_bits(track.monomi_amp_decay.load(Ordering::Relaxed));
        let amp_sustain = f32::from_bits(track.monomi_amp_sustain.load(Ordering::Relaxed));
        let amp_release = f32::from_bits(track.monomi_amp_release.load(Ordering::Relaxed));
        let filter_attack = f32::from_bits(track.monomi_filter_attack.load(Ordering::Relaxed));
        let filter_decay = f32::from_bits(track.monomi_filter_decay.load(Ordering::Relaxed));
        let filter_sustain = f32::from_bits(track.monomi_filter_sustain.load(Ordering::Relaxed));
        let filter_release = f32::from_bits(track.monomi_filter_release.load(Ordering::Relaxed));
        let filter_intensity =
            f32::from_bits(track.monomi_filter_intensity.load(Ordering::Relaxed));
        let filter_polarity =
            f32::from_bits(track.monomi_filter_polarity.load(Ordering::Relaxed));
        let filter_saturation =
            f32::from_bits(track.monomi_filter_saturation.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let filter_sat_env =
            f32::from_bits(track.monomi_filter_sat_env.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let filter_sat_pre = track.monomi_filter_sat_pre.load(Ordering::Relaxed);
        let glide = f32::from_bits(track.monomi_glide.load(Ordering::Relaxed))
            .clamp(0.0, 1000.0);
        let prob = f32::from_bits(track.monomi_prob.load(Ordering::Relaxed))
            .clamp(0.0, 1.0);
        let scale_index = track.monomi_scale_index.load(Ordering::Relaxed) as usize;

        let mut rng_state = track.monomi_rng_state.load(Ordering::Relaxed);
        let keybed_triggered = track.monomi_keybed_trigger.swap(false, Ordering::Relaxed);

        let mut trigger_note = |dsp_state: &mut MonomiDspState,
                                note: i32,
                                step_cutoff: f32,
                                step_resonance: f32,
                                step_morph: f32,
                                step_filter_intensity: f32,
                                step_filter_polarity: f32,
                                step_glide: f32,
                                step_gate: f32,
                                step_amp_attack: f32,
                                step_amp_decay: f32,
                                step_amp_sustain: f32,
                                step_amp_release: f32,
                                step_filter_attack: f32,
                                step_filter_decay: f32,
                                step_filter_sustain: f32,
                                step_filter_release: f32,
                                step_osc_mix: [f32; 3],
                                step_osc_detune: [f32; 3],
                                step_osc_pwm: [f32; 3]| {
            let freq = monomi_midi_to_freq(note);
            dsp_state.target_freq = freq;
            if !dsp_state.current_freq.is_finite() {
                dsp_state.current_freq = freq;
            }
            dsp_state.current_cutoff = step_cutoff;
            dsp_state.current_resonance = step_resonance.clamp(0.0, resonance_max);
            dsp_state.current_morph = step_morph;
            dsp_state.current_filter_intensity = step_filter_intensity;
            dsp_state.current_filter_polarity = step_filter_polarity;
            dsp_state.current_glide = step_glide;
            dsp_state.current_gate_steps = step_gate;
            dsp_state.current_amp_attack = step_amp_attack;
            dsp_state.current_amp_decay = step_amp_decay;
            dsp_state.current_amp_sustain = step_amp_sustain;
            dsp_state.current_amp_release = step_amp_release;
            dsp_state.current_filter_attack = step_filter_attack;
            dsp_state.current_filter_decay = step_filter_decay;
            dsp_state.current_filter_sustain = step_filter_sustain;
            dsp_state.current_filter_release = step_filter_release;
            dsp_state.current_osc_mix = step_osc_mix;
            dsp_state.current_osc_detune = step_osc_detune;
            dsp_state.current_osc_pwm = step_osc_pwm;

            let (a, d, r, s, h) = monomi_env_samples(
                sr,
                step_sec,
                step_amp_attack,
                step_amp_decay,
                step_amp_sustain,
                step_amp_release,
                step_gate,
            );
            dsp_state.amp_attack = a;
            dsp_state.amp_decay = d;
            dsp_state.amp_release = r;
            dsp_state.amp_sustain = s;
            dsp_state.amp_hold = h;
            dsp_state.amp_stage = 1;
            dsp_state.amp_pos = 0;
            dsp_state.amp_level = 0.0;

            let (fa, fd, fr, fs, fh) = monomi_env_samples(
                sr,
                step_sec,
                step_filter_attack,
                step_filter_decay,
                step_filter_sustain,
                step_filter_release,
                step_gate,
            );
            dsp_state.filter_attack = fa;
            dsp_state.filter_decay = fd;
            dsp_state.filter_release = fr;
            dsp_state.filter_sustain = fs;
            dsp_state.filter_hold = fh;
            dsp_state.filter_stage = 1;
            dsp_state.filter_pos = 0;
            dsp_state.filter_level = 0.0;
        };

        if keybed_triggered {
            let note = track.monomi_keybed_note.load(Ordering::Relaxed);
            let step_gate = 1.0;
            trigger_note(
                dsp_state,
                note,
                cutoff,
                resonance,
                filter_morph,
                filter_intensity,
                filter_polarity,
                glide,
                step_gate,
                amp_attack,
                amp_decay,
                amp_sustain,
                amp_release,
                filter_attack,
                filter_decay,
                filter_sustain,
                filter_release,
                [
                    f32::from_bits(track.monomi_osc_mix[0].load(Ordering::Relaxed)),
                    f32::from_bits(track.monomi_osc_mix[1].load(Ordering::Relaxed)),
                    f32::from_bits(track.monomi_osc_mix[2].load(Ordering::Relaxed)),
                ],
                [
                    f32::from_bits(track.monomi_osc_detune[0].load(Ordering::Relaxed)),
                    f32::from_bits(track.monomi_osc_detune[1].load(Ordering::Relaxed)),
                    f32::from_bits(track.monomi_osc_detune[2].load(Ordering::Relaxed)),
                ],
                [
                    f32::from_bits(track.monomi_osc_pwm[0].load(Ordering::Relaxed)),
                    f32::from_bits(track.monomi_osc_pwm[1].load(Ordering::Relaxed)),
                    f32::from_bits(track.monomi_osc_pwm[2].load(Ordering::Relaxed)),
                ],
            );
        }

        let output = track_output;
        let num_channels = output.len().max(1);

        let amp_smooth_coeff = (-1.0 / (0.003 * sr)).exp();
        // Hidden decay for saturation env follower to emphasize transients.
        let sat_env_decay_coeff = (-1.0 / (0.020 * sr)).exp();
        for sample_idx in 0..num_buffer_samples {
            if transport_running {
                sequencer_phase += 1.0;
                if sequencer_phase >= samples_per_step {
                    sequencer_phase -= samples_per_step;
                    current_step = (current_step + 1).rem_euclid(loop_steps_i32);
                    track
                        .monomi_sequencer_step
                        .store(current_step, Ordering::Relaxed);

                    let step_idx = current_step.max(0) as usize;
                    if step_idx < MONOMI_STEPS
                        && track.monomi_sequencer_grid[step_idx].load(Ordering::Relaxed)
                        && (prob >= 1.0 || fmmi_rand_unit(&mut rng_state) <= prob)
                    {
                        let step_note = track.monomi_step_note[step_idx].load(Ordering::Relaxed);
                        let note = if (MONOMI_NOTE_BASE..=MONOMI_NOTE_MAX).contains(&step_note) {
                            step_note
                        } else {
                            monomi_random_note_in_scale(&mut rng_state, scale_index)
                        };
                        let step_cutoff = {
                            let v = f32::from_bits(
                                track.monomi_step_cutoff[step_idx].load(Ordering::Relaxed),
                            );
                            if v >= 0.0 { v } else { cutoff }
                        };
                        let step_resonance = {
                            let v = f32::from_bits(
                                track.monomi_step_resonance[step_idx].load(Ordering::Relaxed),
                            );
                            if v >= 0.0 {
                                v.clamp(0.0, resonance_max)
                            } else {
                                resonance
                            }
                        };
                        let step_morph = {
                            let v = f32::from_bits(
                                track.monomi_step_filter_morph[step_idx].load(Ordering::Relaxed),
                            );
                            if v >= 0.0 { v } else { filter_morph }
                        };
                        let step_glide = {
                            let v = f32::from_bits(
                                track.monomi_step_glide[step_idx].load(Ordering::Relaxed),
                            );
                            if v >= 0.0 { v } else { glide }
                        };
                        let step_gate = {
                            let v = f32::from_bits(
                                track.monomi_step_gate[step_idx].load(Ordering::Relaxed),
                            );
                            if v >= 0.0 { v } else { 1.0 }
                        };
                        let step_amp_attack = {
                            let v = f32::from_bits(
                                track.monomi_step_env_attack[step_idx].load(Ordering::Relaxed),
                            );
                            if v >= 0.0 { v } else { amp_attack }
                        };
                        let step_amp_decay = {
                            let v = f32::from_bits(
                                track.monomi_step_env_decay[step_idx].load(Ordering::Relaxed),
                            );
                            if v >= 0.0 { v } else { amp_decay }
                        };
                        let step_amp_sustain = {
                            let v = f32::from_bits(
                                track.monomi_step_env_sustain[step_idx].load(Ordering::Relaxed),
                            );
                            if v >= 0.0 { v } else { amp_sustain }
                        };
                        let step_amp_release = {
                            let v = f32::from_bits(
                                track.monomi_step_env_release[step_idx].load(Ordering::Relaxed),
                            );
                            if v >= 0.0 { v } else { amp_release }
                        };
                        let step_filter_attack = filter_attack;
                        let step_filter_decay = filter_decay;
                        let step_filter_sustain = filter_sustain;
                        let step_filter_release = filter_release;
                        let step_filter_intensity = filter_intensity;
                        let step_filter_polarity = filter_polarity;

                        let step_osc_mix = std::array::from_fn(|osc| {
                            let v = f32::from_bits(
                                track.monomi_step_osc_mix[osc][step_idx].load(Ordering::Relaxed),
                            );
                            if v >= 0.0 {
                                v
                            } else {
                                f32::from_bits(
                                    track.monomi_osc_mix[osc].load(Ordering::Relaxed),
                                )
                            }
                        });
                        let step_osc_detune = std::array::from_fn(|osc| {
                            let v = f32::from_bits(
                                track.monomi_step_osc_detune[osc][step_idx].load(Ordering::Relaxed),
                            );
                            if v >= 0.0 {
                                v
                            } else {
                                f32::from_bits(
                                    track.monomi_osc_detune[osc].load(Ordering::Relaxed),
                                )
                            }
                        });
                        let step_osc_pwm = std::array::from_fn(|osc| {
                            let v = f32::from_bits(
                                track.monomi_step_osc_pwm[osc][step_idx].load(Ordering::Relaxed),
                            );
                            if v >= 0.0 {
                                v
                            } else {
                                f32::from_bits(
                                    track.monomi_osc_pwm[osc].load(Ordering::Relaxed),
                                )
                            }
                        });

                        trigger_note(
                            dsp_state,
                            note,
                            step_cutoff,
                            step_resonance,
                            step_morph,
                            step_filter_intensity,
                            step_filter_polarity,
                            step_glide,
                            step_gate,
                            step_amp_attack,
                            step_amp_decay,
                            step_amp_sustain,
                            step_amp_release,
                            step_filter_attack,
                            step_filter_decay,
                            step_filter_sustain,
                            step_filter_release,
                            step_osc_mix,
                            step_osc_detune,
                            step_osc_pwm,
                        );
                    }
                }
            }

            let mut lfo_cutoff_mod = 0.0f32;
            let mut lfo_res_mod = 0.0f32;
            let mut lfo_morph_mod = 0.0f32;
            let mut lfo_filter_int_mod = 0.0f32;
            let mut lfo_filter_pol_mod = 0.0f32;
            let mut lfo_glide_mod = 0.0f32;
            let mut lfo_detune_mod = [0.0f32; 3];
            let mut lfo_mix_mod = [0.0f32; 3];
            let mut lfo_pwm_mod = [0.0f32; 3];

            for lfo_idx in 0..3 {
                let wave = track.monomi_lfo_shape[lfo_idx].load(Ordering::Relaxed);
                let target = track.monomi_lfo_target[lfo_idx].load(Ordering::Relaxed) as usize;
                let amount =
                    f32::from_bits(track.monomi_lfo_amount[lfo_idx].load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                let rate =
                    f32::from_bits(track.monomi_lfo_rate[lfo_idx].load(Ordering::Relaxed))
                        .max(0.01);
                let sync = track.monomi_lfo_sync[lfo_idx].load(Ordering::Relaxed);
                let steps = track.monomi_lfo_steps[lfo_idx].load(Ordering::Relaxed).max(1);
                let freq = if sync {
                    (tempo / (15.0 * steps as f32)).max(0.01)
                } else {
                    rate
                };
                dsp_state.lfo_phase[lfo_idx] += freq / sr;
                if dsp_state.lfo_phase[lfo_idx] >= 1.0 {
                    dsp_state.lfo_phase[lfo_idx] -= 1.0;
                    if wave == 4 {
                        dsp_state.lfo_sample_hold[lfo_idx] =
                            fmmi_rand_unit(&mut rng_state) * 2.0 - 1.0;
                    }
                }
                let lfo_val = lfo_waveform_value(
                    wave,
                    dsp_state.lfo_phase[lfo_idx],
                    dsp_state.lfo_sample_hold[lfo_idx],
                );
                let scaled = lfo_val * amount;
                match target {
                    0 => {
                        let base = dsp_state.current_cutoff.max(20.0);
                        let modded = (base * (1.0 + scaled)).clamp(50.0, 12000.0);
                        lfo_cutoff_mod = modded - base;
                    }
                    1 => {
                        let base = dsp_state.current_resonance;
                        let modded = (base + scaled * 2.0).clamp(0.0, 1.0);
                        lfo_res_mod = modded - base;
                    }
                    2 => {
                        let base = dsp_state.current_morph;
                        let modded = (base + scaled).clamp(0.0, 1.0);
                        lfo_morph_mod = modded - base;
                    }
                    3 => {
                        let base = dsp_state.current_filter_intensity;
                        let modded = (base + scaled * 2.0).clamp(0.0, 8.0);
                        lfo_filter_int_mod = modded - base;
                    }
                    4 => {
                        let base = dsp_state.current_filter_polarity;
                        let modded = (base + scaled).clamp(-1.0, 1.0);
                        lfo_filter_pol_mod = modded - base;
                    }
                    5 => {
                        let base = dsp_state.current_glide;
                        let modded = (base + scaled * 500.0).clamp(0.0, 1000.0);
                        lfo_glide_mod = modded - base;
                    }
                    6 => lfo_detune_mod[0] = scaled * 100.0,
                    7 => lfo_detune_mod[1] = scaled * 100.0,
                    8 => lfo_detune_mod[2] = scaled * 100.0,
                    9 => lfo_mix_mod[0] = scaled,
                    10 => lfo_mix_mod[1] = scaled,
                    11 => lfo_mix_mod[2] = scaled,
                    12 => lfo_pwm_mod[0] = scaled * 0.45,
                    13 => lfo_pwm_mod[1] = scaled * 0.45,
                    14 => lfo_pwm_mod[2] = scaled * 0.45,
                    _ => {}
                }
            }

            let glide_ms = (dsp_state.current_glide + lfo_glide_mod).clamp(0.0, 1000.0);
            let glide_coeff = if glide_ms <= 0.0 {
                1.0
            } else {
                1.0 - (-1.0 / (glide_ms * 0.001 * sr)).exp()
            };
            dsp_state.current_freq += (dsp_state.target_freq - dsp_state.current_freq) * glide_coeff;

            let mut update_env = |stage: &mut u32,
                                  pos: &mut u32,
                                  hold: &mut u32,
                                  level: &mut f32,
                                  attack_samples: u32,
                                  decay_samples: u32,
                                  sustain_level: f32,
                                  release_samples: u32| {
                if *stage == 0 {
                    *level = 0.0;
                    return;
                }
                if *hold > 0 {
                    *hold = hold.saturating_sub(1);
                }
                if *hold == 0 && *stage < 4 {
                    *stage = 4;
                    *pos = 0;
                }
                match *stage {
                    1 => {
                        *level = (*pos as f32 / attack_samples as f32).clamp(0.0, 1.0);
                        *pos = pos.saturating_add(1);
                        if *pos >= attack_samples {
                            *stage = 2;
                            *pos = 0;
                            *level = 1.0;
                        }
                    }
                    2 => {
                        *level = (1.0
                            - (1.0 - sustain_level) * (*pos as f32 / decay_samples as f32))
                            .clamp(0.0, 1.0);
                        *pos = pos.saturating_add(1);
                        if *pos >= decay_samples {
                            *stage = 3;
                            *pos = 0;
                            *level = sustain_level;
                        }
                    }
                    3 => {
                        *level = sustain_level;
                    }
                    4 => {
                        *level = (*level * (1.0 - (1.0 / release_samples as f32))).max(0.0);
                        *pos = pos.saturating_add(1);
                        if *pos >= release_samples || *level <= 1.0e-4 {
                            *stage = 0;
                            *pos = 0;
                            *level = 0.0;
                        }
                    }
                    _ => {
                        *level = 0.0;
                        *stage = 0;
                        *pos = 0;
                    }
                }
            };

            update_env(
                &mut dsp_state.amp_stage,
                &mut dsp_state.amp_pos,
                &mut dsp_state.amp_hold,
                &mut dsp_state.amp_level,
                dsp_state.amp_attack,
                dsp_state.amp_decay,
                dsp_state.amp_sustain,
                dsp_state.amp_release,
            );
            update_env(
                &mut dsp_state.filter_stage,
                &mut dsp_state.filter_pos,
                &mut dsp_state.filter_hold,
                &mut dsp_state.filter_level,
                dsp_state.filter_attack,
                dsp_state.filter_decay,
                dsp_state.filter_sustain,
                dsp_state.filter_release,
            );

            let mut sample = 0.0f32;
            if dsp_state.amp_stage != 0 {
                let base_freq = dsp_state.current_freq.max(1.0);
                for osc_idx in 0..3 {
                    let octave = track.monomi_osc_octave[osc_idx].load(Ordering::Relaxed);
                    let octave_mul = match octave {
                        0 => 1.0,
                        1 => 0.5,
                        2 => 0.25,
                        _ => 1.0,
                    };
                    let detune = (dsp_state.current_osc_detune[osc_idx] + lfo_detune_mod[osc_idx])
                        .clamp(-1200.0, 1200.0);
                    let detune_ratio = 2.0f32.powf(detune / 1200.0);
                    let freq = (base_freq * octave_mul * detune_ratio).clamp(0.1, 20_000.0);
                    dsp_state.osc_phase[osc_idx] += freq / sr;
                    if dsp_state.osc_phase[osc_idx] >= 1.0 {
                        dsp_state.osc_phase[osc_idx] -= 1.0;
                    }
                    let wave = track.monomi_osc_wave[osc_idx].load(Ordering::Relaxed);
                    let pwm = (dsp_state.current_osc_pwm[osc_idx] + lfo_pwm_mod[osc_idx])
                        .clamp(0.05, 0.95);
                    let osc = monomi_waveform_value(wave, dsp_state.osc_phase[osc_idx], pwm);
                    let mix = (dsp_state.current_osc_mix[osc_idx] + lfo_mix_mod[osc_idx])
                        .clamp(0.0, 1.0);
                    sample += osc * mix;
                }
            }

            let mix_sum = dsp_state.current_osc_mix.iter().sum::<f32>().max(1.0);
            sample /= mix_sum;

            let cutoff_base = (dsp_state.current_cutoff + lfo_cutoff_mod).clamp(20.0, 20_000.0);
            let res_max = if filter_mode == 0 { 1.0 } else { 8.0 };
            let res = (dsp_state.current_resonance + lfo_res_mod).clamp(0.0, res_max);
            let morph = (dsp_state.current_morph + lfo_morph_mod).clamp(0.0, 1.0);
            let env_octaves = (dsp_state.current_filter_intensity + lfo_filter_int_mod)
                * (dsp_state.current_filter_polarity + lfo_filter_pol_mod);
            let env_octaves = env_octaves.clamp(-8.0, 8.0);
            let cutoff = (cutoff_base * 2.0f32.powf(env_octaves * dsp_state.filter_level))
                .clamp(20.0, 20_000.0);

            let mut channel_samples = [sample; 2];
            if dsp_state.amp_stage != 0 {
                for ch in 0..num_channels.min(2) {
                    let mut lp_out = [0.0f32];
                    let mut hp_out = [0.0f32];
                    let q = if filter_mode == 0 {
                        res.clamp(0.1, 1.0)
                    } else {
                        res.clamp(0.1, 8.0)
                    };
                    let env_input = channel_samples[ch].abs();
                    let env_decay = dsp_state.filter_sat_env[ch] * sat_env_decay_coeff;
                    dsp_state.filter_sat_env[ch] = env_input.max(env_decay);
                    let sat_amt =
                        (filter_saturation + filter_sat_env * dsp_state.filter_sat_env[ch])
                            .clamp(0.0, 1.0);
                    let sat_drive = 1.0 + sat_amt * 8.0;
                    let sat_norm = sat_drive.tanh().max(1.0e-6);
                    let sat = |x: f32| (x * sat_drive).tanh() / sat_norm;
                    let filter_input = if filter_sat_pre {
                        sat(channel_samples[ch])
                    } else {
                        channel_samples[ch]
                    };
                    match filter_mode {
                        0 => {
                            dsp_state.filter_moog[ch].tick(&[filter_input, cutoff, q], &mut lp_out);
                            dsp_state.filter_hp[ch].tick(&[filter_input, cutoff, q], &mut hp_out);
                            channel_samples[ch] = lp_out[0] * (1.0 - morph) + hp_out[0] * morph;
                        }
                        1 => {
                            dsp_state.filter_lp[ch].tick(&[filter_input, cutoff, q], &mut lp_out);
                            dsp_state.filter_hp[ch].tick(&[filter_input, cutoff, q], &mut hp_out);
                            channel_samples[ch] = lp_out[0] * (1.0 - morph) + hp_out[0] * morph;
                        }
                        _ => {
                            dsp_state.filter_hp[ch].tick(&[filter_input, cutoff, q], &mut hp_out);
                            channel_samples[ch] = hp_out[0];
                        }
                    }
                    if !filter_sat_pre {
                        channel_samples[ch] = sat(channel_samples[ch]);
                    }
                }
            } else {
                channel_samples = [0.0; 2];
            }
            dsp_state.amp_level_smooth =
                dsp_state.amp_level_smooth * amp_smooth_coeff
                    + dsp_state.amp_level * (1.0 - amp_smooth_coeff);
            let amp = dsp_state.amp_level_smooth;
            channel_samples[0] *= amp;
            channel_samples[1] *= amp;
            let lim = 0.9f32;
            if num_channels >= 2 {
                let l = (channel_samples[0] * volume).clamp(-lim, lim);
                let r = (channel_samples[1] * volume).clamp(-lim, lim);
                output[0][sample_idx] += l;
                output[1][sample_idx] += r;
            } else {
                let m = (channel_samples[0] * volume).clamp(-lim, lim);
                output[0][sample_idx] += m;
            }
        }

        track
            .monomi_sequencer_phase
            .store(sequencer_phase.to_bits(), Ordering::Relaxed);
        track.monomi_rng_state.store(rng_state, Ordering::Relaxed);
    }

    fn process_voidseed(
        track: &Track,
        track_output: &mut [Vec<f32>],
        num_buffer_samples: usize,
        _global_tempo: &AtomicU32,
        _master_step: i32,
        _master_phase: f32,
        _samples_per_step: f32,
        sample_rate: f32,
        dsp_state: &mut VoidSeedDspState,
    ) {
        let sr = sample_rate.max(1.0);
        dsp_state.set_sample_rate(sr);
        const VOID_SEED_DB_BOOST: f32 = 1.4125375; // +3 dB
        let target_base_freq = f32::from_bits(track.void_base_freq.load(Ordering::Relaxed));
        let target_chaos_depth = f32::from_bits(track.void_chaos_depth.load(Ordering::Relaxed));
        let target_entropy = f32::from_bits(track.void_entropy.load(Ordering::Relaxed));
        let target_feedback = f32::from_bits(track.void_feedback.load(Ordering::Relaxed));
        let target_diffusion = f32::from_bits(track.void_diffusion.load(Ordering::Relaxed));
        let target_mod_rate = f32::from_bits(track.void_mod_rate.load(Ordering::Relaxed));
        let target_void_level = f32::from_bits(track.void_level.load(Ordering::Relaxed));
        let target_void_pan = f32::from_bits(track.void_pan.load(Ordering::Relaxed));
        let target_void_width = f32::from_bits(track.void_width.load(Ordering::Relaxed));
        let target_void_close_decay =
            f32::from_bits(track.void_close_decay.load(Ordering::Relaxed));
        let target_void_filter_cutoff =
            f32::from_bits(track.void_filter_cutoff.load(Ordering::Relaxed));
        let target_void_filter_resonance =
            f32::from_bits(track.void_filter_resonance.load(Ordering::Relaxed));
        let target_void_drive = f32::from_bits(track.void_drive.load(Ordering::Relaxed));
        let void_filter_pre_drive = track.void_filter_pre_drive.load(Ordering::Relaxed);

        let base_freq = smooth_param(
            f32::from_bits(track.void_base_freq_smooth.load(Ordering::Relaxed)),
            target_base_freq,
            num_buffer_samples,
            sr,
        );
        let chaos_depth = smooth_param(
            f32::from_bits(track.void_chaos_depth_smooth.load(Ordering::Relaxed)),
            target_chaos_depth,
            num_buffer_samples,
            sr,
        );
        let entropy = smooth_param(
            f32::from_bits(track.void_entropy_smooth.load(Ordering::Relaxed)),
            target_entropy,
            num_buffer_samples,
            sr,
        );
        let feedback = smooth_param(
            f32::from_bits(track.void_feedback_smooth.load(Ordering::Relaxed)),
            target_feedback,
            num_buffer_samples,
            sr,
        );
        let diffusion = smooth_param(
            f32::from_bits(track.void_diffusion_smooth.load(Ordering::Relaxed)),
            target_diffusion,
            num_buffer_samples,
            sr,
        );
        let mod_rate = smooth_param(
            f32::from_bits(track.void_mod_rate_smooth.load(Ordering::Relaxed)),
            target_mod_rate,
            num_buffer_samples,
            sr,
        );
        let void_level =
            smooth_param(
                f32::from_bits(track.void_level_smooth.load(Ordering::Relaxed)),
                target_void_level,
                num_buffer_samples,
                sr,
            ) * VOID_SEED_DB_BOOST;
        let void_pan = smooth_param(
            f32::from_bits(track.void_pan_smooth.load(Ordering::Relaxed)),
            target_void_pan,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let void_width = smooth_param(
            f32::from_bits(track.void_width_smooth.load(Ordering::Relaxed)),
            target_void_width,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let void_filter_cutoff = smooth_param(
            f32::from_bits(track.void_filter_cutoff_smooth.load(Ordering::Relaxed)),
            target_void_filter_cutoff,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let void_filter_resonance = smooth_param(
            f32::from_bits(
                track
                    .void_filter_resonance_smooth
                    .load(Ordering::Relaxed),
            ),
            target_void_filter_resonance,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let void_drive = smooth_param(
            f32::from_bits(track.void_drive_smooth.load(Ordering::Relaxed)),
            target_void_drive,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let drive_gain = 1.0 + void_drive * 8.0;

        let mut osc_phases = [0.0f32; 12];
        let mut lfo_phases = [0.0f32; 12];
        let mut lfo_freqs = [0.0f32; 12];
        for i in 0..12 {
            osc_phases[i] = f32::from_bits(track.void_osc_phases[i].load(Ordering::Relaxed));
            lfo_phases[i] = f32::from_bits(track.void_lfo_phases[i].load(Ordering::Relaxed));
            lfo_freqs[i] = f32::from_bits(track.void_lfo_freqs[i].load(Ordering::Relaxed));
        }
        let mut chaos_phase = f32::from_bits(track.void_lfo_chaos_phase.load(Ordering::Relaxed));
        let mut filter_v1 = [
            f32::from_bits(track.void_filter_v1[0].load(Ordering::Relaxed)),
            f32::from_bits(track.void_filter_v1[1].load(Ordering::Relaxed)),
        ];
        let mut filter_v2 = [
            f32::from_bits(track.void_filter_v2[0].load(Ordering::Relaxed)),
            f32::from_bits(track.void_filter_v2[1].load(Ordering::Relaxed)),
        ];
        let mut internal_gain = f32::from_bits(track.void_internal_gain.load(Ordering::Relaxed));

        // Targeting 0.8 gain when enabled, 0.0 when disabled (ramping)
        let target_gain = if track.void_enabled.load(Ordering::Relaxed) {
            0.8 * VOID_SEED_DB_BOOST
        } else {
            0.0
        };
        let close_decay_seconds = target_void_close_decay.clamp(1.0, 20.0);
        let ramp_seconds = if track.void_enabled.load(Ordering::Relaxed) {
            4.0
        } else {
            close_decay_seconds
        };
        let gain_step = (target_gain - internal_gain) / (ramp_seconds.max(0.01) * sr);

        let output = track_output;
        let num_channels = output.len();

        if let Some(mut delay_buf) = track.void_delay_buffer.try_lock() {
            let mut write_pos = track.void_delay_write_pos.load(Ordering::Relaxed) as usize;
            let delay_len = delay_buf[0].len();
            // 8n delay at 120bpm = 0.25s. 
            let delay_samples = (0.25 * sr) as usize;

            for sample_idx in 0..num_buffer_samples {
                if target_gain >= internal_gain {
                    internal_gain = (internal_gain + gain_step).min(target_gain);
                } else {
                    internal_gain = (internal_gain + gain_step).max(0.0);
                }

                // Chaos LFO (affects filter frequency)
                chaos_phase += 0.02 / sr;
                if chaos_phase >= 1.0 { chaos_phase -= 1.0; }
                let chaos_lfo = (chaos_phase * 2.0 * PI).sin() * 0.5 + 0.5;
                let filter_mod = 0.2 + chaos_lfo * chaos_depth * 5.0;

                let mut swarm_sample = 0.0f32;
                let types = [0, 1, 2, 3]; // sine, sawtooth, square, triangle

                for i in 0..12 {
                    // Detune LFO
                    lfo_phases[i] += lfo_freqs[i] / sr;
                    if lfo_phases[i] >= 1.0 { lfo_phases[i] -= 1.0; }
                    let detune_cents = (lfo_phases[i] * 2.0 * PI).sin() * 20.0;
                    let detune_ratio = 2.0f32.powf(detune_cents / 1200.0);

                    // Frequency with entropy
                    let entropy_offset = ((i as f32 * 1.618).fract() - 0.5) * entropy;
                    let freq = base_freq * (i as f32 * 0.5 + 1.0) * (1.0 + entropy_offset) * detune_ratio;

                    osc_phases[i] += freq / sr;
                    if osc_phases[i] >= 1.0 { osc_phases[i] -= 1.0; }

                    let phase = osc_phases[i];
                    let val = match types[i % 4] {
                        0 => (phase * 2.0 * PI).sin(),
                        1 => phase * 2.0 - 1.0,
                        2 => if phase < 0.5 { 1.0 } else { -1.0 },
                        3 => if phase < 0.5 { phase * 4.0 - 1.0 } else { 3.0 - phase * 4.0 },
                        _ => 0.0,
                    };
                    swarm_sample += val * 0.04;
                }

                // Filter
                let cutoff_hz = (150.0 + mod_rate * 500.0 * filter_mod).clamp(20.0, 20000.0);
                let filter_f = (2.0 * (PI * cutoff_hz / sr).sin()).clamp(0.0, 0.99);
                let filter_q = 0.5;

                let mut channel_samples = [0.0f32; 2];
                for ch in 0..num_channels.min(2) {
                    let low = filter_v2[ch] + filter_f * filter_v1[ch];
                    let high = swarm_sample - low - filter_q * filter_v1[ch];
                    let band = filter_f * high + filter_v1[ch];
                    
                    let filtered = low;
                    
                    filter_v1[ch] = band;
                    filter_v2[ch] = low;

                    // Delay (Diffusion & Feedback)
                    let read_pos = (write_pos + delay_len - delay_samples) % delay_len;
                    let delayed_sample = delay_buf[ch][read_pos];
                    
                    // Diffusion is "wet" in DroneSYN
                    let output_sample = filtered * (1.0 - diffusion) + delayed_sample * diffusion;
                    
                    // Write back to delay buffer with feedback
                    delay_buf[ch][write_pos] = filtered + delayed_sample * feedback;

                    let mut processed = output_sample;
                    let cutoff_hz = 20.0 + void_filter_cutoff * 19980.0;
                    let q = 0.1 + void_filter_resonance * 0.9;
                    if void_filter_pre_drive {
                        let mut moog_out = [0.0f32];
                        dsp_state.filter_moog[ch].tick(&[processed, cutoff_hz, q], &mut moog_out);
                        processed = moog_out[0];
                    }
                    if void_drive > 0.0 {
                        let mut drive_out = [0.0f32];
                        dsp_state.drive.tick(&[processed * drive_gain], &mut drive_out);
                        processed = drive_out[0];
                    }
                    if !void_filter_pre_drive {
                        let mut moog_out = [0.0f32];
                        dsp_state.filter_moog[ch].tick(&[processed, cutoff_hz, q], &mut moog_out);
                        processed = moog_out[0];
                    }

                    channel_samples[ch] = processed;
                }
                if num_channels.min(2) == 1 {
                    channel_samples[1] = channel_samples[0];
                }
                if num_channels >= 2 {
                    let decorrelation_depth =
                        void_width * (0.01 * (0.25 + entropy) + 0.06);
                    if decorrelation_depth > 0.0 {
                        let decorrelation =
                            (chaos_phase * 2.0 * PI).sin() * decorrelation_depth;
                        channel_samples[0] -= decorrelation;
                        channel_samples[1] += decorrelation;
                    }
                }

                let mid = 0.5 * (channel_samples[0] + channel_samples[1]);
                let side = 0.5 * (channel_samples[0] - channel_samples[1]) * void_width;
                let mut left = mid + side;
                let mut right = mid - side;

                let pan = (void_pan * 2.0 - 1.0).clamp(-1.0, 1.0);
                let angle = (pan + 1.0) * (PI * 0.25);
                let pan_left = angle.cos();
                let pan_right = angle.sin();
                left *= pan_left;
                right *= pan_right;

                if num_channels >= 2 {
                    output[0][sample_idx] += left * internal_gain * void_level;
                    output[1][sample_idx] += right * internal_gain * void_level;
                } else if num_channels == 1 {
                    output[0][sample_idx] += ((left + right) * 0.5) * internal_gain * void_level;
                }
                write_pos = (write_pos + 1) % delay_len;
            }
            track.void_delay_write_pos.store(write_pos as u32, Ordering::Relaxed);
        }

        // Store back
        for i in 0..12 {
            track.void_osc_phases[i].store(osc_phases[i].to_bits(), Ordering::Relaxed);
            track.void_lfo_phases[i].store(lfo_phases[i].to_bits(), Ordering::Relaxed);
        }
        track.void_lfo_chaos_phase.store(chaos_phase.to_bits(), Ordering::Relaxed);
        track
            .void_base_freq_smooth
            .store(base_freq.to_bits(), Ordering::Relaxed);
        track
            .void_chaos_depth_smooth
            .store(chaos_depth.to_bits(), Ordering::Relaxed);
        track
            .void_entropy_smooth
            .store(entropy.to_bits(), Ordering::Relaxed);
        track
            .void_feedback_smooth
            .store(feedback.to_bits(), Ordering::Relaxed);
        track
            .void_diffusion_smooth
            .store(diffusion.to_bits(), Ordering::Relaxed);
        track
            .void_mod_rate_smooth
            .store(mod_rate.to_bits(), Ordering::Relaxed);
        track
            .void_level_smooth
            .store((void_level / VOID_SEED_DB_BOOST).to_bits(), Ordering::Relaxed);
        track
            .void_pan_smooth
            .store(void_pan.to_bits(), Ordering::Relaxed);
        track
            .void_width_smooth
            .store(void_width.to_bits(), Ordering::Relaxed);
        track
            .void_filter_cutoff_smooth
            .store(void_filter_cutoff.to_bits(), Ordering::Relaxed);
        track
            .void_filter_resonance_smooth
            .store(void_filter_resonance.to_bits(), Ordering::Relaxed);
        track
            .void_drive_smooth
            .store(void_drive.to_bits(), Ordering::Relaxed);

        track.void_filter_v1[0].store(filter_v1[0].to_bits(), Ordering::Relaxed);
        track.void_filter_v1[1].store(filter_v1[1].to_bits(), Ordering::Relaxed);
        track.void_filter_v2[0].store(filter_v2[0].to_bits(), Ordering::Relaxed);
        track.void_filter_v2[1].store(filter_v2[1].to_bits(), Ordering::Relaxed);
        track.void_internal_gain.store(internal_gain.to_bits(), Ordering::Relaxed);
    }

    fn process_track_mosaic(
        track: &Track,
        track_output: &mut [Vec<f32>],
        num_buffer_samples: usize,
        global_tempo: f32,
        master_step_count: i64,
        master_phase: f32,
        samples_per_step: f32,
    ) {
        if track.granular_type.load(Ordering::Relaxed) != 1 {
            return;
        }
        if !track.mosaic_enabled.load(Ordering::Relaxed) {
            return;
        }
        let mosaic_buffer = match track.mosaic_buffer.try_lock() {
            Some(buffer) => buffer,
            None => return,
        };
        if mosaic_buffer.is_empty() || num_buffer_samples == 0 {
            return;
        }
        let sr = track.sample_rate.load(Ordering::Relaxed).max(1) as usize;
        let mosaic_len = (sr * MOSAIC_BUFFER_SECONDS)
            .min(MOSAIC_BUFFER_SAMPLES)
            .max(1);
        let target_pitch =
            f32::from_bits(track.mosaic_pitch.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_rate =
            f32::from_bits(track.mosaic_rate.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_size =
            f32::from_bits(track.mosaic_size.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_contour =
            f32::from_bits(track.mosaic_contour.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_warp =
            f32::from_bits(track.mosaic_warp.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_spray =
            f32::from_bits(track.mosaic_spray.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_pattern =
            f32::from_bits(track.mosaic_pattern.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_wet =
            f32::from_bits(track.mosaic_wet.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_post_gain =
            f32::from_bits(track.mosaic_post_gain.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_spatial =
            f32::from_bits(track.mosaic_spatial.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_detune =
            f32::from_bits(track.mosaic_detune.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_rand_rate =
            f32::from_bits(track.mosaic_rand_rate.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_rand_size =
            f32::from_bits(track.mosaic_rand_size.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let mosaic_pitch = smooth_param(
            f32::from_bits(track.mosaic_pitch_smooth.load(Ordering::Relaxed)),
            target_pitch,
            num_buffer_samples,
            sr as f32,
        );
        let mosaic_rate = smooth_param(
            f32::from_bits(track.mosaic_rate_smooth.load(Ordering::Relaxed)),
            target_rate,
            num_buffer_samples,
            sr as f32,
        );
        let mosaic_size = smooth_param(
            f32::from_bits(track.mosaic_size_smooth.load(Ordering::Relaxed)),
            target_size,
            num_buffer_samples,
            sr as f32,
        );
        let mosaic_contour = smooth_param(
            f32::from_bits(track.mosaic_contour_smooth.load(Ordering::Relaxed)),
            target_contour,
            num_buffer_samples,
            sr as f32,
        );
        let mosaic_warp = smooth_param(
            f32::from_bits(track.mosaic_warp_smooth.load(Ordering::Relaxed)),
            target_warp,
            num_buffer_samples,
            sr as f32,
        );
        let mosaic_spray = smooth_param(
            f32::from_bits(track.mosaic_spray_smooth.load(Ordering::Relaxed)),
            target_spray,
            num_buffer_samples,
            sr as f32,
        );
        let mosaic_pattern = smooth_param(
            f32::from_bits(track.mosaic_pattern_smooth.load(Ordering::Relaxed)),
            target_pattern,
            num_buffer_samples,
            sr as f32,
        );
        let mosaic_wet = smooth_param(
            f32::from_bits(track.mosaic_wet_smooth.load(Ordering::Relaxed)),
            target_wet,
            num_buffer_samples,
            sr as f32,
        );
        let mosaic_post_gain = smooth_param(
            f32::from_bits(track.mosaic_post_gain_smooth.load(Ordering::Relaxed)),
            target_post_gain,
            num_buffer_samples,
            sr as f32,
        );
        let mosaic_spatial = smooth_param(
            f32::from_bits(track.mosaic_spatial_smooth.load(Ordering::Relaxed)),
            target_spatial,
            num_buffer_samples,
            sr as f32,
        );
        let mosaic_detune = smooth_param(
            f32::from_bits(track.mosaic_detune_smooth.load(Ordering::Relaxed)),
            target_detune,
            num_buffer_samples,
            sr as f32,
        );
        let mosaic_rand_rate = smooth_param(
            f32::from_bits(track.mosaic_rand_rate_smooth.load(Ordering::Relaxed)),
            target_rand_rate,
            num_buffer_samples,
            sr as f32,
        );
        let mosaic_rand_size = smooth_param(
            f32::from_bits(track.mosaic_rand_size_smooth.load(Ordering::Relaxed)),
            target_rand_size,
            num_buffer_samples,
            sr as f32,
        );
        track
            .mosaic_pitch_smooth
            .store(mosaic_pitch.to_bits(), Ordering::Relaxed);
        track
            .mosaic_rate_smooth
            .store(mosaic_rate.to_bits(), Ordering::Relaxed);
        track
            .mosaic_size_smooth
            .store(mosaic_size.to_bits(), Ordering::Relaxed);
        track
            .mosaic_contour_smooth
            .store(mosaic_contour.to_bits(), Ordering::Relaxed);
        track
            .mosaic_warp_smooth
            .store(mosaic_warp.to_bits(), Ordering::Relaxed);
        track
            .mosaic_spray_smooth
            .store(mosaic_spray.to_bits(), Ordering::Relaxed);
        track
            .mosaic_pattern_smooth
            .store(mosaic_pattern.to_bits(), Ordering::Relaxed);
        track
            .mosaic_wet_smooth
            .store(mosaic_wet.to_bits(), Ordering::Relaxed);
        track
            .mosaic_post_gain_smooth
            .store(mosaic_post_gain.to_bits(), Ordering::Relaxed);
        track
            .mosaic_spatial_smooth
            .store(mosaic_spatial.to_bits(), Ordering::Relaxed);
        track
            .mosaic_detune_smooth
            .store(mosaic_detune.to_bits(), Ordering::Relaxed);
        track
            .mosaic_rand_rate_smooth
            .store(mosaic_rand_rate.to_bits(), Ordering::Relaxed);
        track
            .mosaic_rand_size_smooth
            .store(mosaic_rand_size.to_bits(), Ordering::Relaxed);
        let pitch_bipolar = mosaic_cc_bipolar(mosaic_pitch);
        let contour_bipolar = mosaic_cc_bipolar(mosaic_contour);
        let tempo = if global_tempo.is_finite() {
            global_tempo.clamp(20.0, 240.0)
        } else {
            120.0
        };
        let sync_rate = mosaic_rate <= 0.5;
        let mut sync_beats = None;
        let base_rate = if sync_rate {
            let divisions = [
                1.5_f32,
                1.0,
                0.75,
                (2.0 / 3.0),
                0.5,
                0.375,
                (1.0 / 3.0),
                0.25,
                0.1875,
                (1.0 / 6.0),
                0.125,
                0.09375,
                (1.0 / 12.0),
                0.0625,
                0.046875,
                (1.0 / 24.0),
                0.03125,
                (1.0 / 48.0),
            ];
            let t = (mosaic_rate / 0.5).clamp(0.0, 1.0);
            let idx = (t * (divisions.len().saturating_sub(1)) as f32).round() as usize;
            let beats = divisions[idx.min(divisions.len() - 1)];
            sync_beats = Some(beats.max(0.0001));
            ((tempo / 60.0) / beats).clamp(MOSAIC_RATE_MIN, MOSAIC_RATE_MAX)
        } else {
            let free = ((mosaic_rate - 0.5) / 0.5).clamp(0.0, 1.0);
            MOSAIC_RATE_MIN + (MOSAIC_RATE_MAX - MOSAIC_RATE_MIN) * free
        };
        let base_size_ms =
            MOSAIC_SIZE_MIN_MS + (MOSAIC_SIZE_MAX_MS - MOSAIC_SIZE_MIN_MS) * mosaic_size;
        let semitones = pitch_bipolar * MOSAIC_PITCH_SEMITONES;
        let base_pitch_ratio = 2.0f32.powf(semitones / 12.0);
        let recent_write_pos =
            (track.mosaic_write_pos.load(Ordering::Relaxed) as usize) % mosaic_len;
        let loop_enabled = track.loop_enabled.load(Ordering::Relaxed);
        let loop_lock = track.mosaic_loop_lock.load(Ordering::Relaxed);
        let loop_start_norm =
            f32::from_bits(track.loop_start_smooth.load(Ordering::Relaxed)).clamp(0.0, 0.999999);
        let loop_length_norm =
            f32::from_bits(track.loop_length_smooth.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let (loop_start_idx, loop_len_idx, loop_lock_start_norm, loop_lock_len_norm) =
            if loop_lock && loop_enabled {
                let mut start = (loop_start_norm * mosaic_len as f32) as usize;
                if start >= mosaic_len {
                    start = mosaic_len.saturating_sub(1);
                }
                let mut len = (loop_length_norm * mosaic_len as f32) as usize;
                if len == 0 {
                    len = mosaic_len.saturating_sub(start).max(1);
                }
                let mut end = (start + len).min(mosaic_len);
                if end <= start {
                    end = (start + 1).min(mosaic_len);
                }
                let len = end.saturating_sub(start).max(1);
                let start_norm = start as f32 / mosaic_len as f32;
                let len_norm = len as f32 / mosaic_len as f32;
                (start, len, start_norm, len_norm)
            } else {
                (0, mosaic_len.max(1), 0.0, 1.0)
            };

        let mut grain_active: [bool; MOSAIC_MAX_GRAINS] =
            std::array::from_fn(|idx| track.mosaic_grain_active[idx].load(Ordering::Relaxed));
        let mut grain_pos: [f32; MOSAIC_MAX_GRAINS] = std::array::from_fn(|idx| {
            f32::from_bits(track.mosaic_grain_pos[idx].load(Ordering::Relaxed))
        });
        let mut grain_len: [usize; MOSAIC_MAX_GRAINS] = std::array::from_fn(|idx| {
            track.mosaic_grain_len[idx].load(Ordering::Relaxed) as usize
        });
        let mut grain_start: [usize; MOSAIC_MAX_GRAINS] = std::array::from_fn(|idx| {
            (track.mosaic_grain_start[idx].load(Ordering::Relaxed) as usize) % mosaic_len
        });
        let mut grain_pitch: [f32; MOSAIC_MAX_GRAINS] = std::array::from_fn(|idx| {
            f32::from_bits(track.mosaic_grain_pitch[idx].load(Ordering::Relaxed))
        });
        let mut grain_pan: [f32; MOSAIC_MAX_GRAINS] = std::array::from_fn(|idx| {
            f32::from_bits(track.mosaic_grain_pan[idx].load(Ordering::Relaxed))
        });
        let mut spawn_phase =
            f32::from_bits(track.mosaic_spawn_phase.load(Ordering::Relaxed)).max(0.0);
        let mut last_grain_start =
            track.mosaic_last_grain_start.load(Ordering::Relaxed) as usize;
        let mut last_grain_len =
            track.mosaic_last_grain_len.load(Ordering::Relaxed) as usize;
        let mut rng_state = track.mosaic_rng_state.load(Ordering::Relaxed);
        let post_gain = (mosaic_post_gain * 2.0).max(0.0);

        let num_channels = track_output.len();
        let output = track_output;

        for channel_idx in 0..num_channels {
            for sample_idx in 0..num_buffer_samples {
                output[channel_idx][sample_idx] *= 1.0 - mosaic_wet;
            }
        }

        let interval_samples = if let (true, Some(beats), true) = (
            sync_rate,
            sync_beats,
            samples_per_step.is_finite() && samples_per_step > 0.0,
        ) {
            (samples_per_step * beats * 4.0).max(1.0)
        } else {
            (sr as f32 / base_rate).max(1.0)
        };
        let base_global_step = if samples_per_step.is_finite() && samples_per_step > 0.0 {
            master_step_count as f64 + (master_phase as f64 / samples_per_step as f64)
        } else {
            0.0
        };
        let steps_per_trigger = sync_beats
            .map(|beats| (beats as f64) * 4.0)
            .unwrap_or(0.0);
        for sample_idx in 0..num_buffer_samples {
            let mut start_grain = false;
            if sync_rate {
                if steps_per_trigger > 0.0 && samples_per_step.is_finite() && samples_per_step > 0.0
                {
                    let step_pos =
                        base_global_step + (sample_idx as f64 / samples_per_step as f64);
                    let prev_step_pos = base_global_step
                        + ((sample_idx as f64 - 1.0) / samples_per_step as f64);
                    let bucket = (step_pos / steps_per_trigger).floor();
                    let prev_bucket = (prev_step_pos / steps_per_trigger).floor();
                    if bucket != prev_bucket {
                        start_grain = true;
                    }
                }
            } else {
                spawn_phase -= 1.0;
                if spawn_phase <= 0.0 {
                    start_grain = true;
                    spawn_phase += interval_samples;
                }
            }

            if start_grain {
                let mut slot = None;
                for idx in 0..MOSAIC_MAX_GRAINS {
                    if !grain_active[idx] {
                        slot = Some(idx);
                        break;
                    }
                }
                if slot.is_none() {
                    let mut max_progress = -1.0f32;
                    let mut max_idx = 0usize;
                    for idx in 0..MOSAIC_MAX_GRAINS {
                        let len = grain_len[idx].max(1) as f32;
                        let progress = grain_pos[idx] / len;
                        if progress > max_progress {
                            max_progress = progress;
                            max_idx = idx;
                        }
                    }
                    slot = Some(max_idx);
                }
                let slot = slot.unwrap();
                let rand_rate = next_mosaic_rand_unit(&mut rng_state) * 2.0 - 1.0;
                let rand_size = next_mosaic_rand_unit(&mut rng_state) * 2.0 - 1.0;
                let mut rate = if sync_rate {
                    base_rate
                } else {
                    base_rate * (1.0 + mosaic_rand_rate * rand_rate * 0.5)
                };
                rate = rate.clamp(MOSAIC_RATE_MIN, MOSAIC_RATE_MAX);
                if !sync_rate {
                    // Use randomized rate for free mode so rand rate affects spawn interval.
                    spawn_phase = (sr as f32 / rate).max(1.0);
                }
                let mut size_ms = base_size_ms * (1.0 + mosaic_rand_size * rand_size * 0.5);
                size_ms = size_ms.clamp(MOSAIC_SIZE_MIN_MS, MOSAIC_SIZE_MAX_MS);
                grain_len[slot] = ((size_ms / 1000.0) * sr as f32).round() as usize;
                grain_len[slot] = grain_len[slot].clamp(1, mosaic_len);

                let rand_pos = next_mosaic_rand_unit(&mut rng_state);
                let recent_pos = if loop_lock && loop_enabled && loop_len_idx > 0 {
                    ((recent_write_pos as isize - loop_start_idx as isize) as f32
                        / loop_len_idx as f32)
                        .clamp(0.0, 0.999999)
                } else {
                    recent_write_pos as f32 / mosaic_len as f32
                };
                let mut pos = recent_pos * (1.0 - mosaic_pattern) + rand_pos * mosaic_pattern;
                if mosaic_warp > 0.0 {
                    pos = pos.powf(1.0 + mosaic_warp * 2.0);
                }
                let spray = next_mosaic_rand_unit(&mut rng_state) * 2.0 - 1.0;
                pos = (pos + spray * mosaic_spray * 0.25).clamp(0.0, 0.999999);
                if loop_lock && loop_enabled {
                    pos = (loop_lock_start_norm + pos * loop_lock_len_norm)
                        .clamp(loop_lock_start_norm, (loop_lock_start_norm + loop_lock_len_norm).min(0.999999));
                }
                grain_start[slot] = (pos * mosaic_len as f32) as usize;
                if mosaic_len > 0 {
                    let marker_index =
                        (track.mosaic_grain_marker_write.load(Ordering::Relaxed) as usize)
                            % MOSAIC_GRAIN_MARKER_COUNT;
                    track.mosaic_grain_markers[marker_index].store(
                        (grain_start[slot] as f32 / mosaic_len as f32).to_bits(),
                        Ordering::Relaxed,
                    );
                    track.mosaic_grain_marker_write.store(
                        ((marker_index + 1) % MOSAIC_GRAIN_MARKER_COUNT) as u32,
                        Ordering::Relaxed,
                    );
                }

                let detune = next_mosaic_rand_unit(&mut rng_state) * 2.0 - 1.0;
                let detune_cents = detune * mosaic_detune * MOSAIC_DETUNE_CENTS;
                grain_pitch[slot] =
                    base_pitch_ratio * 2.0f32.powf(detune_cents / 1200.0);
                let pan_rand = next_mosaic_rand_unit(&mut rng_state) * 2.0 - 1.0;
                grain_pan[slot] = (pan_rand * mosaic_spatial).clamp(-1.0, 1.0);

                grain_pos[slot] = 0.0;
                grain_active[slot] = true;
                last_grain_start = grain_start[slot];
                last_grain_len = grain_len[slot];
            }
            for grain_idx in 0..MOSAIC_MAX_GRAINS {
                if !grain_active[grain_idx] {
                    continue;
                }
                let len = grain_len[grain_idx].max(1);
                if grain_pos[grain_idx] >= len as f32 {
                    grain_active[grain_idx] = false;
                    continue;
                }
                let read_pos =
                    grain_start[grain_idx] as f32 + grain_pos[grain_idx] * grain_pitch[grain_idx];
                let t = (grain_pos[grain_idx] / len as f32).clamp(0.0, 1.0);
                let base_env = if t < 0.5 { t * 2.0 } else { (1.0 - t) * 2.0 };
                let curve = if contour_bipolar >= 0.0 {
                    1.0 + contour_bipolar * 4.0
                } else {
                    1.0 / (1.0 + (-contour_bipolar) * 4.0)
                };
                let env = base_env.powf(curve);
                let (left_gain, right_gain, other_gain) = if num_channels >= 2 {
                    let pan = grain_pan[grain_idx].clamp(-1.0, 1.0);
                    let angle = (pan + 1.0) * 0.25 * PI;
                    let left = angle.cos();
                    let right = angle.sin();
                    (left, right, 0.5 * (left + right))
                } else {
                    (1.0, 1.0, 1.0)
                };
                for channel_idx in 0..num_channels {
                    let src_channel = if channel_idx < mosaic_buffer.len() {
                        channel_idx
                    } else {
                        0
                    };
                    let sample_value = sample_at_linear_ring(
                        &mosaic_buffer,
                        src_channel,
                        read_pos,
                    );
                    let wet = mosaic_wet;
                    let pan_gain = if channel_idx == 0 {
                        left_gain
                    } else if channel_idx == 1 {
                        right_gain
                    } else {
                        other_gain
                    };
                    output[channel_idx][sample_idx] +=
                        sample_value * env * MOSAIC_OUTPUT_GAIN * wet * pan_gain;
                }
                grain_pos[grain_idx] += 1.0;
            }
        }

        for idx in 0..MOSAIC_MAX_GRAINS {
            track
                .mosaic_grain_active[idx]
                .store(grain_active[idx], Ordering::Relaxed);
            track
                .mosaic_grain_pos[idx]
                .store(grain_pos[idx].to_bits(), Ordering::Relaxed);
            track
                .mosaic_grain_len[idx]
                .store(grain_len[idx] as u32, Ordering::Relaxed);
            track
                .mosaic_grain_start[idx]
                .store(grain_start[idx] as u32, Ordering::Relaxed);
            track
                .mosaic_grain_pitch[idx]
                .store(grain_pitch[idx].to_bits(), Ordering::Relaxed);
            track
                .mosaic_grain_pan[idx]
                .store(grain_pan[idx].to_bits(), Ordering::Relaxed);
        }
        track
            .mosaic_spawn_phase
            .store(spawn_phase.to_bits(), Ordering::Relaxed);
        track
            .mosaic_last_grain_start
            .store(last_grain_start as u32, Ordering::Relaxed);
        track
            .mosaic_last_grain_len
            .store(last_grain_len as u32, Ordering::Relaxed);
        track
            .mosaic_rng_state
            .store(rng_state, Ordering::Relaxed);

        if post_gain != 1.0 {
            for channel_idx in 0..num_channels {
                for sample_idx in 0..num_buffer_samples {
                    output[channel_idx][sample_idx] *= post_gain;
                }
            }
        }
    }

    fn process_track_ring(
        track: &Track,
        track_output: &mut [Vec<f32>],
        num_buffer_samples: usize,
        global_tempo: f32,
    ) {
        if !track.ring_enabled.load(Ordering::Relaxed) {
            return;
        }
        if num_buffer_samples == 0 {
            return;
        }
        let sr = track.sample_rate.load(Ordering::Relaxed).max(1) as f32;
        let target_cutoff =
            f32::from_bits(track.ring_cutoff.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_resonance =
            f32::from_bits(track.ring_resonance.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_decay =
            f32::from_bits(track.ring_decay.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_pitch =
            f32::from_bits(track.ring_pitch.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_tone =
            f32::from_bits(track.ring_tone.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_tilt =
            f32::from_bits(track.ring_tilt.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_slope =
            f32::from_bits(track.ring_slope.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_wet =
            f32::from_bits(track.ring_wet.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_detune =
            f32::from_bits(track.ring_detune.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_waves =
            f32::from_bits(track.ring_waves.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_waves_rate =
            f32::from_bits(track.ring_waves_rate.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_waves_mode =
            track.ring_waves_rate_mode.load(Ordering::Relaxed);
        let target_noise =
            f32::from_bits(track.ring_noise.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_noise_rate =
            f32::from_bits(track.ring_noise_rate.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let target_noise_mode =
            track.ring_noise_rate_mode.load(Ordering::Relaxed);
        let ring_scale = track.ring_scale.load(Ordering::Relaxed);

        let ring_cutoff = smooth_param(
            f32::from_bits(track.ring_cutoff_smooth.load(Ordering::Relaxed)),
            target_cutoff,
            num_buffer_samples,
            sr,
        );
        let ring_resonance = smooth_param(
            f32::from_bits(track.ring_resonance_smooth.load(Ordering::Relaxed)),
            target_resonance,
            num_buffer_samples,
            sr,
        );
        let ring_decay = smooth_param(
            f32::from_bits(track.ring_decay_smooth.load(Ordering::Relaxed)),
            target_decay,
            num_buffer_samples,
            sr,
        );
        let ring_pitch = smooth_param(
            f32::from_bits(track.ring_pitch_smooth.load(Ordering::Relaxed)),
            target_pitch,
            num_buffer_samples,
            sr,
        );
        let ring_tone = smooth_param(
            f32::from_bits(track.ring_tone_smooth.load(Ordering::Relaxed)),
            target_tone,
            num_buffer_samples,
            sr,
        );
        let ring_tilt = smooth_param(
            f32::from_bits(track.ring_tilt_smooth.load(Ordering::Relaxed)),
            target_tilt,
            num_buffer_samples,
            sr,
        );
        let ring_slope = smooth_param(
            f32::from_bits(track.ring_slope_smooth.load(Ordering::Relaxed)),
            target_slope,
            num_buffer_samples,
            sr,
        );
        let ring_wet = smooth_param(
            f32::from_bits(track.ring_wet_smooth.load(Ordering::Relaxed)),
            target_wet,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let ring_detune = smooth_param(
            f32::from_bits(track.ring_detune_smooth.load(Ordering::Relaxed)),
            target_detune,
            num_buffer_samples,
            sr,
        );
        let ring_waves = smooth_param(
            f32::from_bits(track.ring_waves_smooth.load(Ordering::Relaxed)),
            target_waves,
            num_buffer_samples,
            sr,
        );
        let ring_waves_rate = smooth_param(
            f32::from_bits(track.ring_waves_rate_smooth.load(Ordering::Relaxed)),
            target_waves_rate,
            num_buffer_samples,
            sr,
        );
        let ring_noise = smooth_param(
            f32::from_bits(track.ring_noise_smooth.load(Ordering::Relaxed)),
            target_noise,
            num_buffer_samples,
            sr,
        );
        let ring_noise_rate = smooth_param(
            f32::from_bits(track.ring_noise_rate_smooth.load(Ordering::Relaxed)),
            target_noise_rate,
            num_buffer_samples,
            sr,
        );

        track
            .ring_cutoff_smooth
            .store(ring_cutoff.to_bits(), Ordering::Relaxed);
        track
            .ring_resonance_smooth
            .store(ring_resonance.to_bits(), Ordering::Relaxed);
        track
            .ring_decay_smooth
            .store(ring_decay.to_bits(), Ordering::Relaxed);
        track
            .ring_pitch_smooth
            .store(ring_pitch.to_bits(), Ordering::Relaxed);
        track
            .ring_tone_smooth
            .store(ring_tone.to_bits(), Ordering::Relaxed);
        track
            .ring_tilt_smooth
            .store(ring_tilt.to_bits(), Ordering::Relaxed);
        track
            .ring_slope_smooth
            .store(ring_slope.to_bits(), Ordering::Relaxed);
        track
            .ring_wet_smooth
            .store(ring_wet.to_bits(), Ordering::Relaxed);
        track
            .ring_detune_smooth
            .store(ring_detune.to_bits(), Ordering::Relaxed);
        track
            .ring_waves_smooth
            .store(ring_waves.to_bits(), Ordering::Relaxed);
        track
            .ring_waves_rate_smooth
            .store(ring_waves_rate.to_bits(), Ordering::Relaxed);
        track
            .ring_noise_smooth
            .store(ring_noise.to_bits(), Ordering::Relaxed);
        track
            .ring_noise_rate_smooth
            .store(ring_noise_rate.to_bits(), Ordering::Relaxed);

        if ring_wet > 0.0 {
            let decay_mode = track.ring_decay_mode.load(Ordering::Relaxed);
            let ring_pre_post = track.ring_pre_post.load(Ordering::Relaxed);
            let decay_sec = 0.05 + ring_decay.clamp(0.0, 1.0) * 3.95;
            let decay_factor = (-1.0 / (decay_sec * sr)).exp();
            let pitch_bipolar = ring_pitch * 2.0 - 1.0;
            let tone_bipolar = ring_tone * 2.0 - 1.0;
            let tilt_bipolar = ring_tilt * 2.0 - 1.0;
            let pitch_ratio =
                2.0f32.powf((pitch_bipolar * RING_PITCH_SEMITONES) / 12.0);
            let cutoff_hz = RING_CUTOFF_MIN_HZ
                * (RING_CUTOFF_MAX_HZ / RING_CUTOFF_MIN_HZ).powf(ring_cutoff);
            let cutoff_hz =
                (cutoff_hz * pitch_ratio).clamp(20.0, sr * 0.45);
            let cutoff_hz = ring_quantize_freq(cutoff_hz, ring_scale);
            let q = 0.5 + ring_resonance * 12.0;
            let r = 1.0 / (2.0 * q.max(0.001));
            let slope = ring_slope.clamp(0.0, 1.0);

            let num_channels = track_output.len();
            let output = track_output;
            let detune_phase =
                f32::from_bits(track.ring_detune_phase.load(Ordering::Relaxed));
            let waves_mode = target_waves_mode;
            let noise_mode = target_noise_mode;
            let waves_rate_hz = ring_rate_hz(ring_waves_rate, waves_mode, global_tempo);
            let noise_rate_hz = ring_rate_hz(ring_noise_rate, noise_mode, global_tempo);
            let waves_step = (waves_rate_hz / sr).min(1.0);
            let noise_step = (noise_rate_hz / sr).min(1.0);
            let mut waves_phase =
                f32::from_bits(track.ring_waves_phase.load(Ordering::Relaxed));
            let mut noise_phase =
                f32::from_bits(track.ring_noise_phase.load(Ordering::Relaxed));
            let mut noise_value =
                f32::from_bits(track.ring_noise_value.load(Ordering::Relaxed));
            let mut noise_rng = track.ring_noise_rng.load(Ordering::Relaxed);
            let mut phase = detune_phase;
            let detune_rate = RING_DETUNE_RATE_HZ / sr;
            let detune_depth = ring_detune.clamp(0.0, 1.0) * RING_DETUNE_CENTS;
            for channel_idx in 0..num_channels {
                let mut low =
                    f32::from_bits(track.ring_low[channel_idx].load(Ordering::Relaxed));
                let mut band =
                    f32::from_bits(track.ring_band[channel_idx].load(Ordering::Relaxed));
                for sample_idx in 0..num_buffer_samples {
                    if decay_mode == 1 {
                        let tilt = tilt_bipolar;
                        let low_decay = (decay_factor * (1.0 - tilt * 0.35)).clamp(0.0, 1.0);
                        let band_decay = (decay_factor * (1.0 + tilt * 0.35)).clamp(0.0, 1.0);
                        low *= low_decay;
                        band *= band_decay;
                    }
                    let input = output[channel_idx][sample_idx];
                    let lfo = (phase * 2.0 * PI).sin();
                    let detune_cents =
                        detune_depth * lfo * if channel_idx == 0 { -1.0 } else { 1.0 };
                    let detune_ratio = 2.0f32.powf(detune_cents / 1200.0);
                    let detuned_hz =
                        (cutoff_hz * detune_ratio).clamp(20.0, sr * 0.45);
                    let mut g_detune = (PI * detuned_hz / sr).tan();
                    if !g_detune.is_finite() {
                        g_detune = 0.0;
                    } else if g_detune > 10.0 {
                        g_detune = 10.0;
                    }
                    let waves_lfo = (waves_phase * 2.0 * PI).sin();
                    let waves_mod =
                        (1.0 - ring_waves) + ring_waves * (0.5 + 0.5 * waves_lfo);
                    let noise_mod =
                        (1.0 - ring_noise) + ring_noise * (0.5 + 0.5 * noise_value);
                    let pre_modulated = if ring_pre_post {
                        input * waves_mod * noise_mod
                    } else {
                        input
                    };
                    let v1 = (pre_modulated - low - r * band) * g_detune;
                    let v2 = band + v1;
                    low += v2;
                    band = v2;
                    low = low.clamp(-8.0, 8.0);
                    band = band.clamp(-8.0, 8.0);
                    let high = pre_modulated - low - r * band;
                    let filtered = if slope < 0.5 {
                        let t = slope / 0.5;
                        low + (band - low) * t
                    } else {
                        let t = (slope - 0.5) / 0.5;
                        band + (high - band) * t
                    };
                    if decay_mode == 0 {
                        let tilt = tilt_bipolar;
                        let low_decay = (decay_factor * (1.0 - tilt * 0.35)).clamp(0.0, 1.0);
                        let band_decay = (decay_factor * (1.0 + tilt * 0.35)).clamp(0.0, 1.0);
                        low *= low_decay;
                        band *= band_decay;
                    }
                    let tone_mix = filtered + tone_bipolar * (high - low) * 0.5;
                    let post_modulated = if ring_pre_post {
                        tone_mix
                    } else {
                        tone_mix * waves_mod * noise_mod
                    };
                    output[channel_idx][sample_idx] =
                        input * (1.0 - ring_wet) + post_modulated * ring_wet;
                    if !low.is_finite() || !band.is_finite() || !output[channel_idx][sample_idx].is_finite() {
                        low = 0.0;
                        band = 0.0;
                        output[channel_idx][sample_idx] = input;
                    }
                    if channel_idx == 0 {
                        phase += detune_rate;
                        if phase >= 1.0 {
                            phase -= 1.0;
                        }
                        waves_phase += waves_step;
                        if waves_phase >= 1.0 {
                            waves_phase -= 1.0;
                        }
                        noise_phase += noise_step;
                        if noise_phase >= 1.0 {
                            noise_phase -= 1.0;
                            noise_rng = noise_rng
                                .wrapping_mul(1664525)
                                .wrapping_add(1013904223);
                            let noise = (noise_rng as f32 / u32::MAX as f32) * 2.0 - 1.0;
                            if noise.is_finite() {
                                noise_value = noise;
                            } else {
                                noise_value = 0.0;
                            }
                        }
                    }
                }
                track.ring_low[channel_idx]
                    .store(low.to_bits(), Ordering::Relaxed);
                track.ring_band[channel_idx]
                    .store(band.to_bits(), Ordering::Relaxed);
            }
            track
                .ring_detune_phase
                .store(phase.to_bits(), Ordering::Relaxed);
            track
                .ring_waves_phase
                .store(waves_phase.to_bits(), Ordering::Relaxed);
            track
                .ring_noise_phase
                .store(noise_phase.to_bits(), Ordering::Relaxed);
            track
                .ring_noise_value
                .store(noise_value.to_bits(), Ordering::Relaxed);
            track
                .ring_noise_rng
                .store(noise_rng, Ordering::Relaxed);
        }
    }

    fn process_track_modul8(
        track: &Track,
        num_buffer_samples: usize,
        tempo: f32,
        sample_rate: f32,
        transport_running: bool,
    ) {
        let restore_base = |track: &Track, i: usize| {
            let prev_target = track.modul8_base_target[i].load(Ordering::Relaxed);
            if prev_target != u32::MAX {
                let base = f32::from_bits(track.modul8_base_value[i].load(Ordering::Relaxed));
                if modul8_target_range(prev_target).is_some() {
                    modul8_target_set(track, prev_target, base);
                }
                track.modul8_base_target[i].store(u32::MAX, Ordering::Relaxed);
            }
        };
        if num_buffer_samples == 0 || sample_rate <= 0.0 {
            return;
        }
        if !transport_running {
            for i in 0..MODUL8_LFOS {
                restore_base(track, i);
            }
            return;
        }
        if !track.modul8_enabled.load(Ordering::Relaxed) {
            for i in 0..MODUL8_LFOS {
                restore_base(track, i);
            }
            return;
        }

        let engine_type = track.engine_type.load(Ordering::Relaxed);
        let target_ids = modul8_target_ids_for_engine(engine_type);
        if target_ids.is_empty() {
            return;
        }
        let mut rng = track.modul8_rng_state.load(Ordering::Relaxed);
        for i in 0..MODUL8_LFOS {
            let amount = f32::from_bits(track.modul8_amount[i].load(Ordering::Relaxed)).clamp(0.0, 1.0);
            if amount <= 0.0 {
                let prev_target = track.modul8_base_target[i].load(Ordering::Relaxed);
                if prev_target != u32::MAX {
                    let base = f32::from_bits(track.modul8_base_value[i].load(Ordering::Relaxed));
                    if modul8_target_range(prev_target).is_some() {
                        modul8_target_set(track, prev_target, base);
                    }
                    track.modul8_base_target[i].store(u32::MAX, Ordering::Relaxed);
                }
                continue;
            }
            let target_index = track.modul8_target[i].load(Ordering::Relaxed) as usize;
            let target_index = target_index.min(target_ids.len().saturating_sub(1));
            let target = *target_ids.get(target_index).unwrap_or(&0);
            if target == 0 || target >= MODUL8_TARGET_COUNT {
                restore_base(track, i);
                continue;
            }
            let Some((min_v, max_v)) = modul8_target_range(target) else {
                continue;
            };
            let prev_target = track.modul8_base_target[i].load(Ordering::Relaxed);
            if prev_target != target {
                if prev_target != u32::MAX {
                    let prev_base =
                        f32::from_bits(track.modul8_base_value[i].load(Ordering::Relaxed));
                    if modul8_target_range(prev_target).is_some() {
                        modul8_target_set(track, prev_target, prev_base);
                    }
                }
                if let Some(base_now) = modul8_target_get(track, target) {
                    track.modul8_base_value[i].store(base_now.to_bits(), Ordering::Relaxed);
                    track.modul8_base_target[i].store(target, Ordering::Relaxed);
                } else {
                    continue;
                }
            }

            let wave = track.modul8_wave[i].load(Ordering::Relaxed).min(4);
            let rate = f32::from_bits(track.modul8_rate[i].load(Ordering::Relaxed));
            let sync = track.modul8_sync[i].load(Ordering::Relaxed);
            let div = track.modul8_division[i].load(Ordering::Relaxed);
            let mut phase = f32::from_bits(track.modul8_phase[i].load(Ordering::Relaxed)).fract();
            let mut snh = f32::from_bits(track.modul8_snh[i].load(Ordering::Relaxed));
            let bias = f32::from_bits(track.modul8_bias[i].load(Ordering::Relaxed)).clamp(0.0, 1.0);
            let freq_hz = modul8_rate_hz(rate, sync, div, tempo);
            let phase_advance = (freq_hz * num_buffer_samples as f32 / sample_rate).max(0.0);
            let wrapped = phase + phase_advance;
            phase = wrapped.fract();
            if wave == 4 && (wrapped >= 1.0 || !snh.is_finite()) {
                rng = rng.wrapping_mul(1664525).wrapping_add(1013904223);
                snh = (rng as f32 / u32::MAX as f32) * 2.0 - 1.0;
            }
            let lfo = lfo_waveform_value(wave, phase, snh);
            let range = max_v - min_v;
            let center = min_v + bias * range;
            let amplitude = (center - min_v).min(max_v - center);
            let value = (center + lfo * amplitude * amount).clamp(min_v, max_v);
            modul8_target_set(track, target, value);
            track.modul8_phase[i].store(phase.to_bits(), Ordering::Relaxed);
            track.modul8_snh[i].store(snh.to_bits(), Ordering::Relaxed);
        }
        track.modul8_rng_state.store(rng, Ordering::Relaxed);
    }

    fn process_track_g8(
        track: &Track,
        track_output: &mut [Vec<f32>],
        num_buffer_samples: usize,
        master_step_count: i64,
        master_phase: f32,
        samples_per_step: f32,
        sample_rate: f32,
    ) {
        if !track.g8_enabled.load(Ordering::Relaxed) {
            return;
        }
        if num_buffer_samples == 0 || track_output.is_empty() {
            return;
        }
        if !samples_per_step.is_finite() || samples_per_step <= 0.0 {
            return;
        }

        let rate_index = track.g8_rate_index.load(Ordering::Relaxed).min(4);
        let division = match rate_index {
            0 => 1.0,
            1 => 0.5,
            2 => 0.25,
            3 => 0.125,
            _ => 0.0625,
        };
        let step_len = (samples_per_step * division).max(1.0);
        let base_global_phase = (master_step_count as f32 * samples_per_step) + master_phase;

        let mut steps = [1.0f32; G8_STEPS];
        for i in 0..G8_STEPS {
            steps[i] = f32::from_bits(track.g8_steps[i].load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        }

        let smoothing_samples = (sample_rate * (G8_GAIN_SMOOTH_MS / 1000.0)).max(1.0);
        let mut smooth_gain =
            f32::from_bits(track.g8_gain_smooth.load(Ordering::Relaxed)).clamp(0.0, 1.0);

        let num_channels = track_output.len();
        for sample_idx in 0..num_buffer_samples {
            let step_pos = (base_global_phase + sample_idx as f32) / step_len;
            let step_idx = (step_pos.floor() as i64).rem_euclid(G8_STEPS as i64) as usize;
            let target_gain = steps[step_idx];
            smooth_gain += (target_gain - smooth_gain) / smoothing_samples;
            let gain = smooth_gain.clamp(0.0, 1.0);
            for channel_idx in 0..num_channels {
                track_output[channel_idx][sample_idx] *= gain;
            }
        }

        track
            .g8_gain_smooth
            .store(smooth_gain.to_bits(), Ordering::Relaxed);
    }

    fn process_track_texture(
        track: &Track,
        track_output: &mut [Vec<f32>],
        num_buffer_samples: usize,
    ) {
        if !track.texture_enabled.load(Ordering::Relaxed) {
            return;
        }
        if num_buffer_samples == 0 || track_output.is_empty() {
            return;
        }
        let sr = track.sample_rate.load(Ordering::Relaxed).max(1) as f32;

        let target_drive =
            f32::from_bits(track.texture_drive.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_compress =
            f32::from_bits(track.texture_compress.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_crush =
            f32::from_bits(track.texture_crush.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_tilt =
            f32::from_bits(track.texture_tilt.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_noise =
            f32::from_bits(track.texture_noise.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_noise_decay =
            f32::from_bits(track.texture_noise_decay.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_noise_color =
            f32::from_bits(track.texture_noise_color.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_wet =
            f32::from_bits(track.texture_wet.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_post_gain =
            f32::from_bits(track.texture_post_gain.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let gate = track.texture_gate.load(Ordering::Relaxed);

        let drive = smooth_param(
            f32::from_bits(track.texture_drive_smooth.load(Ordering::Relaxed)),
            target_drive,
            num_buffer_samples,
            sr,
        );
        let compress = smooth_param(
            f32::from_bits(track.texture_compress_smooth.load(Ordering::Relaxed)),
            target_compress,
            num_buffer_samples,
            sr,
        );
        let crush = smooth_param(
            f32::from_bits(track.texture_crush_smooth.load(Ordering::Relaxed)),
            target_crush,
            num_buffer_samples,
            sr,
        );
        let tilt = smooth_param(
            f32::from_bits(track.texture_tilt_smooth.load(Ordering::Relaxed)),
            target_tilt,
            num_buffer_samples,
            sr,
        );
        let noise = smooth_param(
            f32::from_bits(track.texture_noise_smooth.load(Ordering::Relaxed)),
            target_noise,
            num_buffer_samples,
            sr,
        );
        let noise_decay = smooth_param(
            f32::from_bits(track.texture_noise_decay_smooth.load(Ordering::Relaxed)),
            target_noise_decay,
            num_buffer_samples,
            sr,
        );
        let noise_color = smooth_param(
            f32::from_bits(track.texture_noise_color_smooth.load(Ordering::Relaxed)),
            target_noise_color,
            num_buffer_samples,
            sr,
        );
        let wet = smooth_param(
            f32::from_bits(track.texture_wet_smooth.load(Ordering::Relaxed)),
            target_wet,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let post_gain = smooth_param(
            f32::from_bits(track.texture_post_gain_smooth.load(Ordering::Relaxed)),
            target_post_gain,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);

        track
            .texture_drive_smooth
            .store(drive.to_bits(), Ordering::Relaxed);
        track
            .texture_compress_smooth
            .store(compress.to_bits(), Ordering::Relaxed);
        track
            .texture_crush_smooth
            .store(crush.to_bits(), Ordering::Relaxed);
        track
            .texture_tilt_smooth
            .store(tilt.to_bits(), Ordering::Relaxed);
        track
            .texture_noise_smooth
            .store(noise.to_bits(), Ordering::Relaxed);
        track
            .texture_noise_decay_smooth
            .store(noise_decay.to_bits(), Ordering::Relaxed);
        track
            .texture_noise_color_smooth
            .store(noise_color.to_bits(), Ordering::Relaxed);
        track
            .texture_wet_smooth
            .store(wet.to_bits(), Ordering::Relaxed);
        track
            .texture_post_gain_smooth
            .store(post_gain.to_bits(), Ordering::Relaxed);

        if wet <= 0.0 {
            return;
        }

        let drive_gain = 1.0 + drive * 8.0;
        let crush_step = crush.clamp(0.01, 1.0);
        let tilt_bipolar = tilt * 2.0 - 1.0;
        let tilt_low_gain = (1.0 + tilt_bipolar * 0.5).max(0.0);
        let tilt_high_gain = (1.0 - tilt_bipolar * 0.5).max(0.0);
        let tilt_cutoff = 800.0;
        let tilt_alpha = 1.0 - (-2.0 * PI * tilt_cutoff / sr).exp();

        let noise_cutoff = 200.0 + noise_color * 12000.0;
        let noise_alpha = 1.0 - (-2.0 * PI * noise_cutoff / sr).exp();
        let noise_decay_sec = 0.02 + noise_decay * 2.0;
        let noise_decay_factor = (-1.0 / (noise_decay_sec * sr)).exp();
        let post_gain_lin = post_gain * 2.0;

        let mut noise_env =
            f32::from_bits(track.texture_noise_env.load(Ordering::Relaxed));
        let mut noise_rng = track.texture_noise_rng.load(Ordering::Relaxed);
        let mut crush_phase = track.texture_crush_phase.load(Ordering::Relaxed);

        let channel_count = track_output.len().min(2);
        let mut noise_lp = [0.0f32; 2];
        let mut tilt_lp = [0.0f32; 2];
        let mut crush_hold = [0.0f32; 2];
        for idx in 0..channel_count {
            noise_lp[idx] =
                f32::from_bits(track.texture_noise_lp[idx].load(Ordering::Relaxed));
            tilt_lp[idx] = f32::from_bits(track.texture_tilt_lp[idx].load(Ordering::Relaxed));
            crush_hold[idx] =
                f32::from_bits(track.texture_crush_hold[idx].load(Ordering::Relaxed));
        }

        for sample_idx in 0..num_buffer_samples {
            let mut abs_in = 0.0f32;
            if gate {
                for channel_idx in 0..channel_count {
                    let input = track_output[channel_idx][sample_idx].abs();
                    if input > abs_in {
                        abs_in = input;
                    }
                }
                if abs_in > 0.01 {
                    noise_env = 1.0;
                } else {
                    noise_env *= noise_decay_factor;
                }
            } else {
                noise_env = 1.0;
            }

            noise_rng = noise_rng
                .wrapping_mul(1664525)
                .wrapping_add(1013904223);
            let noise_sample = (noise_rng as f32 / u32::MAX as f32) * 2.0 - 1.0;

            let mut crush_update = false;
            if crush > 0.0 {
                crush_phase = crush_phase.wrapping_add(1);
                crush_update = crush_phase % 2 == 0;
            }

            for channel_idx in 0..channel_count {
                let input = track_output[channel_idx][sample_idx];
                noise_lp[channel_idx] += (noise_sample - noise_lp[channel_idx]) * noise_alpha;
                let mut sample = input * drive_gain;
                sample = sample.tanh();
                let comp_amount = compress * 4.0;
                if comp_amount > 0.0 {
                    sample = sample / (1.0 + comp_amount * sample.abs());
                }
                if crush > 0.0 {
                    if crush_update {
                        crush_hold[channel_idx] = sample;
                    }
                    sample = (crush_hold[channel_idx] / crush_step).round() * crush_step;
                }
                tilt_lp[channel_idx] += (sample - tilt_lp[channel_idx]) * tilt_alpha;
                let low = tilt_lp[channel_idx];
                let high = sample - low;
                let tilted = low * tilt_low_gain + high * tilt_high_gain;
                let noisy = tilted + noise_lp[channel_idx] * noise * noise_env;
                let wet_sample = noisy * post_gain_lin;
                track_output[channel_idx][sample_idx] =
                    input * (1.0 - wet) + wet_sample * wet;
            }
        }

        for channel_idx in 0..channel_count {
            track
                .texture_noise_lp[channel_idx]
                .store(noise_lp[channel_idx].to_bits(), Ordering::Relaxed);
            track
                .texture_tilt_lp[channel_idx]
                .store(tilt_lp[channel_idx].to_bits(), Ordering::Relaxed);
            track
                .texture_crush_hold[channel_idx]
                .store(crush_hold[channel_idx].to_bits(), Ordering::Relaxed);
        }

        track
            .texture_noise_env
            .store(noise_env.to_bits(), Ordering::Relaxed);
        track.texture_noise_rng.store(noise_rng, Ordering::Relaxed);
        track.texture_crush_phase.store(crush_phase, Ordering::Relaxed);
    }

    fn process_track_reflect(
        track: &Track,
        track_output: &mut [Vec<f32>],
        num_buffer_samples: usize,
        tempo: f32,
    ) {
        if !track.reflect_enabled.load(Ordering::Relaxed) {
            return;
        }
        if num_buffer_samples == 0 || track_output.is_empty() {
            return;
        }

        let sr = track.sample_rate.load(Ordering::Relaxed).max(1) as f32;
        let channel_count = track_output.len().min(2);

        let target_delay =
            f32::from_bits(track.reflect_delay.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_time =
            f32::from_bits(track.reflect_time.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let time_mode = track.reflect_time_mode.load(Ordering::Relaxed);
        let target_reverb =
            f32::from_bits(track.reflect_reverb.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_size =
            f32::from_bits(track.reflect_size.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_feedback =
            f32::from_bits(track.reflect_feedback.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_spread =
            f32::from_bits(track.reflect_spread.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_damp =
            f32::from_bits(track.reflect_damp.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_decay =
            f32::from_bits(track.reflect_decay.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let target_post_gain =
            f32::from_bits(track.reflect_post_gain.load(Ordering::Relaxed)).clamp(0.0, 1.0);

        let delay_mix = smooth_param(
            f32::from_bits(track.reflect_delay_smooth.load(Ordering::Relaxed)),
            target_delay,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let time_norm = if time_mode == 3 {
            smooth_param(
                f32::from_bits(track.reflect_time_smooth.load(Ordering::Relaxed)),
                target_time,
                num_buffer_samples,
                sr,
            )
        } else {
            target_time
        }
        .clamp(0.0, 1.0);
        let reverb_mix = smooth_param(
            f32::from_bits(track.reflect_reverb_smooth.load(Ordering::Relaxed)),
            target_reverb,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let size = smooth_param(
            f32::from_bits(track.reflect_size_smooth.load(Ordering::Relaxed)),
            target_size,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let feedback = smooth_param(
            f32::from_bits(track.reflect_feedback_smooth.load(Ordering::Relaxed)),
            target_feedback,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let spread = smooth_param(
            f32::from_bits(track.reflect_spread_smooth.load(Ordering::Relaxed)),
            target_spread,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let damp = smooth_param(
            f32::from_bits(track.reflect_damp_smooth.load(Ordering::Relaxed)),
            target_damp,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let decay = smooth_param(
            f32::from_bits(track.reflect_decay_smooth.load(Ordering::Relaxed)),
            target_decay,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);
        let post_gain = smooth_param(
            f32::from_bits(track.reflect_post_gain_smooth.load(Ordering::Relaxed)),
            target_post_gain,
            num_buffer_samples,
            sr,
        )
        .clamp(0.0, 1.0);

        track
            .reflect_delay_smooth
            .store(delay_mix.to_bits(), Ordering::Relaxed);
        track
            .reflect_time_smooth
            .store(time_norm.to_bits(), Ordering::Relaxed);
        track
            .reflect_reverb_smooth
            .store(reverb_mix.to_bits(), Ordering::Relaxed);
        track
            .reflect_size_smooth
            .store(size.to_bits(), Ordering::Relaxed);
        track
            .reflect_feedback_smooth
            .store(feedback.to_bits(), Ordering::Relaxed);
        track
            .reflect_spread_smooth
            .store(spread.to_bits(), Ordering::Relaxed);
        track
            .reflect_damp_smooth
            .store(damp.to_bits(), Ordering::Relaxed);
        track
            .reflect_decay_smooth
            .store(decay.to_bits(), Ordering::Relaxed);
        track
            .reflect_post_gain_smooth
            .store(post_gain.to_bits(), Ordering::Relaxed);

        let mut delay_buffers = if let Some(buffers) = track.reflect_delay_buffer.try_lock() {
            buffers
        } else {
            return;
        };
        let mut comb_buffers =
            if let Some(buffers) = track.reflect_reverb_comb_buffers.try_lock() {
                buffers
            } else {
                return;
            };
        let mut ap_buffers =
            if let Some(buffers) = track.reflect_reverb_ap_buffers.try_lock() {
                buffers
            } else {
                return;
            };

        if track.reflect_clear.swap(false, Ordering::Relaxed) {
            for channel in delay_buffers.iter_mut() {
                channel.fill(0.0);
            }
            for channel in comb_buffers.iter_mut() {
                for comb in channel.iter_mut() {
                    comb.fill(0.0);
                }
            }
            for channel in ap_buffers.iter_mut() {
                for ap in channel.iter_mut() {
                    ap.fill(0.0);
                }
            }
            track.reflect_delay_write_pos.store(0, Ordering::Relaxed);
            for idx in 0..track.reflect_reverb_comb_pos.len() {
                track.reflect_reverb_comb_pos[idx].store(0, Ordering::Relaxed);
            }
            for idx in 0..track.reflect_reverb_ap_pos.len() {
                track.reflect_reverb_ap_pos[idx].store(0, Ordering::Relaxed);
            }
            for channel in 0..2 {
                track
                    .reflect_damp_state_delay[channel]
                    .store(0.0f32.to_bits(), Ordering::Relaxed);
                track
                    .reflect_damp_state_reverb[channel]
                    .store(0.0f32.to_bits(), Ordering::Relaxed);
            }
        }

        let delay_len = delay_buffers[0].len();
        if delay_len < 2 {
            return;
        }

        let delay_seconds = reflect_time_seconds(time_norm, time_mode, tempo);
        let mut delay_samples = (delay_seconds * sr).round() as usize;
        delay_samples = delay_samples.clamp(1, delay_len.saturating_sub(1));

        let size_scale =
            REFLECT_REVERB_MIN_SCALE + size * (REFLECT_REVERB_MAX_SCALE - REFLECT_REVERB_MIN_SCALE);
        let mut comb_lens = [0usize; 4];
        for i in 0..4 {
            let len = (REFLECT_REVERB_COMB_BASE[i] as f32 * (sr / 44_100.0) * size_scale)
                .round() as usize;
            let max_len = comb_buffers[0][i].len().saturating_sub(1).max(1);
            comb_lens[i] = len.clamp(1, max_len);
        }
        let mut ap_lens = [0usize; 2];
        for i in 0..2 {
            let len = (REFLECT_REVERB_AP_BASE[i] as f32 * (sr / 44_100.0) * size_scale)
                .round() as usize;
            let max_len = ap_buffers[0][i].len().saturating_sub(1).max(1);
            ap_lens[i] = len.clamp(1, max_len);
        }

        let damp_cutoff = 200.0 + (1.0 - damp) * 12_000.0;
        let damp_alpha = 1.0 - (-2.0 * PI * damp_cutoff / sr).exp();

        let feedback_curve = feedback.powf(1.4);
        let decay_curve = decay.powf(1.4);
        let mut feedback_amt = (feedback_curve * 0.98).clamp(0.0, 0.98);
        let mut decay_amt = (decay_curve * 0.98).clamp(0.0, 0.98);
        let freeze = track.reflect_freeze.load(Ordering::Relaxed);
        if freeze {
            feedback_amt = 0.995;
            decay_amt = 0.995;
        }
        let comb_feedback = 0.2 + decay_amt * 0.78;
        let wet_mix = (delay_mix + reverb_mix).clamp(0.0, 1.0);
        let dry_mix = 1.0 - wet_mix;
        let post_gain_lin = post_gain * 2.0;

        let mut write_pos =
            (track.reflect_delay_write_pos.load(Ordering::Relaxed) as usize) % delay_len;
        let mut comb_pos = [[0usize; 4]; 2];
        let mut ap_pos = [[0usize; 2]; 2];
        for ch in 0..2 {
            for i in 0..4 {
                let idx = ch * 4 + i;
                comb_pos[ch][i] =
                    (track.reflect_reverb_comb_pos[idx].load(Ordering::Relaxed) as usize)
                        % comb_lens[i];
            }
            for i in 0..2 {
                let idx = ch * 2 + i;
                ap_pos[ch][i] =
                    (track.reflect_reverb_ap_pos[idx].load(Ordering::Relaxed) as usize)
                        % ap_lens[i];
            }
        }

        let mut damp_delay = [0.0f32; 2];
        let mut damp_reverb = [0.0f32; 2];
        for ch in 0..2 {
            damp_delay[ch] =
                f32::from_bits(track.reflect_damp_state_delay[ch].load(Ordering::Relaxed));
            damp_reverb[ch] =
                f32::from_bits(track.reflect_damp_state_reverb[ch].load(Ordering::Relaxed));
        }

        for sample_idx in 0..num_buffer_samples {
            let read_pos = if write_pos >= delay_samples {
                write_pos - delay_samples
            } else {
                delay_len + write_pos - delay_samples
            };

            let mut delay_wet = [0.0f32; 2];
            let mut reverb_wet = [0.0f32; 2];
            for ch in 0..channel_count {
                let input = track_output[ch][sample_idx];
                let delay_out = delay_buffers[ch][read_pos];
                let fb = delay_out * feedback_amt;
                damp_delay[ch] += (fb - damp_delay[ch]) * damp_alpha;
                let delay_in = if freeze {
                    damp_delay[ch]
                } else {
                    input + damp_delay[ch]
                };
                delay_buffers[ch][write_pos] = delay_in;

                let reverb_in = input + delay_out * delay_mix;
                let mut comb_sum = 0.0f32;
                for i in 0..4 {
                    let pos = comb_pos[ch][i];
                    let buf = &mut comb_buffers[ch][i];
                    let comb_out = buf[pos];
                    let comb_fb = comb_out * comb_feedback;
                    damp_reverb[ch] += (comb_fb - damp_reverb[ch]) * damp_alpha;
                    let comb_in = if freeze {
                        damp_reverb[ch]
                    } else {
                        reverb_in + damp_reverb[ch]
                    };
                    buf[pos] = comb_in;
                    comb_sum += comb_out;
                    comb_pos[ch][i] = (pos + 1) % comb_lens[i];
                }

                let mut ap_signal = comb_sum * 0.25;
                for i in 0..2 {
                    let pos = ap_pos[ch][i];
                    let buf = &mut ap_buffers[ch][i];
                    let ap_out = buf[pos];
                    let ap_feedback = 0.7;
                    let ap_in = ap_signal + (-ap_feedback) * ap_out;
                    let ap_res = ap_out + ap_feedback * ap_in;
                    buf[pos] = ap_in;
                    ap_signal = ap_res;
                    ap_pos[ch][i] = (pos + 1) % ap_lens[i];
                }

                delay_wet[ch] = delay_out * delay_mix;
                reverb_wet[ch] = ap_signal * reverb_mix;
            }

            let total_mix = delay_mix + reverb_mix;
            let wet_scale = if total_mix > 1.0 {
                1.0 / total_mix
            } else {
                1.0
            };
            for ch in 0..channel_count {
                delay_wet[ch] *= wet_scale;
                reverb_wet[ch] *= wet_scale;
            }

            if channel_count == 2 {
                if spread <= 0.5 {
                    let pingpong = spread / 0.5;
                    let dl = delay_wet[0];
                    let dr = delay_wet[1];
                    delay_wet[0] = dl * (1.0 - pingpong) + dr * pingpong;
                    delay_wet[1] = dr * (1.0 - pingpong) + dl * pingpong;
                } else {
                    let diffusion = (spread - 0.5) / 0.5;
                    let mid = (reverb_wet[0] + reverb_wet[1]) * 0.5;
                    let side = (reverb_wet[0] - reverb_wet[1]) * 0.5;
                    let spread_gain = 1.0 + diffusion;
                    reverb_wet[0] = mid + side * spread_gain;
                    reverb_wet[1] = mid - side * spread_gain;
                }
            }

            for ch in 0..channel_count {
                let input = track_output[ch][sample_idx];
                let wet = delay_wet[ch] + reverb_wet[ch];
                track_output[ch][sample_idx] =
                    (input * dry_mix + wet) * post_gain_lin;
            }

            write_pos += 1;
            if write_pos >= delay_len {
                write_pos = 0;
            }
        }

        track
            .reflect_delay_write_pos
            .store(write_pos as u32, Ordering::Relaxed);
        for ch in 0..2 {
            track
                .reflect_damp_state_delay[ch]
                .store(damp_delay[ch].to_bits(), Ordering::Relaxed);
            track
                .reflect_damp_state_reverb[ch]
                .store(damp_reverb[ch].to_bits(), Ordering::Relaxed);
            for i in 0..4 {
                let idx = ch * 4 + i;
                track.reflect_reverb_comb_pos[idx]
                    .store(comb_pos[ch][i] as u32, Ordering::Relaxed);
            }
            for i in 0..2 {
                let idx = ch * 2 + i;
                track.reflect_reverb_ap_pos[idx]
                    .store(ap_pos[ch][i] as u32, Ordering::Relaxed);
            }
        }
    }
}

impl Plugin for TLBX1 {
    const NAME: &'static str = "TLBX-1";
    const VENDOR: &'static str = "Zencoder";
    const URL: &'static str = "https://example.com";
    const EMAIL: &'static str = "info@example.com";

    const VERSION: &'static str = env!("CARGO_PKG_VERSION");

    const AUDIO_IO_LAYOUTS: &'static [AudioIOLayout] = &[
        AudioIOLayout {
            // Input-enabled layout for recording/monitoring.
            main_input_channels: NonZeroU32::new(2),
            main_output_channels: NonZeroU32::new(2),
            ..AudioIOLayout::const_default()
        },
        AudioIOLayout {
            // Generator-style layout.
            main_input_channels: None,
            main_output_channels: NonZeroU32::new(2),
            ..AudioIOLayout::const_default()
        },
    ];

    const MIDI_INPUT: MidiConfig = MidiConfig::None;
    const MIDI_OUTPUT: MidiConfig = MidiConfig::None;

    const SAMPLE_ACCURATE_AUTOMATION: bool = true;

    type SysExMessage = ();
    type BackgroundTask = TLBX1Task;

    fn initialize(
        &mut self,
        _audio_io_layout: &AudioIOLayout,
        buffer_config: &BufferConfig,
        _context: &mut impl InitContext<Self>,
    ) -> bool {
        self.sample_rate.store(buffer_config.sample_rate as u32, Ordering::Relaxed);
        self.track_buffer = vec![vec![0.0; buffer_config.max_buffer_size as usize]; 2];
        true
    }

    fn params(&self) -> Arc<dyn Params> {
        self.params.clone()
    }

    fn editor(&mut self, async_executor: AsyncExecutor<Self>) -> Option<Box<dyn Editor>> {
        Some(Box::new(SlintEditor {
            params: self.params.clone(),
            tracks: self.tracks.clone(),
            master_meters: self.master_meters.clone(),
            visualizer: self.visualizer.clone(),
            global_tempo: self.global_tempo.clone(),
            follow_host_tempo: self.follow_host_tempo.clone(),
            metronome_enabled: self.metronome_enabled.clone(),
            metronome_count_in_ticks: self.metronome_count_in_ticks.clone(),
            metronome_count_in_playback: self.metronome_count_in_playback.clone(),
            metronome_count_in_record: self.metronome_count_in_record.clone(),
            async_executor,
            pending_project_params: self.pending_project_params.clone(),
            animate_library: self.animate_library.clone(),
        }))
    }

    fn task_executor(&mut self) -> TaskExecutor<Self> {
        let tracks = self.tracks.clone();
        let global_tempo = self.global_tempo.clone();
        let params = self.params.clone();
        let pending_project_params = self.pending_project_params.clone();
        Box::new(move |task| match task {
            TLBX1Task::LoadSample(track_idx, path) => {
                if track_idx >= NUM_TRACKS {
                    return;
                }
                
                match load_media_file(&path) {
                    Ok((new_samples, sample_rate, video)) => {
                        let mut samples = tracks[track_idx].samples.lock();
                        let mut summary = tracks[track_idx].waveform_summary.lock();
                        let mut sample_path = tracks[track_idx].sample_path.lock();
                        let mut video_cache = tracks[track_idx].video_cache.lock();

                        *samples = new_samples;
                        *sample_path = Some(path.clone());
                        tracks[track_idx]
                            .sample_rate
                            .store(sample_rate, Ordering::Relaxed);

                        if let Some(video) = video {
                            tracks[track_idx]
                                .video_enabled
                                .store(true, Ordering::Relaxed);
                            tracks[track_idx]
                                .video_width
                                .store(video.width, Ordering::Relaxed);
                            tracks[track_idx]
                                .video_height
                                .store(video.height, Ordering::Relaxed);
                            tracks[track_idx]
                                .video_fps
                                .store(video.fps.to_bits(), Ordering::Relaxed);
                            *video_cache = Some(video);
                            tracks[track_idx]
                                .video_cache_id
                                .fetch_add(1, Ordering::Relaxed);
                        } else {
                            tracks[track_idx]
                                .video_enabled
                                .store(false, Ordering::Relaxed);
                            tracks[track_idx]
                                .video_width
                                .store(0, Ordering::Relaxed);
                            tracks[track_idx]
                                .video_height
                                .store(0, Ordering::Relaxed);
                            tracks[track_idx]
                                .video_fps
                                .store(0.0f32.to_bits(), Ordering::Relaxed);
                            *video_cache = None;
                            tracks[track_idx]
                                .video_cache_id
                                .fetch_add(1, Ordering::Relaxed);
                        }

                        if !samples.is_empty() {
                            calculate_waveform_summary(&samples[0], &mut summary);
                        } else {
                            summary.fill(0.0);
                        }

                        nih_log!("Loaded media: {:?}", path);
                    }
                    Err(e) => {
                        tracks[track_idx]
                            .video_enabled
                            .store(false, Ordering::Relaxed);
                        tracks[track_idx]
                            .video_cache_id
                            .fetch_add(1, Ordering::Relaxed);
                        *tracks[track_idx].video_cache.lock() = None;
                        nih_log!("Failed to load media: {:?}", e);
                    }
                }
            }
            TLBX1Task::LoadSyndrmSample {
                track_idx,
                channel_idx,
                path,
            } => {
                if track_idx >= NUM_TRACKS || channel_idx >= SYNDRM_SAMPLE_CHANNELS {
                    return;
                }

                match load_media_file(&path) {
                    Ok((new_samples, sample_rate, _video)) => {
                        let sample_len = new_samples.get(0).map(|ch| ch.len()).unwrap_or(0);
                        if let Some(mut guard) = tracks[track_idx].samp_samples[channel_idx].try_lock()
                        {
                            *guard = Some(Arc::new(new_samples));
                        }
                        if let Some(mut guard) = tracks[track_idx]
                            .samp_sample_path[channel_idx]
                            .try_lock()
                        {
                            *guard = Some(path.to_string_lossy().to_string());
                        }
                        tracks[track_idx].samp_sample_rate[channel_idx]
                            .store(sample_rate, Ordering::Relaxed);
                        tracks[track_idx].samp_sample_len[channel_idx]
                            .store(sample_len as u32, Ordering::Relaxed);
                        tracks[track_idx].samp_playhead[channel_idx]
                            .store(0.0f32.to_bits(), Ordering::Relaxed);
                        tracks[track_idx].samp_env[channel_idx]
                            .store(0.0f32.to_bits(), Ordering::Relaxed);
                        tracks[track_idx].samp_attack_remaining[channel_idx]
                            .store(0, Ordering::Relaxed);
                        tracks[track_idx].samp_decay_remaining[channel_idx]
                            .store(0, Ordering::Relaxed);
                        nih_log!("Loaded SynDRM sample: {:?}", path);
                    }
                    Err(e) => {
                        nih_log!("Failed to load SynDRM sample: {:?}", e);
                    }
                }
            }
            TLBX1Task::SaveProject {
                path,
                title,
                description,
            } => {
                let tempo = f32::from_bits(global_tempo.load(Ordering::Relaxed));
                if let Err(err) = save_project(&tracks, tempo, &params, &title, &description, &path) {
                    nih_log!("Failed to save project: {:?}", err);
                } else {
                    nih_log!("Saved project: {:?}", path);
                }
            }
            TLBX1Task::LoadProject(path) => {
                if let Err(err) = load_project(
                    &tracks,
                    &global_tempo,
                    &params,
                    &pending_project_params,
                    &path,
                ) {
                    nih_log!("Failed to load project: {:?}", err);
                } else {
                    nih_log!("Loaded project: {:?}", path);
                }
            }
            TLBX1Task::ExportProjectZip {
                path,
                title,
                description,
            } => {
                let tempo = f32::from_bits(global_tempo.load(Ordering::Relaxed));
                if let Err(err) =
                    export_project_as_zip(&tracks, tempo, &params, &title, &description, &path)
                {
                    nih_log!("Failed to export project: {:?}", err);
                } else {
                    nih_log!("Exported project zip: {:?}", path);
                }
            }
        })
    }

    fn process(
        &mut self,
        buffer: &mut Buffer,
        _aux: &mut AuxiliaryBuffers,
        context: &mut impl ProcessContext<Self>,
    ) -> ProcessStatus {
        let host_playing = context.transport().playing;
        if self.last_host_playing && !host_playing {
            for track in self.tracks.iter() {
                track.void_enabled.store(false, Ordering::Relaxed);
            }
        }
        self.last_host_playing = host_playing;

        let mut keep_alive = false;
        let mut global_tempo =
            f32::from_bits(self.global_tempo.load(Ordering::Relaxed)).clamp(20.0, 240.0);
        if !global_tempo.is_finite() {
            global_tempo = 120.0;
            self.global_tempo
                .store(global_tempo.to_bits(), Ordering::Relaxed);
        }
        if self.follow_host_tempo.load(Ordering::Relaxed) {
            if let Some(tempo) = context.transport().tempo {
                let tempo = tempo as f32;
                if tempo.is_finite() {
                    global_tempo = tempo.clamp(20.0, 240.0);
                    self.global_tempo
                        .store(global_tempo.to_bits(), Ordering::Relaxed);
                }
            }
        }
        let mut master_sr = context.transport().sample_rate;
        if !master_sr.is_finite() || master_sr <= 0.0 {
            master_sr = self.sample_rate.load(Ordering::Relaxed).max(1) as f32;
        }
        self.sample_rate.store(master_sr as u32, Ordering::Relaxed);
        let mut samples_per_step = (master_sr * 60.0) / (global_tempo * 4.0);
        if !samples_per_step.is_finite() || samples_per_step <= 0.0 {
            samples_per_step = (master_sr * 60.0) / (120.0 * 4.0);
        }
        let mut master_step = self.master_step_index;
        let mut master_phase = self.master_step_phase;
        let mut master_step_count = self.master_step_count;
        if samples_per_step > 0.0 {
            while master_phase >= samples_per_step {
                master_phase -= samples_per_step;
                master_step = (master_step + 1).rem_euclid(16);
                master_step_count += 1;
            }
        }


        let buffer_samples = buffer.samples() as u32;
        let mut any_pending = false;
        if buffer_samples > 0 {
            let mut play_remaining = None;
            for track in self.tracks.iter() {
                if track.pending_play.load(Ordering::Relaxed) {
                    play_remaining = Some(track.count_in_remaining.load(Ordering::Relaxed));
                    break;
                }
            }
            if let Some(remaining) = play_remaining {
                any_pending = true;
                keep_alive = true;
                let new_remaining = remaining.saturating_sub(buffer_samples);
                for track in self.tracks.iter() {
                    if !track.pending_play.load(Ordering::Relaxed) {
                        continue;
                    }
                    if remaining == 0 {
                        track.is_playing.store(true, Ordering::Relaxed);
                        track.pending_play.store(false, Ordering::Relaxed);
                        track.count_in_remaining.store(0, Ordering::Relaxed);
                    } else {
                        track
                            .count_in_remaining
                            .store(new_remaining, Ordering::Relaxed);
                    }
                }
            }

            for track in self.tracks.iter() {
                let pending_record = track.pending_record.load(Ordering::Relaxed);
                if !pending_record {
                    continue;
                }
                any_pending = true;
                keep_alive = true;
                let remaining = track.count_in_remaining.load(Ordering::Relaxed);
                if remaining == 0 {
                    track.is_recording.store(true, Ordering::Relaxed);
                    track.pending_record.store(false, Ordering::Relaxed);
                } else {
                    let new_remaining = remaining.saturating_sub(buffer_samples);
                    track
                        .count_in_remaining
                        .store(new_remaining, Ordering::Relaxed);
                }
            }
        }

        // Handle recording for all tracks
        for track in self.tracks.iter() {
            if track.is_recording.load(Ordering::Relaxed) {
                keep_alive = true;
            }
            if track.is_recording.load(Ordering::Relaxed) {
                if let Some(mut samples) = track.samples.try_lock() {
                    let overdub = track.tape_overdub.load(Ordering::Relaxed);
                    let sos = f32::from_bits(track.tape_sos.load(Ordering::Relaxed))
                        .clamp(0.0, 1.0);
                    // Ensure we have enough channels
                    while samples.len() < buffer.channels() {
                        samples.push(vec![]);
                    }

                    let input = buffer.as_slice_immutable();
        let record_sample_rate = track.sample_rate.load(Ordering::Relaxed).max(1) as f32;
        let target_loop_start =
            f32::from_bits(track.loop_start.load(Ordering::Relaxed)).clamp(0.0, 0.999);
        let target_loop_length =
            f32::from_bits(track.loop_length.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let smooth_loop_start = smooth_param(
            f32::from_bits(track.loop_start_smooth.load(Ordering::Relaxed)),
            target_loop_start,
            buffer.samples(),
            record_sample_rate,
        );
        let smooth_loop_length = smooth_param(
            f32::from_bits(track.loop_length_smooth.load(Ordering::Relaxed)),
            target_loop_length,
            buffer.samples(),
            record_sample_rate,
        );
        track
            .loop_start_smooth
            .store(smooth_loop_start.to_bits(), Ordering::Relaxed);
        track
            .loop_length_smooth
            .store(smooth_loop_length.to_bits(), Ordering::Relaxed);
        let loop_start_norm = smooth_loop_start;
        let loop_length_norm = smooth_loop_length;
                    let record_start = (loop_start_norm * RECORD_MAX_SAMPLES as f32) as usize;
                    let mut record_len =
                        (loop_length_norm * RECORD_MAX_SAMPLES as f32) as usize;
                    if record_len == 0 {
                        record_len = 1;
                    }
                    let record_end = (record_start + record_len).min(RECORD_MAX_SAMPLES);
                    let mut write_pos =
                        f32::from_bits(track.record_pos.load(Ordering::Relaxed))
                            .max(0.0) as usize;
                    if write_pos < record_start || write_pos >= record_end {
                        write_pos = record_start;
                    }
                    for channel_idx in 0..buffer.channels() {
                        let channel_data = &input[channel_idx];
                        let buf = &mut samples[channel_idx];
                        let mut write_idx = write_pos;
                        for sample in channel_data.iter() {
                            if write_idx >= record_end {
                                if overdub {
                                    write_idx = record_start;
                                } else {
                                    track.is_recording.store(false, Ordering::Relaxed);
                                    break;
                                }
                            }
                            if write_idx >= buf.len() {
                                track.is_recording.store(false, Ordering::Relaxed);
                                break;
                            }
                            if overdub {
                                let existing = buf[write_idx];
                                buf[write_idx] = existing * sos + *sample;
                            } else {
                                buf[write_idx] = *sample;
                            }
                            write_idx += 1;
                        }
                        if !track.is_recording.load(Ordering::Relaxed) {
                            break;
                        }
                        write_pos = write_idx;
                    }
                    track
                        .record_pos
                        .store((write_pos as f32).to_bits(), Ordering::Relaxed);
                }
            }
        }

        let any_playing = self
            .tracks
            .iter()
            .any(|track| track.is_playing.load(Ordering::Relaxed));
        let any_engine_clock = self.tracks.iter().any(|track| {
            matches!(
                track.engine_type.load(Ordering::Relaxed),
                2 | 3 | 4 | 5 | 6
            )
        });
        let any_recording = self
            .tracks
            .iter()
            .any(|track| track.is_recording.load(Ordering::Relaxed));
        let mut monitor_level = 0.0;
        for track in self.tracks.iter() {
            if track.tape_monitor.load(Ordering::Relaxed) && !track.is_muted.load(Ordering::Relaxed)
            {
                monitor_level += f32::from_bits(track.level.load(Ordering::Relaxed));
            }
        }
        let monitor_level = monitor_level.clamp(0.0, 1.0);
        let any_monitoring = monitor_level > 0.0;
        if any_monitoring {
            if (monitor_level - 1.0).abs() > f32::EPSILON {
                for channel_samples in buffer.iter_samples() {
                    for sample in channel_samples {
                        *sample *= monitor_level;
                    }
                }
            }
        } else {
            for channel_samples in buffer.iter_samples() {
                for sample in channel_samples {
                    *sample = 0.0;
                }
            }
        }

        // Handle playback for all tracks
        let transport_running = any_playing;
        for track_idx in 0..self.tracks.len() {
            let track = &self.tracks[track_idx];
            let syndrm_dsp = &mut self.syndrm_dsp[track_idx];
            let animate_dsp = &mut self.animate_dsp[track_idx];
            if track.is_recording.load(Ordering::Relaxed) {
                continue;
            }

            let engine_type = track.engine_type.load(Ordering::Relaxed);
            let track_muted = track.is_muted.load(Ordering::Relaxed);
            if engine_type != 0 {
                Self::process_track_modul8(
                    track,
                    buffer.samples(),
                    global_tempo,
                    master_sr,
                    transport_running,
                );
            }
            let should_process =
                transport_running || matches!(engine_type, 2 | 3 | 4 | 5 | 6);
            if !should_process {
                let prev_left =
                    f32::from_bits(track.meter_left.load(Ordering::Relaxed));
                let prev_right =
                    f32::from_bits(track.meter_right.load(Ordering::Relaxed));
                let next_left = smooth_meter(prev_left, 0.0);
                let next_right = smooth_meter(prev_right, 0.0);
                track
                    .meter_left
                    .store(next_left.to_bits(), Ordering::Relaxed);
                track
                    .meter_right
                    .store(next_right.to_bits(), Ordering::Relaxed);
                continue;
            }
            if !transport_running && track_muted {
                let prev_left =
                    f32::from_bits(track.meter_left.load(Ordering::Relaxed));
                let prev_right =
                    f32::from_bits(track.meter_right.load(Ordering::Relaxed));
                let next_left = smooth_meter(prev_left, 0.0);
                let next_right = smooth_meter(prev_right, 0.0);
                track
                    .meter_left
                    .store(next_left.to_bits(), Ordering::Relaxed);
                track
                    .meter_right
                    .store(next_right.to_bits(), Ordering::Relaxed);
                continue;
            }

            keep_alive = true;

            // Clear track buffer
            for channel in self.track_buffer.iter_mut() {
                channel.fill(0.0);
            }

            let mut track_peak_left = 0.0f32;
            let mut track_peak_right = 0.0f32;

            if engine_type == 2 {
                Self::process_animate(
                    track,
                    &mut self.track_buffer,
                    animate_dsp,
                    buffer.samples(),
                    &self.global_tempo,
                    &self.animate_library,
                    master_step,
                    master_phase,
                    samples_per_step,
                    transport_running,
                );
            } else if engine_type == 3 {
                Self::process_syndrm(
                    track,
                    &mut self.track_buffer,
                    syndrm_dsp,
                    buffer.samples(),
                    &self.global_tempo,
                    master_step,
                    master_phase,
                    master_step_count,
                    samples_per_step,
                    master_sr,
                    transport_running,
                );
                let mosaic_active =
                    track.granular_type.load(Ordering::Relaxed) == 1
                        && track.mosaic_enabled.load(Ordering::Relaxed);
                if mosaic_active {
                    if let Some(mut mosaic) = track.mosaic_buffer.try_lock() {
                        if !mosaic.is_empty() && !mosaic[0].is_empty() {
                            let sr = master_sr.max(1.0) as usize;
                            let mosaic_len = (sr * MOSAIC_BUFFER_SECONDS)
                                .min(MOSAIC_BUFFER_SAMPLES)
                                .max(1);
                            let mut mosaic_write_pos =
                                (track.mosaic_write_pos.load(Ordering::Relaxed) as usize)
                                    % mosaic_len;
                            let target_mosaic_sos = f32::from_bits(
                                track.mosaic_sos.load(Ordering::Relaxed),
                            )
                            .clamp(0.0, 1.0);
                            let smooth_mosaic_sos = smooth_param(
                                f32::from_bits(
                                    track.mosaic_sos_smooth.load(Ordering::Relaxed),
                                ),
                                target_mosaic_sos,
                                buffer.samples(),
                                master_sr,
                            );
                            track
                                .mosaic_sos_smooth
                                .store(smooth_mosaic_sos.to_bits(), Ordering::Relaxed);
                            let num_buffer_samples = buffer.samples();
                            let num_channels = self.track_buffer.len().min(mosaic.len());
                            for sample_idx in 0..num_buffer_samples {
                                for channel_idx in 0..num_channels {
                                    let out_value =
                                        self.track_buffer[channel_idx][sample_idx];
                                    let existing = mosaic[channel_idx][mosaic_write_pos];
                                    mosaic[channel_idx][mosaic_write_pos] =
                                        out_value * (1.0 - smooth_mosaic_sos)
                                            + existing * smooth_mosaic_sos;
                                }
                                mosaic_write_pos = (mosaic_write_pos + 1) % mosaic_len;
                            }
                            track
                                .mosaic_write_pos
                                .store(mosaic_write_pos as u32, Ordering::Relaxed);
                        }
                    }
                }
            } else if engine_type == 5 {
                Self::process_fmmi(
                    track,
                    &mut self.track_buffer,
                    buffer.samples(),
                    &self.global_tempo,
                    master_step,
                    master_phase,
                    master_step_count,
                    samples_per_step,
                    master_sr,
                    transport_running,
                    &mut self.fmmi_dsp[track_idx],
                );
                let mosaic_active =
                    track.granular_type.load(Ordering::Relaxed) == 1
                        && track.mosaic_enabled.load(Ordering::Relaxed);
                if mosaic_active {
                    if let Some(mut mosaic) = track.mosaic_buffer.try_lock() {
                        if !mosaic.is_empty() && !mosaic[0].is_empty() {
                            let sr = master_sr.max(1.0) as usize;
                            let mosaic_len = (sr * MOSAIC_BUFFER_SECONDS)
                                .min(MOSAIC_BUFFER_SAMPLES)
                                .max(1);
                            let mut mosaic_write_pos =
                                (track.mosaic_write_pos.load(Ordering::Relaxed) as usize)
                                    % mosaic_len;
                            let target_mosaic_sos = f32::from_bits(
                                track.mosaic_sos.load(Ordering::Relaxed),
                            )
                            .clamp(0.0, 1.0);
                            let smooth_mosaic_sos = smooth_param(
                                f32::from_bits(
                                    track.mosaic_sos_smooth.load(Ordering::Relaxed),
                                ),
                                target_mosaic_sos,
                                buffer.samples(),
                                master_sr,
                            );
                            track
                                .mosaic_sos_smooth
                                .store(smooth_mosaic_sos.to_bits(), Ordering::Relaxed);
                            let num_buffer_samples = buffer.samples();
                            let num_channels = self.track_buffer.len().min(mosaic.len());
                            for sample_idx in 0..num_buffer_samples {
                                for channel_idx in 0..num_channels {
                                    let out_value = self.track_buffer[channel_idx][sample_idx];
                                    let existing = mosaic[channel_idx][mosaic_write_pos];
                                    mosaic[channel_idx][mosaic_write_pos] =
                                        out_value * (1.0 - smooth_mosaic_sos)
                                            + existing * smooth_mosaic_sos;
                                }
                                mosaic_write_pos = (mosaic_write_pos + 1) % mosaic_len;
                            }
                            track
                                .mosaic_write_pos
                                .store(mosaic_write_pos as u32, Ordering::Relaxed);
                        }
                    }
                }
            } else if engine_type == 6 {
                Self::process_monomi(
                    track,
                    &mut self.track_buffer,
                    buffer.samples(),
                    &self.global_tempo,
                    master_step,
                    master_phase,
                    master_step_count,
                    samples_per_step,
                    master_sr,
                    transport_running,
                    &mut self.monomi_dsp[track_idx],
                );
                let mosaic_active =
                    track.granular_type.load(Ordering::Relaxed) == 1
                        && track.mosaic_enabled.load(Ordering::Relaxed);
                if mosaic_active {
                    if let Some(mut mosaic) = track.mosaic_buffer.try_lock() {
                        if !mosaic.is_empty() && !mosaic[0].is_empty() {
                            let sr = master_sr.max(1.0) as usize;
                            let mosaic_len = (sr * MOSAIC_BUFFER_SECONDS)
                                .min(MOSAIC_BUFFER_SAMPLES)
                                .max(1);
                            let mut mosaic_write_pos =
                                (track.mosaic_write_pos.load(Ordering::Relaxed) as usize)
                                    % mosaic_len;
                            let target_mosaic_sos = f32::from_bits(
                                track.mosaic_sos.load(Ordering::Relaxed),
                            )
                            .clamp(0.0, 1.0);
                            let smooth_mosaic_sos = smooth_param(
                                f32::from_bits(
                                    track.mosaic_sos_smooth.load(Ordering::Relaxed),
                                ),
                                target_mosaic_sos,
                                buffer.samples(),
                                master_sr,
                            );
                            track
                                .mosaic_sos_smooth
                                .store(smooth_mosaic_sos.to_bits(), Ordering::Relaxed);
                            let num_buffer_samples = buffer.samples();
                            let num_channels = self.track_buffer.len().min(mosaic.len());
                            for sample_idx in 0..num_buffer_samples {
                                for channel_idx in 0..num_channels {
                                    let out_value = self.track_buffer[channel_idx][sample_idx];
                                    let existing = mosaic[channel_idx][mosaic_write_pos];
                                    mosaic[channel_idx][mosaic_write_pos] =
                                        out_value * (1.0 - smooth_mosaic_sos)
                                            + existing * smooth_mosaic_sos;
                                }
                                mosaic_write_pos = (mosaic_write_pos + 1) % mosaic_len;
                            }
                            track
                                .mosaic_write_pos
                                .store(mosaic_write_pos as u32, Ordering::Relaxed);
                        }
                    }
                }
            } else if engine_type == 4 {
                Self::process_voidseed(
                    track,
                    &mut self.track_buffer,
                    buffer.samples(),
                    &self.global_tempo,
                    master_step,
                    master_phase,
                    samples_per_step,
                    master_sr,
                    &mut self.void_dsp[track_idx],
                );
                let mosaic_active =
                    track.granular_type.load(Ordering::Relaxed) == 1
                        && track.mosaic_enabled.load(Ordering::Relaxed);
                if mosaic_active {
                    if let Some(mut mosaic) = track.mosaic_buffer.try_lock() {
                        if !mosaic.is_empty() && !mosaic[0].is_empty() {
                            let sr = master_sr.max(1.0) as usize;
                            let mosaic_len = (sr * MOSAIC_BUFFER_SECONDS)
                                .min(MOSAIC_BUFFER_SAMPLES)
                                .max(1);
                            let mut mosaic_write_pos =
                                (track.mosaic_write_pos.load(Ordering::Relaxed) as usize)
                                    % mosaic_len;
                            let target_mosaic_sos = f32::from_bits(
                                track.mosaic_sos.load(Ordering::Relaxed),
                            )
                            .clamp(0.0, 1.0);
                            let smooth_mosaic_sos = smooth_param(
                                f32::from_bits(
                                    track.mosaic_sos_smooth.load(Ordering::Relaxed),
                                ),
                                target_mosaic_sos,
                                buffer.samples(),
                                master_sr,
                            );
                            track
                                .mosaic_sos_smooth
                                .store(smooth_mosaic_sos.to_bits(), Ordering::Relaxed);
                            let num_buffer_samples = buffer.samples();
                            let num_channels = self.track_buffer.len().min(mosaic.len());
                            for sample_idx in 0..num_buffer_samples {
                                for channel_idx in 0..num_channels {
                                    let out_value = self.track_buffer[channel_idx][sample_idx];
                                    let existing = mosaic[channel_idx][mosaic_write_pos];
                                    mosaic[channel_idx][mosaic_write_pos] =
                                        out_value * (1.0 - smooth_mosaic_sos)
                                            + existing * smooth_mosaic_sos;
                                }
                                mosaic_write_pos = (mosaic_write_pos + 1) % mosaic_len;
                            }
                            track
                                .mosaic_write_pos
                                .store(mosaic_write_pos as u32, Ordering::Relaxed);
                        }
                    }
                }
            } else if transport_running {
                if let Some(samples) = track.samples.try_lock() {
                    if samples.is_empty() || samples[0].is_empty() {
                        track.is_playing.store(false, Ordering::Relaxed);
                        continue;
                    }

                    let num_samples = samples[0].len();
                    let num_channels = samples.len();
                    let num_buffer_samples = buffer.samples();
                    let mosaic_active =
                        track.granular_type.load(Ordering::Relaxed) == 1;
                    let mut mosaic_buffer = if mosaic_active {
                        track.mosaic_buffer.try_lock()
                    } else {
                        None
                    };
                    let mosaic_len = if mosaic_active {
                        let sr = track.sample_rate.load(Ordering::Relaxed).max(1) as usize;
                        let len = (sr * MOSAIC_BUFFER_SECONDS).min(MOSAIC_BUFFER_SAMPLES);
                        len.max(1)
                    } else {
                        0
                    };
                    let mut mosaic_write_pos = if mosaic_active && mosaic_len > 0 {
                        (track.mosaic_write_pos.load(Ordering::Relaxed) as usize) % mosaic_len
                    } else {
                        0
                    };
                    let target_mosaic_sos =
                        f32::from_bits(track.mosaic_sos.load(Ordering::Relaxed)).clamp(0.0, 1.0);
                    let smooth_mosaic_sos = smooth_param(
                        f32::from_bits(track.mosaic_sos_smooth.load(Ordering::Relaxed)),
                        target_mosaic_sos,
                        num_buffer_samples,
                        track.sample_rate.load(Ordering::Relaxed).max(1) as f32,
                    );
                    track
                        .mosaic_sos_smooth
                        .store(smooth_mosaic_sos.to_bits(), Ordering::Relaxed);
                    let track_level =
                        f32::from_bits(track.level.load(Ordering::Relaxed));
                    let tape_speed =
                        f32::from_bits(track.tape_speed.load(Ordering::Relaxed)).clamp(-4.0, 4.0);
                    let tape_tempo = global_tempo.max(1.0);
                    let tape_rate_mode = track.tape_rate_mode.load(Ordering::Relaxed);
                    let tape_freeze = track.tape_freeze.load(Ordering::Relaxed);
                    let tape_reverse = track.tape_reverse.load(Ordering::Relaxed);
                    let tape_keylock = track.tape_keylock.load(Ordering::Relaxed);
                    let mut smooth_speed =
                        f32::from_bits(track.tape_speed_smooth.load(Ordering::Relaxed));
                    let target_level = if track_muted { 0.0 } else { track_level };
                    let mut smooth_level =
                        f32::from_bits(track.level_smooth.load(Ordering::Relaxed));
                    let level_step = if num_buffer_samples > 0 {
                        (target_level - smooth_level) / num_buffer_samples as f32
                    } else {
                        0.0
                    };
                    let loop_enabled = track.loop_enabled.load(Ordering::Relaxed);
                    let loop_mode = track.loop_mode.load(Ordering::Relaxed);
                    let keylock_enabled = tape_keylock && loop_mode != 1 && loop_mode != 4;
                    let loop_active = loop_enabled && loop_mode != 2;
                    let track_sample_rate =
                        track.sample_rate.load(Ordering::Relaxed).max(1) as f32;
                    let target_loop_start =
                        f32::from_bits(track.loop_start.load(Ordering::Relaxed))
                            .clamp(0.0, 0.999);
                    let target_loop_length =
                        f32::from_bits(track.loop_length.load(Ordering::Relaxed))
                            .clamp(0.0, 1.0);
                    let target_loop_xfade =
                        f32::from_bits(track.loop_xfade.load(Ordering::Relaxed))
                            .clamp(0.0, 0.5);
                    let smooth_loop_start = smooth_param(
                        f32::from_bits(track.loop_start_smooth.load(Ordering::Relaxed)),
                        target_loop_start,
                        num_buffer_samples,
                        track_sample_rate,
                    );
                    let smooth_loop_length = smooth_param(
                        f32::from_bits(track.loop_length_smooth.load(Ordering::Relaxed)),
                        target_loop_length,
                        num_buffer_samples,
                        track_sample_rate,
                    );
                    let smooth_loop_xfade = smooth_param(
                        f32::from_bits(track.loop_xfade_smooth.load(Ordering::Relaxed)),
                        target_loop_xfade,
                        num_buffer_samples,
                        track_sample_rate,
                    );
                    track
                        .loop_start_smooth
                        .store(smooth_loop_start.to_bits(), Ordering::Relaxed);
                    track
                        .loop_length_smooth
                        .store(smooth_loop_length.to_bits(), Ordering::Relaxed);
                    track
                        .loop_xfade_smooth
                        .store(smooth_loop_xfade.to_bits(), Ordering::Relaxed);
                    let loop_start_norm = smooth_loop_start;
                    let loop_length_norm = smooth_loop_length;
                    let loop_xfade_norm = smooth_loop_xfade;
                    let output = buffer.as_slice();
                    let mut play_pos = f32::from_bits(track.play_pos.load(Ordering::Relaxed));
                    let mut keylock_phase =
                        f32::from_bits(track.keylock_phase.load(Ordering::Relaxed));
                    let mut keylock_grain_a =
                        f32::from_bits(track.keylock_grain_a.load(Ordering::Relaxed));
                    let mut keylock_grain_b =
                        f32::from_bits(track.keylock_grain_b.load(Ordering::Relaxed));

                    let target_rotate =
                        f32::from_bits(track.tape_rotate.load(Ordering::Relaxed)).clamp(0.0, 1.0);
                    let smooth_rotate = smooth_param(
                        f32::from_bits(track.tape_rotate_smooth.load(Ordering::Relaxed)),
                        target_rotate,
                        num_buffer_samples,
                        track_sample_rate,
                    );
                    track
                        .tape_rotate_smooth
                        .store(smooth_rotate.to_bits(), Ordering::Relaxed);
                    let rotate_norm = smooth_rotate;
                    let reverse_active = tape_reverse || loop_mode == 3;
                    let rotate_offset = (rotate_norm * num_samples as f32) as usize;
                    let loop_start = if reverse_active {
                        let base_end =
                            ((1.0 - loop_start_norm) * num_samples as f32) as usize;
                        let loop_end = (base_end + rotate_offset).min(num_samples);
                        let mut loop_len = (loop_length_norm * num_samples as f32) as usize;
                        if loop_len == 0 {
                            loop_len = loop_end.max(1);
                        }
                        loop_end.saturating_sub(loop_len)
                    } else {
                        let base_start = (loop_start_norm * num_samples as f32) as usize;
                        (base_start + rotate_offset) % num_samples.max(1)
                    };
                    let mut loop_len = (loop_length_norm * num_samples as f32) as usize;
                    if loop_len == 0 {
                        loop_len = num_samples.saturating_sub(loop_start).max(1);
                    }
                    let loop_end = (loop_start + loop_len).min(num_samples);
                    let loop_len = loop_end.saturating_sub(loop_start).max(1);
                    let mut xfade_samples = (loop_xfade_norm * loop_len as f32) as usize;
                    if xfade_samples * 2 > loop_len {
                        xfade_samples = loop_len / 2;
                    }
                    let mut direction = match loop_mode {
                        1 => track.loop_dir.load(Ordering::Relaxed),
                        3 => -1,
                        _ => 1,
                    };
                    if tape_reverse {
                        direction *= -1;
                    }
                    if tape_rate_mode == 1 && tape_speed < 0.0 {
                        direction *= -1;
                    }
                    let rate_factor = match tape_rate_mode {
                        1 => 1.0,
                        2 => 1.5,
                        3 => 2.0 / 3.0,
                        _ => 0.0,
                    };
                    let (tempo_speed, straight_bars) = match tape_rate_mode {
                        0 => (tape_speed, None),
                        1 => {
                            let divisions = [
                                1.0 / 64.0,
                                1.0 / 32.0,
                                1.0 / 16.0,
                                1.0 / 8.0,
                                1.0 / 4.0,
                                1.0 / 2.0,
                                1.0,
                                2.0,
                                4.0,
                                8.0,
                                16.0,
                            ];
                            let normalized = (tape_speed.abs() / 4.0).clamp(0.0, 1.0);
                            let idx = ((divisions.len() - 1) as f32 * normalized).round() as usize;
                            let bars = divisions[idx];
                            let seconds_per_bar = (60.0 / tape_tempo) * 4.0;
                            let target_seconds = (bars * seconds_per_bar).max(0.001);
                            let speed = loop_len as f32
                                / (target_seconds
                                    * track.sample_rate.load(Ordering::Relaxed).max(1) as f32);
                            (speed, Some(bars))
                        }
                        _ => ((tape_tempo / 120.0) * rate_factor, None),
                    };
                    let sync_requested =
                        track.tape_sync_requested.swap(false, Ordering::Relaxed);
                    let use_straight_lock = tape_rate_mode == 1
                        && straight_bars.is_some()
                        && samples_per_step > 0.0;
                    let mut straight_phase = master_phase;
                    let mut straight_step_count = master_step_count;
                    if sync_requested && use_straight_lock && loop_len > 0 {
                        let bars = straight_bars.unwrap_or(1.0f32).max(0.000_01f32);
                        let step_progress =
                            straight_step_count as f32 + (straight_phase / samples_per_step);
                        let total_bars = step_progress / 16.0;
                        let loop_units = total_bars / bars;
                        let phase = loop_units.fract();
                        let locked_pos = if direction >= 0 {
                            loop_start as f32 + phase * loop_len as f32
                        } else {
                            loop_end.saturating_sub(1) as f32 - phase * loop_len as f32
                        };
                        play_pos = locked_pos;
                    }
                    let target_speed = if tape_freeze { 0.0 } else { tempo_speed };
                    let target_glide =
                        f32::from_bits(track.tape_glide.load(Ordering::Relaxed)).clamp(0.0, 1.0);
                    let smooth_glide = smooth_param(
                        f32::from_bits(track.tape_glide_smooth.load(Ordering::Relaxed)),
                        target_glide,
                        num_buffer_samples,
                        track_sample_rate,
                    );
                    track
                        .tape_glide_smooth
                        .store(smooth_glide.to_bits(), Ordering::Relaxed);
                    let glide = smooth_glide;
                    let glide_factor = 1.0 + glide * 20.0;
                    let speed_step = if num_buffer_samples > 0 {
                        (target_speed - smooth_speed)
                            / (num_buffer_samples as f32 * glide_factor)
                    } else {
                        0.0
                    };
                    if loop_mode == 5 && loop_active {
                        let last_start = track.loop_start_last.load(Ordering::Relaxed) as usize;
                        if last_start != loop_start {
                            play_pos = loop_start as f32;
                            if keylock_enabled {
                                keylock_phase = 0.0;
                                keylock_grain_a = play_pos;
                                keylock_grain_b =
                                    play_pos + direction as f32 * KEYLOCK_GRAIN_HOP as f32;
                            }
                        }
                        track
                            .loop_start_last
                            .store(loop_start as u32, Ordering::Relaxed);
                    }

                    let mut prev_play_pos;
                    for sample_idx in 0..num_buffer_samples {
                        let mut pos = play_pos as isize;
                        if pos < 0 || pos as usize >= num_samples {
                            if loop_active {
                                if direction >= 0 {
                                    pos = loop_start as isize;
                                } else {
                                    pos = loop_end.saturating_sub(1) as isize;
                                }
                                play_pos = pos as f32;
                            } else {
                                track.is_playing.store(false, Ordering::Relaxed);
                                break;
                            }
                        }
                        let pos = pos as usize;
                        if loop_mode == 2 {
                            if direction >= 0 && pos >= loop_end {
                                track.is_playing.store(false, Ordering::Relaxed);
                                break;
                            }
                            if direction < 0 && pos <= loop_start {
                                track.is_playing.store(false, Ordering::Relaxed);
                                break;
                            }
                        }

                        if use_straight_lock {
                            let bars = straight_bars.unwrap_or(1.0f32).max(0.000_01f32);
                            let step_progress =
                                straight_step_count as f32 + (straight_phase / samples_per_step);
                            let total_bars = step_progress / 16.0;
                            let loop_units = total_bars / bars;
                            let phase = loop_units.fract();
                            let locked_pos = if direction >= 0 {
                                loop_start as f32 + phase * loop_len as f32
                            } else {
                                loop_end.saturating_sub(1) as f32 - phase * loop_len as f32
                            };
                            let xfade_start = loop_end.saturating_sub(xfade_samples) as f32;
                            let xfade_len = xfade_samples as f32;
                            for channel_idx in 0..output.len() {
                                let src_channel = if num_channels == 1 {
                                    0
                                } else if channel_idx < num_channels {
                                    channel_idx
                                } else {
                                    continue;
                                };
                                let mut sample_value = sample_at_linear(
                                    &samples,
                                    src_channel,
                                    locked_pos,
                                    loop_start,
                                    loop_end,
                                    loop_active,
                                    num_samples,
                                );
                                if loop_active && xfade_samples > 0 {
                                    if direction > 0 && locked_pos >= xfade_start {
                                        let fade_in =
                                            ((locked_pos - xfade_start) / xfade_len).clamp(0.0, 1.0);
                                        let head_pos =
                                            loop_start as f32 + (locked_pos - xfade_start);
                                        let head_sample = sample_at_linear(
                                            &samples,
                                            src_channel,
                                            head_pos,
                                            loop_start,
                                            loop_end,
                                            loop_active,
                                            num_samples,
                                        );
                                        sample_value = sample_value * (1.0 - fade_in)
                                            + head_sample * fade_in;
                                    } else if direction < 0
                                        && locked_pos <= loop_start as f32 + xfade_len
                                    {
                                        let fade_in = ((loop_start as f32 + xfade_len - locked_pos)
                                            / xfade_len)
                                            .clamp(0.0, 1.0);
                                        let head_pos =
                                            loop_end as f32 - (loop_start as f32 + xfade_len - locked_pos);
                                        let head_sample = sample_at_linear(
                                            &samples,
                                            src_channel,
                                            head_pos,
                                            loop_start,
                                            loop_end,
                                            loop_active,
                                            num_samples,
                                        );
                                        sample_value = sample_value * (1.0 - fade_in)
                                            + head_sample * fade_in;
                                    }
                                }
                                    let level = smooth_level + level_step * sample_idx as f32;
                                    let out_value = sample_value * level;
                                    self.track_buffer[channel_idx][sample_idx] += out_value;
                                    if let Some(mosaic) = mosaic_buffer.as_mut() {
                                        if mosaic_len > 0 && channel_idx < mosaic.len() {
                                            let existing = mosaic[channel_idx][mosaic_write_pos];
                                            mosaic[channel_idx][mosaic_write_pos] =
                                                out_value * (1.0 - smooth_mosaic_sos)
                                                    + existing * smooth_mosaic_sos;
                                        }
                                    }
                                }
                            if mosaic_buffer.is_some() && mosaic_len > 0 {
                                mosaic_write_pos = (mosaic_write_pos + 1) % mosaic_len;
                            }
                            play_pos = locked_pos;
                            straight_phase += 1.0;
                            if straight_phase >= samples_per_step {
                                straight_phase -= samples_per_step;
                                straight_step_count += 1;
                            }
                        } else if keylock_enabled {
                            let speed = smooth_speed + speed_step * sample_idx as f32;
                            let step = direction as f32 * speed;
                            let hop = KEYLOCK_GRAIN_HOP as f32;
                            let fade = (keylock_phase / hop).clamp(0.0, 1.0);
                            let read_a = keylock_grain_a + keylock_phase;
                            let read_b = keylock_grain_b + keylock_phase;

                            for channel_idx in 0..output.len() {
                                let src_channel = if num_channels == 1 {
                                    0
                                } else if channel_idx < num_channels {
                                    channel_idx
                                } else {
                                    continue;
                                };
                                let sample_a = sample_at_linear(
                                    &samples,
                                    src_channel,
                                    read_a,
                                    loop_start,
                                    loop_end,
                                    loop_active,
                                    num_samples,
                                );
                                let sample_b = sample_at_linear(
                                    &samples,
                                    src_channel,
                                    read_b,
                                    loop_start,
                                    loop_end,
                                    loop_active,
                                    num_samples,
                                );
                                let sample_value = sample_a * (1.0 - fade) + sample_b * fade;
                                    let level = smooth_level + level_step * sample_idx as f32;
                                    let out_value = sample_value * level;
                                    self.track_buffer[channel_idx][sample_idx] += out_value;
                                    if let Some(mosaic) = mosaic_buffer.as_mut() {
                                        if mosaic_len > 0 && channel_idx < mosaic.len() {
                                            let existing = mosaic[channel_idx][mosaic_write_pos];
                                            mosaic[channel_idx][mosaic_write_pos] =
                                                out_value * (1.0 - smooth_mosaic_sos)
                                                    + existing * smooth_mosaic_sos;
                                        }
                                    }
                                }

                            if mosaic_buffer.is_some() && mosaic_len > 0 {
                                mosaic_write_pos = (mosaic_write_pos + 1) % mosaic_len;
                            }

                            keylock_phase += 1.0;
                            if keylock_phase >= hop {
                                keylock_phase -= hop;
                                keylock_grain_a = keylock_grain_b;
                                keylock_grain_b += step * hop;
                            }
                            let keylock_pos = keylock_grain_a + keylock_phase;
                            prev_play_pos = play_pos;
                            play_pos = keylock_pos;
                            if loop_mode == 2 {
                                if direction >= 0 && play_pos >= loop_end as f32 {
                                    track.is_playing.store(false, Ordering::Relaxed);
                                    break;
                                }
                                if direction < 0 && play_pos <= loop_start as f32 {
                                    track.is_playing.store(false, Ordering::Relaxed);
                                    break;
                                }
                            }
                            if loop_active && loop_end > loop_start {
                                if loop_mode == 1 {
                                    if direction > 0 && play_pos >= loop_end as f32 && prev_play_pos < loop_end as f32 {
                                        direction = -1;
                                        play_pos = loop_end.saturating_sub(1) as f32;
                                    } else if direction < 0 && play_pos <= loop_start as f32 && prev_play_pos > loop_start as f32 {
                                        direction = 1;
                                        play_pos = loop_start as f32;
                                    }
                                } else if direction > 0 && play_pos >= loop_end as f32 && prev_play_pos < loop_end as f32 {
                                    play_pos = loop_start as f32;
                                } else if direction < 0 && play_pos < loop_start as f32 && prev_play_pos >= loop_start as f32 {
                                    play_pos = loop_end.saturating_sub(1) as f32;
                                }
                            }
                            if loop_mode != 2 {
                                keylock_grain_a = wrap_loop_pos(
                                    keylock_grain_a,
                                    loop_start,
                                    loop_end,
                                    loop_active,
                                    num_samples,
                                );
                                keylock_grain_b = wrap_loop_pos(
                                    keylock_grain_b,
                                    loop_start,
                                    loop_end,
                                    loop_active,
                                    num_samples,
                                );
                                play_pos = wrap_loop_pos(
                                    play_pos,
                                    loop_start,
                                    loop_end,
                                    loop_active,
                                    num_samples,
                                );
                            }
                        } else {
                            for channel_idx in 0..output.len() {
                                let src_channel = if num_channels == 1 {
                                    0
                                } else if channel_idx < num_channels {
                                    channel_idx
                                } else {
                                    continue;
                                };
                                let mut sample_value = samples[src_channel][pos];
                            if loop_active && direction > 0 && xfade_samples > 0 {
                                    let xfade_start = loop_end.saturating_sub(xfade_samples);
                                    if pos >= xfade_start && loop_end > loop_start {
                                        let tail_idx = pos - xfade_start;
                                        let head_pos = loop_start + tail_idx;
                                        if head_pos < loop_end {
                                            let fade_in = tail_idx as f32 / xfade_samples as f32;
                                            let fade_out = 1.0 - fade_in;
                                            let head_sample = samples[src_channel][head_pos];
                                            sample_value =
                                                sample_value * fade_out + head_sample * fade_in;
                                        }
                                    }
                                }
                            let level = smooth_level + level_step * sample_idx as f32;
                            let out_value = sample_value * level;
                            self.track_buffer[channel_idx][sample_idx] += out_value;
                            if let Some(mosaic) = mosaic_buffer.as_mut() {
                                if mosaic_len > 0 && channel_idx < mosaic.len() {
                                    let existing = mosaic[channel_idx][mosaic_write_pos];
                                    mosaic[channel_idx][mosaic_write_pos] =
                                        out_value * (1.0 - smooth_mosaic_sos)
                                            + existing * smooth_mosaic_sos;
                                }
                            }
                        }

                        if mosaic_buffer.is_some() && mosaic_len > 0 {
                            mosaic_write_pos = (mosaic_write_pos + 1) % mosaic_len;
                        }

                            let speed = smooth_speed + speed_step * sample_idx as f32;
                            prev_play_pos = play_pos;
                            play_pos += direction as f32 * speed;
                            if loop_active && loop_end > loop_start {
                                if loop_mode == 1 {
                                    if direction > 0 && play_pos >= loop_end as f32 && prev_play_pos < loop_end as f32 {
                                        direction = -1;
                                        play_pos = loop_end.saturating_sub(1) as f32;
                                    } else if direction < 0 && play_pos <= loop_start as f32 && prev_play_pos > loop_start as f32 {
                                        direction = 1;
                                        play_pos = loop_start as f32;
                                    }
                                } else if direction > 0 && play_pos >= loop_end as f32 && prev_play_pos < loop_end as f32 {
                                    play_pos = loop_start as f32;
                                } else if direction < 0 && play_pos < loop_start as f32 && prev_play_pos >= loop_start as f32 {
                                    play_pos = loop_end.saturating_sub(1) as f32;
                                }
                            }
                        }
                    }

                    track.play_pos.store(play_pos.to_bits(), Ordering::Relaxed);
                    if mosaic_buffer.is_some() && mosaic_len > 0 {
                        track
                            .mosaic_write_pos
                            .store(mosaic_write_pos as u32, Ordering::Relaxed);
                    }
                    smooth_speed += speed_step * num_buffer_samples as f32;
                    track
                        .tape_speed_smooth
                        .store(smooth_speed.to_bits(), Ordering::Relaxed);
                    if tape_keylock {
                        track
                            .keylock_phase
                            .store(keylock_phase.to_bits(), Ordering::Relaxed);
                        track
                            .keylock_grain_a
                            .store(keylock_grain_a.to_bits(), Ordering::Relaxed);
                        track
                            .keylock_grain_b
                            .store(keylock_grain_b.to_bits(), Ordering::Relaxed);
                    }
                    if loop_mode == 1 {
                        track.loop_dir.store(direction, Ordering::Relaxed);
                    }
                    smooth_level += level_step * num_buffer_samples as f32;
                    track
                        .level_smooth
                        .store(smooth_level.to_bits(), Ordering::Relaxed);
                }
            }

            // Apply track effects
            Self::process_track_mosaic(
                track,
                &mut self.track_buffer,
                buffer.samples(),
                global_tempo,
                master_step_count,
                master_phase,
                samples_per_step,
            );
            Self::process_track_ring(track, &mut self.track_buffer, buffer.samples(), global_tempo);
            Self::process_track_g8(
                track,
                &mut self.track_buffer,
                buffer.samples(),
                master_step_count,
                master_phase,
                samples_per_step,
                master_sr,
            );
            Self::process_track_texture(track, &mut self.track_buffer, buffer.samples());
            Self::process_track_reflect(
                track,
                &mut self.track_buffer,
                buffer.samples(),
                global_tempo,
            );

            let mix_gain = if track_muted && engine_type != 1 { 0.0 } else { 1.0 };
            // Sum track buffer to master output and calculate final peaks
            let num_buffer_samples = buffer.samples();
            let output = buffer.as_slice();
            for sample_idx in 0..num_buffer_samples {
                for channel_idx in 0..output.len() {
                    let val = self.track_buffer[channel_idx][sample_idx] * mix_gain;
                    output[channel_idx][sample_idx] += val;

                    if channel_idx == 0 {
                        track_peak_left = track_peak_left.max(val.abs());
                    } else if channel_idx == 1 {
                        track_peak_right = track_peak_right.max(val.abs());
                    }
                }
            }

            // Update meters with final peaks
            if output.len() == 1 && buffer.channels() > 1 {
                track_peak_right = track_peak_left;
            }
            let prev_left = f32::from_bits(track.meter_left.load(Ordering::Relaxed));
            let prev_right = f32::from_bits(track.meter_right.load(Ordering::Relaxed));
            let next_left = smooth_meter(prev_left, track_peak_left);
            let next_right = smooth_meter(prev_right, track_peak_right);
            track.meter_left.store(next_left.to_bits(), Ordering::Relaxed);
            track.meter_right.store(next_right.to_bits(), Ordering::Relaxed);
        }

        if any_monitoring {
            keep_alive = true;
        }


        let metronome_active = self.metronome_enabled.load(Ordering::Relaxed)
            && (any_playing || any_recording || any_pending);
        if metronome_active {
            let num_buffer_samples = buffer.samples();
            let output = buffer.as_slice();
            let sr = self.tracks[0].sample_rate.load(Ordering::Relaxed).max(1);
            let tempo = global_tempo.clamp(20.0, 240.0);
            let samples_per_beat =
                ((sr as f32 * 60.0) / tempo.max(1.0)).round().max(1.0) as u32;
            let click_len = ((sr as f32) * (METRONOME_CLICK_MS / 1000.0))
                .round()
                .max(1.0) as u32;
            let mut phase = self.metronome_phase_samples;
            let mut click_remaining = self.metronome_click_remaining;
            for sample_idx in 0..num_buffer_samples {
                if phase == 0 {
                    click_remaining = click_len;
                }
                if click_remaining > 0 {
                    let env = click_remaining as f32 / click_len as f32;
                    let click = METRONOME_CLICK_GAIN * env;
                    for channel_idx in 0..output.len() {
                        output[channel_idx][sample_idx] += click;
                    }
                    click_remaining = click_remaining.saturating_sub(1);
                }
                phase += 1;
                if phase >= samples_per_beat {
                    phase = 0;
                }
            }
            self.metronome_phase_samples = phase;
            self.metronome_click_remaining = click_remaining;
            keep_alive = true;
        }

        // Master FX Chain
        let sr = self.sample_rate.load(Ordering::Relaxed) as f32;
        let num_channels = buffer.channels();
        let num_samples = buffer.samples();

        for sample_idx in 0..num_samples {
            let master_filter = (self.params.master_filter.smoothed.next() * 0.5).clamp(0.0, 0.5);
            let master_comp = self.params.master_comp.smoothed.next();

            // Calculate DJ Filter coefficients
            let mut filter_type = 0; // 0=None, 1=HP, 2=LP
            let mut f = 0.0f32;
            let q = 0.707f32;

            if master_filter < 0.49 {
                filter_type = 1; // HP
                let cutoff_hz = 20.0 + (1.0 - master_filter / 0.5) * 2000.0;
                f = (PI * cutoff_hz / sr).tan();
            }

            let res_coeff = 1.0 / q;

            // Compressor parameters
            let threshold_db = -24.0 * master_comp;
            let threshold = util::db_to_gain(threshold_db);
            let ratio = 1.0 + master_comp * 10.0;
            let attack_ms = 5.0;
            let release_ms = 100.0;
            let attack_coeff = (-1.0 / (attack_ms * sr / 1000.0)).exp();
            let release_coeff = (-1.0 / (release_ms * sr / 1000.0)).exp();

            let mut max_abs = 0.0f32;
            
            // Process Filter + Find Max for Compressor
            for channel_idx in 0..num_channels {
                let mut x = buffer.as_slice()[channel_idx][sample_idx];
                
                if filter_type > 0 {
                    let low = self.master_fx.filter_low[channel_idx];
                    let band = self.master_fx.filter_band[channel_idx];
                    let high = x - low - res_coeff * band;
                    let new_band = f * high + band;
                    let new_low = f * new_band + low;
                    
                    self.master_fx.filter_low[channel_idx] = new_low;
                    self.master_fx.filter_band[channel_idx] = new_band;
                    
                    if filter_type == 1 {
                        x = high;
                    } else {
                        x = new_low;
                    }
                }
                
                buffer.as_slice()[channel_idx][sample_idx] = x;
                max_abs = max_abs.max(x.abs());
            }

            // Compressor
            let mut env = self.master_fx.comp_env;
            if max_abs > env {
                env = attack_coeff * env + (1.0 - attack_coeff) * max_abs;
            } else {
                env = release_coeff * env + (1.0 - release_coeff) * max_abs;
            }
            self.master_fx.comp_env = env;

            let mut reduction = 1.0f32;
            if env > threshold {
                let env_db = util::gain_to_db(env);
                let over_db = env_db - threshold_db;
                let reduced_db = over_db / ratio;
                reduction = util::db_to_gain(reduced_db - over_db);
            }

            // Apply global gain + compression
            let gain = self.params.gain.smoothed.next();
            for channel_idx in 0..num_channels {
                buffer.as_slice()[channel_idx][sample_idx] *= gain * reduction;
            }
        }

        for channel_samples in buffer.iter_samples() {
            for sample in channel_samples {
                if !sample.is_finite() {
                    *sample = 0.0;
                }
            }
        }

        // Update master output meters + visualizer data.
        if !buffer.is_empty() {
            let output = buffer.as_slice_immutable();
            let left = output.get(0).map(|ch| ch.as_ref()).unwrap_or(&[]);
            let right = output
                .get(1)
                .map(|ch| ch.as_ref())
                .unwrap_or(left);

            let mut peak_left = 0.0_f32;
            for sample in left {
                let amp = sample.abs();
                if amp > peak_left {
                    peak_left = amp;
                }
            }

            let mut peak_right = 0.0_f32;
            for sample in right {
                let amp = sample.abs();
                if amp > peak_right {
                    peak_right = amp;
                }
            }

            let prev_left =
                f32::from_bits(self.master_meters.left.load(Ordering::Relaxed));
            let prev_right =
                f32::from_bits(self.master_meters.right.load(Ordering::Relaxed));

            let next_left = smooth_meter(prev_left, peak_left);
            let next_right = smooth_meter(prev_right, peak_right);

            self.master_meters
                .left
                .store(next_left.to_bits(), Ordering::Relaxed);
            self.master_meters
                .right
                .store(next_right.to_bits(), Ordering::Relaxed);

            let total_samples = left.len().min(right.len());
            if total_samples > 0 {
                let scope_stride = (total_samples / OSCILLOSCOPE_SAMPLES).max(1);
                if let Some(mut scope) = self.visualizer.oscilloscope.try_lock() {
                    for (i, slot) in scope.iter_mut().enumerate() {
                        let idx = i * scope_stride;
                        *slot = left.get(idx).copied().unwrap_or(0.0);
                    }
                }

                let vector_stride = (total_samples / VECTORSCOPE_POINTS).max(1);
                if let (Some(mut xs), Some(mut ys)) = (
                    self.visualizer.vectorscope_x.try_lock(),
                    self.visualizer.vectorscope_y.try_lock(),
                ) {
                    for i in 0..VECTORSCOPE_POINTS {
                        let idx = i * vector_stride;
                        xs[i] = left.get(idx).copied().unwrap_or(0.0);
                        ys[i] = right.get(idx).copied().unwrap_or(0.0);
                    }
                }

                let window_len = SPECTRUM_WINDOW.min(total_samples);
                if window_len >= 2 {
                    let bins = SPECTRUM_BINS.min(window_len / 2);
                    if let Some(mut spectrum) = self.visualizer.spectrum.try_lock() {
                        for bin in 0..bins {
                            let mut re = 0.0_f32;
                            let mut im = 0.0_f32;
                            let bin_f = bin as f32;
                            let win_f = window_len as f32;
                            for i in 0..window_len {
                                let sample = left[i];
                                let phase = 2.0 * PI * bin_f * (i as f32) / win_f;
                                re += sample * phase.cos();
                                im -= sample * phase.sin();
                            }
                            let mag = (re * re + im * im).sqrt() / window_len as f32;
                            let mag = mag.clamp(0.0, 1.0);
                            // Compress dynamic range to make low-level movement more visible.
                            let mag = (1.0_f32 + 20.0 * mag).ln() / (1.0_f32 + 20.0).ln();
                            spectrum[bin] = mag.clamp(0.0, 1.0);
                        }
                        for bin in bins..SPECTRUM_BINS {
                            spectrum[bin] = 0.0;
                        }
                    }
                }
            }
        }

        if any_playing || any_pending || any_engine_clock {
            let mut phase = master_phase + buffer.samples() as f32;
            let mut step = master_step;
            if samples_per_step > 0.0 {
                while phase >= samples_per_step {
                    phase -= samples_per_step;
                    step = (step + 1).rem_euclid(16);
                    master_step_count += 1;
                }
            }
            self.master_step_phase = phase;
            self.master_step_index = step;
            self.master_step_count = master_step_count;
        } else {
            self.master_step_phase = 0.0;
            self.master_step_index = 0;
            self.master_step_count = 0;
        }

        if keep_alive {
            ProcessStatus::KeepAlive
        } else {
            ProcessStatus::Normal
        }
    }
}

fn wrap_loop_pos(
    mut pos: f32,
    loop_start: usize,
    loop_end: usize,
    loop_active: bool,
    num_samples: usize,
) -> f32 {
    if num_samples == 0 {
        return 0.0;
    }
    if pos < 0.0 {
        if loop_active && loop_end > loop_start {
            pos = (loop_end.saturating_sub(1)) as f32;
        } else {
            pos = 0.0;
        }
    } else if pos as usize >= num_samples {
        if loop_active && loop_end > loop_start {
            pos = loop_start as f32;
        } else {
            pos = (num_samples.saturating_sub(1)) as f32;
        }
    }
    pos
}

fn lfo_division_beats(index: u32) -> f32 {
    match index {
        0 => 0.25,        // 1/16
        1 => 0.5,         // 1/8
        2 => 1.0,         // 1/4
        3 => 1.333_333_4, // 1/3
        4 => 2.0,         // 1/2
        5 => 4.0,         // 1 bar
        6 => 8.0,         // 2 bars
        7 => 16.0,        // 4 bars
        _ => 4.0,
    }
}

fn modul8_division_beats(index: u32) -> f32 {
    match index {
        0 => 4.0,   // 1 bar
        1 => 2.0,   // 1/2
        2 => 1.0,   // 1/4
        3 => 0.5,   // 1/8
        4 => 0.25,  // 1/16
        5 => 0.125, // 1/32
        _ => 4.0,
    }
}

fn lfo_waveform_value(waveform: u32, phase: f32, sample_hold: f32) -> f32 {
    match waveform {
        0 => (2.0 * PI * phase).sin(),
        1 => 1.0 - 4.0 * (phase - 0.5).abs(),
        2 => {
            if phase < 0.5 {
                1.0
            } else {
                -1.0
            }
        }
        3 => 2.0 * phase - 1.0,
        4 => sample_hold,
        _ => 0.0,
    }
}

fn modul8_rate_hz(rate: f32, sync: bool, division: u32, tempo: f32) -> f32 {
    if sync {
        let beats = modul8_division_beats(division);
        (tempo / 60.0) / beats.max(0.0001)
    } else {
        rate.max(0.01)
    }
}

fn fmmi_waveform_value(waveform: u32, phase: f32) -> f32 {
    match waveform {
        0 => (2.0 * PI * phase).sin(),
        1 => 1.0 - 4.0 * (phase - 0.5).abs(),
        2 => 2.0 * phase - 1.0,
        3 => {
            if phase < 0.5 { 1.0 } else { -1.0 }
        }
        _ => 0.0,
    }
}

fn fmmi_midi_to_freq(midi: i32) -> f32 {
    (440.0 * 2.0_f32.powf((midi as f32 - 69.0) / 12.0)).max(1.0)
}

fn fmmi_midi_to_label(midi: i32) -> Option<String> {
    if !(FMMI_NOTE_BASE..=FMMI_NOTE_MAX).contains(&midi) {
        return None;
    }
    let note_names = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    let note_index = midi.rem_euclid(12) as usize;
    let octave = (midi / 12) - 1;
    Some(format!("{}{}", note_names[note_index], octave))
}

fn monomi_midi_to_freq(midi: i32) -> f32 {
    fmmi_midi_to_freq(midi)
}

fn monomi_waveform_value(waveform: u32, phase: f32, pwm: f32) -> f32 {
    match waveform {
        0 => (2.0 * PI * phase).sin(),
        1 => 1.0 - 4.0 * (phase - 0.5).abs(),
        2 => 2.0 * phase - 1.0,
        3 => if phase < pwm { 1.0 } else { -1.0 },
        _ => 0.0,
    }
}

fn monomi_env_samples(
    sr: f32,
    step_sec: f32,
    attack_steps: f32,
    decay_steps: f32,
    sustain_steps: f32,
    release_steps: f32,
    gate_steps: f32,
) -> (u32, u32, u32, f32, u32) {
    let attack_time = (attack_steps.max(0.0)) * step_sec;
    let decay_time = (decay_steps.max(1.0)) * step_sec;
    let release_time = (release_steps.max(1.0)) * step_sec;
    let sustain_level = (sustain_steps / 128.0).clamp(0.0, 1.0);
    let attack_samples = (attack_time * sr).round().max(1.0) as u32;
    let decay_samples = (decay_time * sr).round().max(1.0) as u32;
    let release_samples = (release_time * sr).round().max(1.0) as u32;
    let gate_len = gate_steps.max(1.0);
    let hold_samples = ((gate_len * step_sec) * sr).round().max(0.0) as u32;
    (
        attack_samples,
        decay_samples,
        release_samples,
        sustain_level,
        hold_samples,
    )
}

fn modul8_target_options_for_engine(engine_type: u32) -> Vec<SharedString> {
    let ids = modul8_target_ids_for_engine(engine_type);
    ids.iter()
        .copied()
        .map(|id| SharedString::from(modul8_target_label(id)))
        .collect()
}

const MODUL8_TARGET_IDS_DEFAULT: [u32; 46] = [
    0, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
    81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101,
    102, 103, 104,
];
const MODUL8_TARGET_IDS_TAPE: [u32; 54] = [
    0, 1, 2, 3, 4, 148, 149, 150, 151, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
    74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
    96, 97, 98, 99, 100, 101, 102, 103, 104,
];
const MODUL8_TARGET_IDS_ANIMATE: [u32; 48] = [
    0, 5, 6, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101,
    102, 103, 104,
];
const MODUL8_TARGET_IDS_SYNDRM: [u32; 125] = [
    0, 24, 105, 25, 26, 27, 28, 106, 107, 29, 30, 31, 32, 33, 34, 108, 109, 35, 36, 37, 38, 39,
    110, 111, 40, 41, 42, 43, 44, 112, 113, 45, 46, 47, 48, 49, 114, 115, 50, 51, 52, 53, 54,
    116, 117, 55, 56, 57, 58, 59, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 60, 61, 62,
    128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145,
    146, 147, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,
    83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103,
    104,
];
const MODUL8_TARGET_IDS_VOID: [u32; 55] = [
    0, 7, 8, 9, 10, 11, 12, 13, 14, 15, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
    73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
    95, 96, 97, 98, 99, 100, 101, 102, 103, 104,
];
const MODUL8_TARGET_IDS_FMMI: [u32; 59] = [
    0, 16, 17, 18, 19, 20, 21, 22, 23, 152, 153, 154, 155, 156, 60, 61, 62, 63, 64, 65, 66,
    67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,
    89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104,
];
const MODUL8_TARGET_IDS_MONOMI: [u32; 61] = [
    0, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 60, 61, 62,
    63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,
    85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104,
];

fn modul8_target_ids_for_engine(engine_type: u32) -> &'static [u32] {
    match engine_type {
        1 => &MODUL8_TARGET_IDS_TAPE,
        2 => &MODUL8_TARGET_IDS_ANIMATE,
        3 => &MODUL8_TARGET_IDS_SYNDRM,
        4 => &MODUL8_TARGET_IDS_VOID,
        5 => &MODUL8_TARGET_IDS_FMMI,
        6 => &MODUL8_TARGET_IDS_MONOMI,
        _ => &MODUL8_TARGET_IDS_DEFAULT,
    }
}

macro_rules! modul8_targets {
    ($mac:ident, $($args:expr),* $(,)?) => {
        $mac!(
            $($args),*;
            1, "Tape: Speed", -4.0, 4.0, tape_speed;
            2, "Tape: Rotate", 0.0, 1.0, tape_rotate;
            3, "Tape: Glide", 0.0, 1.0, tape_glide;
            4, "Tape: SOS", 0.0, 1.0, tape_sos;
            148, "Tape: T. Start", 0.0, 1.0, trigger_start;
            149, "Tape: L. Start", 0.0, 1.0, loop_start;
            150, "Tape: Length", 0.0, 1.0, loop_length;
            151, "Tape: XFade", 0.0, 0.5, loop_xfade;
            5, "Animate: Vector X", 0.0, 1.0, animate_vector_x;
            6, "Animate: Vector Y", 0.0, 1.0, animate_vector_y;
            7, "Void: Base Freq", 20.0, 200.0, void_base_freq;
            8, "Void: Chaos Depth", 0.0, 1.0, void_chaos_depth;
            9, "Void: Entropy", 0.0, 1.0, void_entropy;
            10, "Void: Feedback", 0.0, 0.98, void_feedback;
            11, "Void: Diffusion", 0.0, 1.0, void_diffusion;
            12, "Void: Mod Rate", 0.01, 10.0, void_mod_rate;
            13, "Void: Level", 0.0, 1.0, void_level;
            14, "Void: Pan", -1.0, 1.0, void_pan;
            15, "Void: Width", -1.0, 1.0, void_width;
            16, "FMMI: Car Freq", 20.0, 4000.0, fmmi_car_freq;
            17, "FMMI: Car Detune", -120.0, 120.0, fmmi_car_detune;
            18, "FMMI: Mod Value", 0.1, 4000.0, fmmi_mod_value;
            19, "FMMI: Mod Detune", -120.0, 120.0, fmmi_mod_detune;
            20, "FMMI: Index", 0.0, 4000.0, fmmi_index;
            21, "FMMI: Feedback", 0.0, 1.0, fmmi_feedback;
            22, "FMMI: Drive", 0.0, 1.0, fmmi_drive;
            23, "FMMI: Out Level", 0.0, 1.0, fmmi_out_level;
            152, "FMMI: Amp Attack", 0.0, 127.0, fmmi_amp_attack;
            153, "FMMI: Amp Decay", 0.0, 127.0, fmmi_amp_decay;
            154, "FMMI: Amp Sustain", 0.0, 127.0, fmmi_amp_sustain;
            155, "FMMI: Amp Release", 0.0, 127.0, fmmi_amp_release;
            156, "FMMI: Gate Length", 0.0, 3000.0, fmmi_gate_length;
            157, "MonoMI: Cutoff", 200.0, 8000.0, monomi_cutoff;
            158, "MonoMI: Resonance", 0.0, 8.0, monomi_resonance;
            159, "MonoMI: Morph", 0.0, 1.0, monomi_filter_morph;
            160, "MonoMI: F Env Int", 0.0, 4.0, monomi_filter_intensity;
            161, "MonoMI: F Env Pol", -1.0, 1.0, monomi_filter_polarity;
            162, "MonoMI: Glide", 0.0, 500.0, monomi_glide;
            163, "MonoMI: Osc1 Detune", -100.0, 100.0, monomi_osc_detune[0];
            164, "MonoMI: Osc2 Detune", -100.0, 100.0, monomi_osc_detune[1];
            165, "MonoMI: Osc3 Detune", -100.0, 100.0, monomi_osc_detune[2];
            166, "MonoMI: Osc1 Mix", 0.0, 1.0, monomi_osc_mix[0];
            167, "MonoMI: Osc2 Mix", 0.0, 1.0, monomi_osc_mix[1];
            168, "MonoMI: Osc3 Mix", 0.0, 1.0, monomi_osc_mix[2];
            169, "MonoMI: Osc1 PWM", 0.05, 0.95, monomi_osc_pwm[0];
            170, "MonoMI: Osc2 PWM", 0.05, 0.95, monomi_osc_pwm[1];
            171, "MonoMI: Osc3 PWM", 0.05, 0.95, monomi_osc_pwm[2];
            24, "SynDRM Kick: Pitch", 0.0, 1.0, kick_pitch;
            25, "SynDRM Kick: Decay", 0.0, 1.0, kick_decay;
            26, "SynDRM Kick: Attack", 0.0, 1.0, kick_attack;
            27, "SynDRM Kick: Drive", 0.0, 1.0, kick_drive;
            28, "SynDRM Kick: Level", 0.0, 1.0, kick_level;
            106, "SynDRM Kick: Cut", 0.0, 1.0, kick_filter_cutoff;
            107, "SynDRM Kick: Res", 0.0, 1.0, kick_filter_resonance;
            29, "SynDRM Snare: Tone", 0.0, 1.0, snare_tone;
            30, "SynDRM Snare: Decay", 0.0, 1.0, snare_decay;
            31, "SynDRM Snare: Snappy", 0.0, 1.0, snare_snappy;
            32, "SynDRM Snare: Attack", 0.0, 1.0, snare_attack;
            33, "SynDRM Snare: Drive", 0.0, 1.0, snare_drive;
            34, "SynDRM Snare: Level", 0.0, 1.0, snare_level;
            108, "SynDRM Snare: Cut", 0.0, 1.0, snare_filter_cutoff;
            109, "SynDRM Snare: Res", 0.0, 1.0, snare_filter_resonance;
            35, "SynDRM Clap: Pitch", 0.0, 1.0, clap_pitch;
            36, "SynDRM Clap: Decay", 0.0, 1.0, clap_decay;
            37, "SynDRM Clap: Tone", 0.0, 1.0, clap_tone;
            38, "SynDRM Clap: Drive", 0.0, 1.0, clap_drive;
            39, "SynDRM Clap: Level", 0.0, 1.0, clap_level;
            110, "SynDRM Clap: Cut", 0.0, 1.0, clap_filter_cutoff;
            111, "SynDRM Clap: Res", 0.0, 1.0, clap_filter_resonance;
            40, "SynDRM Hat: Pitch", 0.0, 1.0, hat_pitch;
            41, "SynDRM Hat: Decay", 0.0, 1.0, hat_decay;
            42, "SynDRM Hat: Tone", 0.0, 1.0, hat_tone;
            43, "SynDRM Hat: Drive", 0.0, 1.0, hat_drive;
            44, "SynDRM Hat: Level", 0.0, 1.0, hat_level;
            112, "SynDRM Hat: Cut", 0.0, 1.0, hat_filter_cutoff;
            113, "SynDRM Hat: Res", 0.0, 1.0, hat_filter_resonance;
            45, "SynDRM Perc1: Pitch", 0.0, 1.0, perc1_pitch;
            46, "SynDRM Perc1: Decay", 0.0, 1.0, perc1_decay;
            47, "SynDRM Perc1: Tone", 0.0, 1.0, perc1_tone;
            48, "SynDRM Perc1: Drive", 0.0, 1.0, perc1_drive;
            49, "SynDRM Perc1: Level", 0.0, 1.0, perc1_level;
            114, "SynDRM Perc1: Cut", 0.0, 1.0, perc1_filter_cutoff;
            115, "SynDRM Perc1: Res", 0.0, 1.0, perc1_filter_resonance;
            50, "SynDRM Perc2: Pitch", 0.0, 1.0, perc2_pitch;
            51, "SynDRM Perc2: Decay", 0.0, 1.0, perc2_decay;
            52, "SynDRM Perc2: Tone", 0.0, 1.0, perc2_tone;
            53, "SynDRM Perc2: Drive", 0.0, 1.0, perc2_drive;
            54, "SynDRM Perc2: Level", 0.0, 1.0, perc2_level;
            116, "SynDRM Perc2: Cut", 0.0, 1.0, perc2_filter_cutoff;
            117, "SynDRM Perc2: Res", 0.0, 1.0, perc2_filter_resonance;
            55, "SynDRM Crash: Tone", 0.0, 1.0, crash_tone;
            56, "SynDRM Crash: Decay", 0.0, 1.0, crash_decay;
            57, "SynDRM Crash: Pitch", 0.0, 1.0, crash_pitch;
            58, "SynDRM Crash: Drive", 0.0, 1.0, crash_drive;
            59, "SynDRM Crash: Level", 0.0, 1.0, crash_level;
            118, "SynDRM Crash: Cut", 0.0, 1.0, crash_filter_cutoff;
            119, "SynDRM Crash: Res", 0.0, 1.0, crash_filter_resonance;
            60, "Granulator: Pitch", 0.0, 1.0, mosaic_pitch;
            61, "Granulator: Rate", 0.0, 1.0, mosaic_rate;
            62, "Granulator: Size", 0.0, 1.0, mosaic_size;
            63, "Granulator: Contour", 0.0, 1.0, mosaic_contour;
            64, "Granulator: Warp", 0.0, 1.0, mosaic_warp;
            65, "Granulator: Spray", 0.0, 1.0, mosaic_spray;
            66, "Granulator: Pattern", 0.0, 1.0, mosaic_pattern;
            67, "Granulator: Wet", 0.0, 1.0, mosaic_wet;
            68, "Granulator: Post Gain", 0.0, 1.0, mosaic_post_gain;
            69, "Granulator: Detune", 0.0, 1.0, mosaic_detune;
            70, "Granulator: Spatial", 0.0, 1.0, mosaic_spatial;
            71, "Granulator: Rand Rate", 0.0, 1.0, mosaic_rand_rate;
            72, "Granulator: Rand Size", 0.0, 1.0, mosaic_rand_size;
            73, "Granulator: SOS", 0.0, 1.0, mosaic_sos;
            74, "Silk: Cutoff", 0.0, 1.0, ring_cutoff;
            75, "Silk: Resonance", 0.0, 1.0, ring_resonance;
            76, "Silk: Decay", 0.0, 1.0, ring_decay;
            77, "Silk: Pitch", 0.0, 1.0, ring_pitch;
            78, "Silk: Slope", 0.0, 1.0, ring_slope;
            79, "Silk: Tone", 0.0, 1.0, ring_tone;
            80, "Silk: Tilt", 0.0, 1.0, ring_tilt;
            81, "Silk: Wet", 0.0, 1.0, ring_wet;
            82, "Silk: Detune", 0.0, 1.0, ring_detune;
            83, "Silk: Waves", 0.0, 1.0, ring_waves;
            84, "Silk: Waves Rate", 0.0, 1.0, ring_waves_rate;
            85, "Silk: Noise", 0.0, 1.0, ring_noise;
            86, "Silk: Noise Rate", 0.0, 1.0, ring_noise_rate;
            87, "Texture: Drive", 0.0, 1.0, texture_drive;
            88, "Texture: Compress", 0.0, 1.0, texture_compress;
            89, "Texture: Crush", 0.0, 1.0, texture_crush;
            90, "Texture: Tilt", 0.0, 1.0, texture_tilt;
            91, "Texture: Noise", 0.0, 1.0, texture_noise;
            92, "Texture: Noise Decay", 0.0, 1.0, texture_noise_decay;
            93, "Texture: Noise Color", 0.0, 1.0, texture_noise_color;
            94, "Texture: Wet", 0.0, 1.0, texture_wet;
            95, "Texture: Post Gain", 0.0, 1.0, texture_post_gain;
            96, "Reflect: Delay", 0.0, 1.0, reflect_delay;
            97, "Reflect: Time", 0.0, 1.0, reflect_time;
            98, "Reflect: Reverb", 0.0, 1.0, reflect_reverb;
            99, "Reflect: Size", 0.0, 1.0, reflect_size;
            100, "Reflect: Feedback", 0.0, 1.0, reflect_feedback;
            101, "Reflect: Spread", 0.0, 1.0, reflect_spread;
            102, "Reflect: Damp", 0.0, 1.0, reflect_damp;
            103, "Reflect: Decay", 0.0, 1.0, reflect_decay;
            104, "Reflect: Post Gain", 0.0, 1.0, reflect_post_gain;
            105, "SynDRM Kick: P Env", 0.0, 1.0, kick_pitch_env_amount;
        )
    };
}

macro_rules! modul8_target_label_match {
    ($id:expr; $( $tid:expr, $label:expr, $min:literal, $max:literal, $field:ident $( [ $idx:expr ] )?; )*) => {
        match $id {
            0 => "None",
            $( $tid => $label, )*
            _ => "None",
        }
    };
}

fn modul8_target_label(target: u32) -> &'static str {
    match target {
        120 => "SynDRM Samp 1: Cut",
        121 => "SynDRM Samp 1: Res",
        122 => "SynDRM Samp 2: Cut",
        123 => "SynDRM Samp 2: Res",
        124 => "SynDRM Samp 3: Cut",
        125 => "SynDRM Samp 3: Res",
        126 => "SynDRM Samp 4: Cut",
        127 => "SynDRM Samp 4: Res",
        128 => "SynDRM Samp 1: Pitch",
        129 => "SynDRM Samp 1: Attack",
        130 => "SynDRM Samp 1: Decay",
        131 => "SynDRM Samp 1: Drive",
        132 => "SynDRM Samp 1: Level",
        133 => "SynDRM Samp 2: Pitch",
        134 => "SynDRM Samp 2: Attack",
        135 => "SynDRM Samp 2: Decay",
        136 => "SynDRM Samp 2: Drive",
        137 => "SynDRM Samp 2: Level",
        138 => "SynDRM Samp 3: Pitch",
        139 => "SynDRM Samp 3: Attack",
        140 => "SynDRM Samp 3: Decay",
        141 => "SynDRM Samp 3: Drive",
        142 => "SynDRM Samp 3: Level",
        143 => "SynDRM Samp 4: Pitch",
        144 => "SynDRM Samp 4: Attack",
        145 => "SynDRM Samp 4: Decay",
        146 => "SynDRM Samp 4: Drive",
        147 => "SynDRM Samp 4: Level",
        _ => modul8_targets!(modul8_target_label_match, target),
    }
}

macro_rules! modul8_target_range_match {
    ($id:expr; $( $tid:expr, $label:expr, $min:literal, $max:literal, $field:ident $( [ $idx:expr ] )?; )*) => {
        match $id {
            $( $tid => Some(($min, $max)), )*
            _ => None,
        }
    };
}

fn modul8_target_range(target: u32) -> Option<(f32, f32)> {
    match target {
        120..=147 => Some((0.0, 1.0)),
        _ => modul8_targets!(modul8_target_range_match, target),
    }
}

macro_rules! modul8_target_get_match {
    ($track:expr, $id:expr; $( $tid:expr, $label:expr, $min:literal, $max:literal, $field:ident $( [ $idx:expr ] )?; )*) => {
        match $id {
            $( $tid => Some(f32::from_bits($track.$field $( [ $idx ] )?.load(Ordering::Relaxed))), )*
            _ => None,
        }
    };
}

fn modul8_target_get(track: &Track, target: u32) -> Option<f32> {
    match target {
        120 => Some(f32::from_bits(track.samp_filter_cutoff[0].load(Ordering::Relaxed))),
        121 => Some(f32::from_bits(track.samp_filter_resonance[0].load(Ordering::Relaxed))),
        122 => Some(f32::from_bits(track.samp_filter_cutoff[1].load(Ordering::Relaxed))),
        123 => Some(f32::from_bits(track.samp_filter_resonance[1].load(Ordering::Relaxed))),
        124 => Some(f32::from_bits(track.samp_filter_cutoff[2].load(Ordering::Relaxed))),
        125 => Some(f32::from_bits(track.samp_filter_resonance[2].load(Ordering::Relaxed))),
        126 => Some(f32::from_bits(track.samp_filter_cutoff[3].load(Ordering::Relaxed))),
        127 => Some(f32::from_bits(track.samp_filter_resonance[3].load(Ordering::Relaxed))),
        128 => Some(f32::from_bits(track.samp_pitch[0].load(Ordering::Relaxed))),
        129 => Some(f32::from_bits(track.samp_attack[0].load(Ordering::Relaxed))),
        130 => Some(f32::from_bits(track.samp_decay[0].load(Ordering::Relaxed))),
        131 => Some(f32::from_bits(track.samp_drive[0].load(Ordering::Relaxed))),
        132 => Some(f32::from_bits(track.samp_level[0].load(Ordering::Relaxed))),
        133 => Some(f32::from_bits(track.samp_pitch[1].load(Ordering::Relaxed))),
        134 => Some(f32::from_bits(track.samp_attack[1].load(Ordering::Relaxed))),
        135 => Some(f32::from_bits(track.samp_decay[1].load(Ordering::Relaxed))),
        136 => Some(f32::from_bits(track.samp_drive[1].load(Ordering::Relaxed))),
        137 => Some(f32::from_bits(track.samp_level[1].load(Ordering::Relaxed))),
        138 => Some(f32::from_bits(track.samp_pitch[2].load(Ordering::Relaxed))),
        139 => Some(f32::from_bits(track.samp_attack[2].load(Ordering::Relaxed))),
        140 => Some(f32::from_bits(track.samp_decay[2].load(Ordering::Relaxed))),
        141 => Some(f32::from_bits(track.samp_drive[2].load(Ordering::Relaxed))),
        142 => Some(f32::from_bits(track.samp_level[2].load(Ordering::Relaxed))),
        143 => Some(f32::from_bits(track.samp_pitch[3].load(Ordering::Relaxed))),
        144 => Some(f32::from_bits(track.samp_attack[3].load(Ordering::Relaxed))),
        145 => Some(f32::from_bits(track.samp_decay[3].load(Ordering::Relaxed))),
        146 => Some(f32::from_bits(track.samp_drive[3].load(Ordering::Relaxed))),
        147 => Some(f32::from_bits(track.samp_level[3].load(Ordering::Relaxed))),
        _ => modul8_targets!(modul8_target_get_match, track, target),
    }
}

macro_rules! modul8_target_set_match {
    ($track:expr, $id:expr, $bits:expr; $( $tid:expr, $label:expr, $min:literal, $max:literal, $field:ident $( [ $idx:expr ] )?; )*) => {
        match $id {
            $( $tid => $track.$field $( [ $idx ] )?.store($bits, Ordering::Relaxed), )*
            _ => {}
        }
    };
}

fn modul8_target_set(track: &Track, target: u32, value: f32) {
    let bits = value.to_bits();
    match target {
        120 => track.samp_filter_cutoff[0].store(bits, Ordering::Relaxed),
        121 => track.samp_filter_resonance[0].store(bits, Ordering::Relaxed),
        122 => track.samp_filter_cutoff[1].store(bits, Ordering::Relaxed),
        123 => track.samp_filter_resonance[1].store(bits, Ordering::Relaxed),
        124 => track.samp_filter_cutoff[2].store(bits, Ordering::Relaxed),
        125 => track.samp_filter_resonance[2].store(bits, Ordering::Relaxed),
        126 => track.samp_filter_cutoff[3].store(bits, Ordering::Relaxed),
        127 => track.samp_filter_resonance[3].store(bits, Ordering::Relaxed),
        128 => track.samp_pitch[0].store(bits, Ordering::Relaxed),
        129 => track.samp_attack[0].store(bits, Ordering::Relaxed),
        130 => track.samp_decay[0].store(bits, Ordering::Relaxed),
        131 => track.samp_drive[0].store(bits, Ordering::Relaxed),
        132 => track.samp_level[0].store(bits, Ordering::Relaxed),
        133 => track.samp_pitch[1].store(bits, Ordering::Relaxed),
        134 => track.samp_attack[1].store(bits, Ordering::Relaxed),
        135 => track.samp_decay[1].store(bits, Ordering::Relaxed),
        136 => track.samp_drive[1].store(bits, Ordering::Relaxed),
        137 => track.samp_level[1].store(bits, Ordering::Relaxed),
        138 => track.samp_pitch[2].store(bits, Ordering::Relaxed),
        139 => track.samp_attack[2].store(bits, Ordering::Relaxed),
        140 => track.samp_decay[2].store(bits, Ordering::Relaxed),
        141 => track.samp_drive[2].store(bits, Ordering::Relaxed),
        142 => track.samp_level[2].store(bits, Ordering::Relaxed),
        143 => track.samp_pitch[3].store(bits, Ordering::Relaxed),
        144 => track.samp_attack[3].store(bits, Ordering::Relaxed),
        145 => track.samp_decay[3].store(bits, Ordering::Relaxed),
        146 => track.samp_drive[3].store(bits, Ordering::Relaxed),
        147 => track.samp_level[3].store(bits, Ordering::Relaxed),
        _ => modul8_targets!(modul8_target_set_match, track, target, bits),
    }
}

fn fmmi_rand_next(state: &mut u32) -> u32 {
    let mut x = *state;
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    *state = x;
    x
}

fn fmmi_rand_unit(state: &mut u32) -> f32 {
    let v = fmmi_rand_next(state);
    (v as f32) / (u32::MAX as f32)
}

fn next_mosaic_rng(state: &mut u32) -> u32 {
    let mut x = *state;
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    *state = x;
    x
}

fn next_mosaic_rand_unit(state: &mut u32) -> f32 {
    let value = next_mosaic_rng(state);
    value as f32 / u32::MAX as f32
}

fn syndrm_rand_bool(state: &mut u32) -> bool {
    next_mosaic_rand_unit(state) >= 0.5
}

fn syndrm_rand_unit(state: &mut u32) -> f32 {
    next_mosaic_rand_unit(state).clamp(0.0, 1.0)
}

fn syndrm_rand_filter_type(state: &mut u32) -> u32 {
    let max = SYNDRM_FILTER_TYPES.max(1);
    let idx = (syndrm_rand_unit(state) * max as f32).floor() as u32;
    idx.min(max - 1)
}

fn fmmi_note_index_to_midi(index: i32) -> i32 {
    if index <= 0 {
        -1
    } else {
        FMMI_NOTE_BASE + (index - 1)
    }
}

fn fmmi_randomize_pattern(track: &Track, rng_state: &mut u32) {
    let amount = f32::from_bits(track.fmmi_randomize_steps_amount.load(Ordering::Relaxed))
        .clamp(0.0, 1.0);
    if amount <= 0.0 {
        return;
    }
    for step in 0..FMMI_STEPS {
        if amount >= 1.0 || fmmi_rand_unit(rng_state) <= amount {
            track
                .fmmi_sequencer_grid[step]
                .store(fmmi_rand_unit(rng_state) > 0.5, Ordering::Relaxed);
        }
    }
}

fn fmmi_reset_pattern(track: &Track) {
    for step in 0..FMMI_STEPS {
        let active = step < FMMI_PAGE_SIZE && step % 2 == 0;
        track
            .fmmi_sequencer_grid[step]
            .store(active, Ordering::Relaxed);
        track.fmmi_step_note[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_car_wave[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_wave[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_mode[step].store(-1, Ordering::Relaxed);
        track
            .fmmi_step_car_freq[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_car_detune[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_mod_value[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_mod_detune[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_index[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_feedback[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_drive[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_out_level[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_attack[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_decay[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_sustain[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_release[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_gate_length[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
    }
}

fn fmmi_clear_page(track: &Track, page: usize) {
    let start = page * FMMI_PAGE_SIZE;
    let end = (start + FMMI_PAGE_SIZE).min(FMMI_STEPS);
    for step in start..end {
        track.fmmi_sequencer_grid[step].store(false, Ordering::Relaxed);
        track.fmmi_step_note[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_car_wave[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_wave[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_mode[step].store(-1, Ordering::Relaxed);
        track
            .fmmi_step_car_freq[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_car_detune[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_mod_value[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_mod_detune[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_index[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_feedback[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_drive[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_out_level[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_attack[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_decay[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_sustain[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_release[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_gate_length[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
    }
}

fn fmmi_clear_sequence(track: &Track) {
    for step in 0..FMMI_STEPS {
        track.fmmi_sequencer_grid[step].store(false, Ordering::Relaxed);
        track.fmmi_step_note[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_car_wave[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_wave[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_mode[step].store(-1, Ordering::Relaxed);
        track
            .fmmi_step_car_freq[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_car_detune[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_mod_value[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_mod_detune[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_index[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_feedback[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_drive[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_out_level[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_attack[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_decay[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_sustain[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_release[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_gate_length[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
    }
}

fn fmmi_clear_steps_page(track: &Track, page: usize) {
    let start = page * FMMI_PAGE_SIZE;
    let end = (start + FMMI_PAGE_SIZE).min(FMMI_STEPS);
    for step in start..end {
        track.fmmi_sequencer_grid[step].store(false, Ordering::Relaxed);
    }
}

fn fmmi_clear_steps_all(track: &Track) {
    for step in 0..FMMI_STEPS {
        track.fmmi_sequencer_grid[step].store(false, Ordering::Relaxed);
    }
}

fn fmmi_clear_params_page(track: &Track, page: usize) {
    let start = page * FMMI_PAGE_SIZE;
    let end = (start + FMMI_PAGE_SIZE).min(FMMI_STEPS);
    for step in start..end {
        track.fmmi_step_note[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_car_wave[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_wave[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_mode[step].store(-1, Ordering::Relaxed);
        track
            .fmmi_step_car_freq[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_car_detune[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_mod_value[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_mod_detune[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_index[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_feedback[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_drive[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_out_level[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_attack[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_decay[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_sustain[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_release[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_gate_length[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
    }
}

fn fmmi_clear_params_all(track: &Track) {
    for step in 0..FMMI_STEPS {
        track.fmmi_step_note[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_car_wave[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_wave[step].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_mode[step].store(-1, Ordering::Relaxed);
        track
            .fmmi_step_car_freq[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_car_detune[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_mod_value[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_mod_detune[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_index[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_feedback[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_drive[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_out_level[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_attack[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_decay[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_sustain[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_amp_release[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
        track
            .fmmi_step_gate_length[step]
            .store((-1.0f32).to_bits(), Ordering::Relaxed);
    }
}

fn fmmi_randomize_step_params(
    track: &Track,
    step: usize,
    _mod_mode: u32,
    rng_state: &mut u32,
) {
    if step >= FMMI_STEPS {
        return;
    }
    let amount = f32::from_bits(track.fmmi_randomize_amount.load(Ordering::Relaxed))
        .clamp(0.0, 1.0);
    if amount <= 0.0 {
        return;
    }
    let rand_note = track.fmmi_rand_note_enabled.load(Ordering::Relaxed);
    let rand_car_wave = track.fmmi_rand_car_wave_enabled.load(Ordering::Relaxed);
    let rand_mod_wave = track.fmmi_rand_mod_wave_enabled.load(Ordering::Relaxed);
    let rand_mod_mode = track.fmmi_rand_mod_mode_enabled.load(Ordering::Relaxed);
    let rand_car_freq = track.fmmi_rand_car_freq_enabled.load(Ordering::Relaxed);
    let rand_car_detune = track.fmmi_rand_car_detune_enabled.load(Ordering::Relaxed);
    let rand_mod_value = track.fmmi_rand_mod_value_enabled.load(Ordering::Relaxed);
    let rand_mod_detune = track.fmmi_rand_mod_detune_enabled.load(Ordering::Relaxed);
    let rand_index = track.fmmi_rand_index_enabled.load(Ordering::Relaxed);
    let rand_feedback = track.fmmi_rand_feedback_enabled.load(Ordering::Relaxed);
    let rand_drive = track.fmmi_rand_drive_enabled.load(Ordering::Relaxed);
    let rand_out_level = track.fmmi_rand_out_level_enabled.load(Ordering::Relaxed);
    let rand_amp_attack = track.fmmi_rand_amp_attack_enabled.load(Ordering::Relaxed);
    let rand_amp_decay = track.fmmi_rand_amp_decay_enabled.load(Ordering::Relaxed);
    let rand_amp_sustain = track.fmmi_rand_amp_sustain_enabled.load(Ordering::Relaxed);
    let rand_amp_release = track.fmmi_rand_amp_release_enabled.load(Ordering::Relaxed);
    let rand_gate_length = track.fmmi_rand_gate_length_enabled.load(Ordering::Relaxed);
    let lerp = |base: f32, target: f32| base + (target - base) * amount;
    let base_car_freq =
        f32::from_bits(track.fmmi_car_freq.load(Ordering::Relaxed)).clamp(10.0, 20000.0);
    let base_car_detune =
        f32::from_bits(track.fmmi_car_detune.load(Ordering::Relaxed)).clamp(-1200.0, 1200.0);
    let base_mod_value = f32::from_bits(track.fmmi_mod_value.load(Ordering::Relaxed));
    let base_mod_detune =
        f32::from_bits(track.fmmi_mod_detune.load(Ordering::Relaxed)).clamp(-1200.0, 1200.0);
    let base_index = f32::from_bits(track.fmmi_index.load(Ordering::Relaxed)).max(0.0);
    let base_feedback = f32::from_bits(track.fmmi_feedback.load(Ordering::Relaxed)).max(0.0);
    let base_drive = f32::from_bits(track.fmmi_drive.load(Ordering::Relaxed)).clamp(0.0, 1.0);
    let base_out_level =
        f32::from_bits(track.fmmi_out_level.load(Ordering::Relaxed)).clamp(0.0, 1.5);
    let base_amp_attack =
        f32::from_bits(track.fmmi_amp_attack.load(Ordering::Relaxed)).clamp(0.0, 127.0);
    let base_amp_decay =
        f32::from_bits(track.fmmi_amp_decay.load(Ordering::Relaxed)).clamp(0.0, 127.0);
    let base_amp_sustain =
        f32::from_bits(track.fmmi_amp_sustain.load(Ordering::Relaxed)).clamp(0.0, 127.0);
    let base_amp_release =
        f32::from_bits(track.fmmi_amp_release.load(Ordering::Relaxed)).clamp(0.0, 127.0);
    let base_gate_length = {
        let v = f32::from_bits(track.fmmi_gate_length.load(Ordering::Relaxed));
        if v.is_finite() && v >= 0.0 { v } else { 0.0 }
    };

    let step_car_wave = (fmmi_rand_unit(rng_state) * 4.0).floor().min(3.0) as i32;
    let step_mod_wave = (fmmi_rand_unit(rng_state) * 4.0).floor().min(3.0) as i32;
    let step_mod_mode = if fmmi_rand_unit(rng_state) < 0.5 { 0 } else { 1 };
    let mod_mode_change = rand_mod_mode && (amount >= 1.0 || fmmi_rand_unit(rng_state) <= amount);
    let effective_mod_mode = if mod_mode_change {
        step_mod_mode as u32
    } else {
        track.fmmi_mod_mode.load(Ordering::Relaxed)
    };
    let scale_index = track.fmmi_scale_index.load(Ordering::Relaxed) as usize;
    let note = fmmi_random_note_in_scale(rng_state, scale_index);
    let car_freq = 30.0 + fmmi_rand_unit(rng_state) * 2000.0;
    let car_detune = (fmmi_rand_unit(rng_state) * 200.0 - 100.0).floor();
    let mod_val = if effective_mod_mode == 1 {
        fmmi_rand_unit(rng_state) * 16.0
    } else {
        fmmi_rand_unit(rng_state) * 20_000.0
    };
    let mod_detune = (fmmi_rand_unit(rng_state) * 200.0 - 100.0).floor();
    let index = (fmmi_rand_unit(rng_state) * 1500.0).floor();
    let feedback = (fmmi_rand_unit(rng_state) * 600.0).floor();
    let drive = fmmi_rand_unit(rng_state);
    let out_level = fmmi_rand_unit(rng_state) * 1.5;
    let amp_attack = fmmi_rand_unit(rng_state) * 127.0;
    let amp_decay = fmmi_rand_unit(rng_state) * 127.0;
    let amp_sustain = fmmi_rand_unit(rng_state) * 127.0;
    let amp_release = fmmi_rand_unit(rng_state) * 127.0;
    let gate_length = fmmi_rand_unit(rng_state) * 3000.0;

    if rand_note && (amount >= 1.0 || fmmi_rand_unit(rng_state) <= amount) {
        track.fmmi_step_note[step].store(note, Ordering::Relaxed);
    }
    if rand_car_wave && (amount >= 1.0 || fmmi_rand_unit(rng_state) <= amount) {
        track
            .fmmi_step_car_wave[step]
            .store(step_car_wave, Ordering::Relaxed);
    }
    if rand_mod_wave && (amount >= 1.0 || fmmi_rand_unit(rng_state) <= amount) {
        track
            .fmmi_step_mod_wave[step]
            .store(step_mod_wave, Ordering::Relaxed);
    }
    if rand_mod_mode && mod_mode_change {
        track
            .fmmi_step_mod_mode[step]
            .store(step_mod_mode, Ordering::Relaxed);
    }
    if rand_car_freq {
        track
            .fmmi_step_car_freq[step]
            .store(lerp(base_car_freq, car_freq).to_bits(), Ordering::Relaxed);
    }
    if rand_car_detune {
        track
            .fmmi_step_car_detune[step]
            .store(lerp(base_car_detune, car_detune).to_bits(), Ordering::Relaxed);
    }
    if rand_mod_value {
        track
            .fmmi_step_mod_value[step]
            .store(lerp(base_mod_value, mod_val).to_bits(), Ordering::Relaxed);
    }
    if rand_mod_detune {
        track
            .fmmi_step_mod_detune[step]
            .store(lerp(base_mod_detune, mod_detune).to_bits(), Ordering::Relaxed);
    }
    if rand_index {
        track
            .fmmi_step_index[step]
            .store(lerp(base_index, index).to_bits(), Ordering::Relaxed);
    }
    if rand_feedback {
        track
            .fmmi_step_feedback[step]
            .store(lerp(base_feedback, feedback).to_bits(), Ordering::Relaxed);
    }
    if rand_drive {
        track
            .fmmi_step_drive[step]
            .store(lerp(base_drive, drive).to_bits(), Ordering::Relaxed);
    }
    if rand_out_level {
        track
            .fmmi_step_out_level[step]
            .store(lerp(base_out_level, out_level).to_bits(), Ordering::Relaxed);
    }
    if rand_amp_attack {
        track
            .fmmi_step_amp_attack[step]
            .store(lerp(base_amp_attack, amp_attack).to_bits(), Ordering::Relaxed);
    }
    if rand_amp_decay {
        track
            .fmmi_step_amp_decay[step]
            .store(lerp(base_amp_decay, amp_decay).to_bits(), Ordering::Relaxed);
    }
    if rand_amp_sustain {
        track
            .fmmi_step_amp_sustain[step]
            .store(lerp(base_amp_sustain, amp_sustain).to_bits(), Ordering::Relaxed);
    }
    if rand_amp_release {
        track
            .fmmi_step_amp_release[step]
            .store(lerp(base_amp_release, amp_release).to_bits(), Ordering::Relaxed);
    }
    if rand_gate_length {
        track
            .fmmi_step_gate_length[step]
            .store(lerp(base_gate_length, gate_length).to_bits(), Ordering::Relaxed);
    }
}

fn fmmi_randomize_page_params(track: &Track, page: usize, mod_mode: u32, rng_state: &mut u32) {
    let start = page * FMMI_PAGE_SIZE;
    let end = (start + FMMI_PAGE_SIZE).min(FMMI_STEPS);
    for step in start..end {
        fmmi_randomize_step_params(track, step, mod_mode, rng_state);
    }
}

fn fmmi_randomize_all_params(track: &Track, mod_mode: u32, rng_state: &mut u32) {
    for step in 0..FMMI_STEPS {
        fmmi_randomize_step_params(track, step, mod_mode, rng_state);
    }
}

fn monomi_lerp_rand(base: f32, min: f32, max: f32, amount: f32, rng_state: &mut u32) -> f32 {
    let rand = min + fmmi_rand_unit(rng_state) * (max - min);
    base + (rand - base) * amount
}

fn monomi_randomize_notes_step(track: &Track, step: usize, rng_state: &mut u32) {
    if step >= MONOMI_STEPS {
        return;
    }
    let active = fmmi_rand_unit(rng_state) > 0.4;
    track.monomi_sequencer_grid[step].store(active, Ordering::Relaxed);
    let scale_index = track.monomi_scale_index.load(Ordering::Relaxed) as usize;
    let note = monomi_random_note_in_scale(rng_state, scale_index);
    track.monomi_step_note[step].store(note, Ordering::Relaxed);
}

fn monomi_randomize_notes_page(track: &Track, page: usize, rng_state: &mut u32) {
    let start = page * MONOMI_PAGE_SIZE;
    let end = (start + MONOMI_PAGE_SIZE).min(MONOMI_STEPS);
    for step in start..end {
        monomi_randomize_notes_step(track, step, rng_state);
    }
}

fn monomi_randomize_notes_all(track: &Track, rng_state: &mut u32) {
    for step in 0..MONOMI_STEPS {
        monomi_randomize_notes_step(track, step, rng_state);
    }
}

fn monomi_reset_notes(track: &Track) {
    for step in 0..MONOMI_STEPS {
        let active = step < MONOMI_PAGE_SIZE;
        track.monomi_sequencer_grid[step].store(active, Ordering::Relaxed);
        track.monomi_step_note[step].store(-1, Ordering::Relaxed);
    }
}

fn monomi_randomize_params_step(track: &Track, step: usize, rng_state: &mut u32) {
    if step >= MONOMI_STEPS {
        return;
    }
    let amount =
        f32::from_bits(track.monomi_randomize_amount.load(Ordering::Relaxed)).clamp(0.0, 1.0);
    let cutoff = f32::from_bits(track.monomi_cutoff.load(Ordering::Relaxed));
    let resonance = f32::from_bits(track.monomi_resonance.load(Ordering::Relaxed));
    let filter_morph = f32::from_bits(track.monomi_filter_morph.load(Ordering::Relaxed));
    let glide = f32::from_bits(track.monomi_glide.load(Ordering::Relaxed));
    let amp_attack = f32::from_bits(track.monomi_amp_attack.load(Ordering::Relaxed));
    let amp_decay = f32::from_bits(track.monomi_amp_decay.load(Ordering::Relaxed));
    let amp_sustain = f32::from_bits(track.monomi_amp_sustain.load(Ordering::Relaxed));
    let amp_release = f32::from_bits(track.monomi_amp_release.load(Ordering::Relaxed));

    if track.monomi_rand_cutoff.load(Ordering::Relaxed) {
        let v = monomi_lerp_rand(cutoff, 200.0, 8000.0, amount, rng_state);
        track.monomi_step_cutoff[step].store(v.to_bits(), Ordering::Relaxed);
    }
    if track.monomi_rand_resonance.load(Ordering::Relaxed) {
        let v = monomi_lerp_rand(resonance, 0.1, 8.0, amount, rng_state);
        track.monomi_step_resonance[step].store(v.to_bits(), Ordering::Relaxed);
    }
    if track.monomi_rand_env_attack.load(Ordering::Relaxed) {
        let v = monomi_lerp_rand(amp_attack, 0.0, 128.0, amount, rng_state);
        track.monomi_step_env_attack[step].store(v.to_bits(), Ordering::Relaxed);
    }
    if track.monomi_rand_env_decay.load(Ordering::Relaxed) {
        let v = monomi_lerp_rand(amp_decay, 1.0, 128.0, amount, rng_state);
        track.monomi_step_env_decay[step].store(v.to_bits(), Ordering::Relaxed);
    }
    if track.monomi_rand_env_sustain.load(Ordering::Relaxed) {
        let v = monomi_lerp_rand(amp_sustain, 1.0, 128.0, amount, rng_state);
        track.monomi_step_env_sustain[step].store(v.to_bits(), Ordering::Relaxed);
    }
    if track.monomi_rand_env_release.load(Ordering::Relaxed) {
        let v = monomi_lerp_rand(amp_release, 1.0, 128.0, amount, rng_state);
        track.monomi_step_env_release[step].store(v.to_bits(), Ordering::Relaxed);
    }
    if track.monomi_rand_gate.load(Ordering::Relaxed) {
        let v = monomi_lerp_rand(1.0, 1.0, 128.0, amount, rng_state).round();
        track.monomi_step_gate[step].store(v.to_bits(), Ordering::Relaxed);
    }
    if track.monomi_rand_filter_morph.load(Ordering::Relaxed) {
        let v = monomi_lerp_rand(filter_morph, 0.0, 1.0, amount, rng_state);
        track.monomi_step_filter_morph[step].store(v.to_bits(), Ordering::Relaxed);
    }
    if track.monomi_rand_glide.load(Ordering::Relaxed) {
        let v = monomi_lerp_rand(glide, 0.0, 500.0, amount, rng_state);
        track.monomi_step_glide[step].store(v.to_bits(), Ordering::Relaxed);
    }
    for osc in 0..3 {
        if track.monomi_rand_osc_mix[osc].load(Ordering::Relaxed) {
            let base = f32::from_bits(track.monomi_osc_mix[osc].load(Ordering::Relaxed));
            let v = monomi_lerp_rand(base, 0.0, 1.0, amount, rng_state);
            track.monomi_step_osc_mix[osc][step].store(v.to_bits(), Ordering::Relaxed);
        }
        if track.monomi_rand_osc_detune[osc].load(Ordering::Relaxed) {
            let base = f32::from_bits(track.monomi_osc_detune[osc].load(Ordering::Relaxed));
            let v = monomi_lerp_rand(base, -100.0, 100.0, amount, rng_state);
            track.monomi_step_osc_detune[osc][step].store(v.to_bits(), Ordering::Relaxed);
        }
        if track.monomi_rand_osc_pwm[osc].load(Ordering::Relaxed) {
            let base = f32::from_bits(track.monomi_osc_pwm[osc].load(Ordering::Relaxed));
            let v = monomi_lerp_rand(base, 0.05, 0.95, amount, rng_state);
            track.monomi_step_osc_pwm[osc][step].store(v.to_bits(), Ordering::Relaxed);
        }
    }
}

fn monomi_randomize_params_page(track: &Track, page: usize, rng_state: &mut u32) {
    let start = page * MONOMI_PAGE_SIZE;
    let end = (start + MONOMI_PAGE_SIZE).min(MONOMI_STEPS);
    for step in start..end {
        monomi_randomize_params_step(track, step, rng_state);
    }
}

fn monomi_randomize_params_all(track: &Track, rng_state: &mut u32) {
    for step in 0..MONOMI_STEPS {
        monomi_randomize_params_step(track, step, rng_state);
    }
}

fn monomi_reset_params(track: &Track) {
    for step in 0..MONOMI_STEPS {
        track.monomi_step_cutoff[step].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.monomi_step_resonance[step].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.monomi_step_env_attack[step].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.monomi_step_env_decay[step].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.monomi_step_env_sustain[step].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.monomi_step_env_release[step].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.monomi_step_gate[step].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.monomi_step_filter_morph[step].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.monomi_step_glide[step].store((-1.0f32).to_bits(), Ordering::Relaxed);
        for osc in 0..3 {
            track.monomi_step_osc_mix[osc][step].store((-1.0f32).to_bits(), Ordering::Relaxed);
            track.monomi_step_osc_detune[osc][step]
                .store((-1.0f32).to_bits(), Ordering::Relaxed);
            track.monomi_step_osc_pwm[osc][step].store((-1.0f32).to_bits(), Ordering::Relaxed);
        }
    }
}

fn fmmi_randomize_steps_page(track: &Track, page: usize, rng_state: &mut u32) {
    let start = page * FMMI_PAGE_SIZE;
    let end = (start + FMMI_PAGE_SIZE).min(FMMI_STEPS);
    let amount = f32::from_bits(track.fmmi_randomize_steps_amount.load(Ordering::Relaxed))
        .clamp(0.0, 1.0);
    if amount <= 0.0 {
        return;
    }
    for step in start..end {
        if amount >= 1.0 || fmmi_rand_unit(rng_state) <= amount {
            track
                .fmmi_sequencer_grid[step]
                .store(fmmi_rand_unit(rng_state) > 0.5, Ordering::Relaxed);
        }
    }
}

fn fmmi_randomize_global(track: &Track, rng_state: &mut u32) {
    let amount = f32::from_bits(track.fmmi_randomize_amount.load(Ordering::Relaxed))
        .clamp(0.0, 1.0);
    if amount <= 0.0 {
        return;
    }
    let lerp = |base: f32, target: f32| base + (target - base) * amount;
    let base_car_detune =
        f32::from_bits(track.fmmi_car_detune.load(Ordering::Relaxed)).clamp(-1200.0, 1200.0);
    let base_mod_detune =
        f32::from_bits(track.fmmi_mod_detune.load(Ordering::Relaxed)).clamp(-1200.0, 1200.0);
    let base_mod_value = f32::from_bits(track.fmmi_mod_value.load(Ordering::Relaxed));
    let base_index = f32::from_bits(track.fmmi_index.load(Ordering::Relaxed)).max(0.0);
    let base_feedback = f32::from_bits(track.fmmi_feedback.load(Ordering::Relaxed)).max(0.0);
    let base_drive = f32::from_bits(track.fmmi_drive.load(Ordering::Relaxed)).clamp(0.0, 1.0);
    let wave = (fmmi_rand_unit(rng_state) * 4.0).floor().min(3.0) as u32;
    let mod_wave = (fmmi_rand_unit(rng_state) * 4.0).floor().min(3.0) as u32;
    let mod_mode = if fmmi_rand_unit(rng_state) < 0.6 { 1 } else { 0 };
    let mod_val = if mod_mode == 1 {
        2.0_f32.powf(fmmi_rand_unit(rng_state) * 8.0 - 3.0)
    } else {
        50.0 + fmmi_rand_unit(rng_state) * 1000.0
    };
    let index = (fmmi_rand_unit(rng_state) * 1500.0).floor();
    let feedback = (fmmi_rand_unit(rng_state) * 600.0).floor();
    let drive = fmmi_rand_unit(rng_state);
    let car_detune = (fmmi_rand_unit(rng_state) * 200.0 - 100.0).floor();
    let mod_detune = (fmmi_rand_unit(rng_state) * 200.0 - 100.0).floor();

    if amount >= 1.0 || fmmi_rand_unit(rng_state) <= amount {
        track.fmmi_car_wave.store(wave, Ordering::Relaxed);
    }
    if amount >= 1.0 || fmmi_rand_unit(rng_state) <= amount {
        track.fmmi_mod_wave.store(mod_wave, Ordering::Relaxed);
    }
    if amount >= 1.0 || fmmi_rand_unit(rng_state) <= amount {
        track.fmmi_mod_mode.store(mod_mode, Ordering::Relaxed);
    }
    track
        .fmmi_mod_value
        .store(lerp(base_mod_value, mod_val).to_bits(), Ordering::Relaxed);
    track
        .fmmi_index
        .store(lerp(base_index, index).to_bits(), Ordering::Relaxed);
    track
        .fmmi_feedback
        .store(lerp(base_feedback, feedback).to_bits(), Ordering::Relaxed);
    track
        .fmmi_drive
        .store(lerp(base_drive, drive).to_bits(), Ordering::Relaxed);
    track
        .fmmi_car_detune
        .store(lerp(base_car_detune, car_detune).to_bits(), Ordering::Relaxed);
    track
        .fmmi_mod_detune
        .store(lerp(base_mod_detune, mod_detune).to_bits(), Ordering::Relaxed);
}

fn fmmi_copy_apply(
    track: &Track,
    start: usize,
    len: usize,
    include_steps: bool,
    include_params: bool,
    page_scoped: bool,
) {
    let mut buffer = track.fmmi_copy_buffer.lock();
    buffer.has_data = true;
    buffer.len = len;
    buffer.include_steps = include_steps;
    buffer.include_params = include_params;
    buffer.page_scoped = page_scoped;
    buffer.steps.clear();
    buffer.params.clear();

    if include_steps {
        for i in 0..len {
            let idx = start + i;
            if idx < FMMI_STEPS {
                buffer
                    .steps
                    .push(track.fmmi_sequencer_grid[idx].load(Ordering::Relaxed));
            }
        }
    }

    if include_params {
        for i in 0..len {
            let idx = start + i;
            if idx < FMMI_STEPS {
                buffer.params.push(FMMIStepParamsCopy {
                    note: track.fmmi_step_note[idx].load(Ordering::Relaxed),
                    car_wave: track.fmmi_step_car_wave[idx].load(Ordering::Relaxed),
                    mod_wave: track.fmmi_step_mod_wave[idx].load(Ordering::Relaxed),
                    mod_mode: track.fmmi_step_mod_mode[idx].load(Ordering::Relaxed),
                    car_freq: track.fmmi_step_car_freq[idx].load(Ordering::Relaxed),
                    car_detune: track.fmmi_step_car_detune[idx].load(Ordering::Relaxed),
                    mod_value: track.fmmi_step_mod_value[idx].load(Ordering::Relaxed),
                    mod_detune: track.fmmi_step_mod_detune[idx].load(Ordering::Relaxed),
                    index: track.fmmi_step_index[idx].load(Ordering::Relaxed),
                    feedback: track.fmmi_step_feedback[idx].load(Ordering::Relaxed),
                    drive: track.fmmi_step_drive[idx].load(Ordering::Relaxed),
                    out_level: track.fmmi_step_out_level[idx].load(Ordering::Relaxed),
                    amp_attack: track.fmmi_step_amp_attack[idx].load(Ordering::Relaxed),
                    amp_decay: track.fmmi_step_amp_decay[idx].load(Ordering::Relaxed),
                    amp_sustain: track.fmmi_step_amp_sustain[idx].load(Ordering::Relaxed),
                    amp_release: track.fmmi_step_amp_release[idx].load(Ordering::Relaxed),
                    gate_length: track.fmmi_step_gate_length[idx].load(Ordering::Relaxed),
                });
            }
        }
    }
}

fn fmmi_paste_apply(track: &Track, target_page: usize) {
    let buffer = track.fmmi_copy_buffer.lock();
    if !buffer.has_data {
        return;
    }
    let (start, len) = if buffer.page_scoped {
        (target_page * FMMI_PAGE_SIZE, FMMI_PAGE_SIZE)
    } else {
        (0, FMMI_STEPS)
    };
    let copy_len = buffer.len.min(len);
    for i in 0..copy_len {
        let idx = start + i;
        if idx >= FMMI_STEPS {
            break;
        }
        if buffer.include_steps {
            if let Some(active) = buffer.steps.get(i) {
                track.fmmi_sequencer_grid[idx].store(*active, Ordering::Relaxed);
            }
        }
        if buffer.include_params {
            if let Some(params) = buffer.params.get(i) {
                track
                    .fmmi_step_note[idx]
                    .store(params.note, Ordering::Relaxed);
                track
                    .fmmi_step_car_wave[idx]
                    .store(params.car_wave, Ordering::Relaxed);
                track
                    .fmmi_step_mod_wave[idx]
                    .store(params.mod_wave, Ordering::Relaxed);
                track
                    .fmmi_step_mod_mode[idx]
                    .store(params.mod_mode, Ordering::Relaxed);
                track
                    .fmmi_step_car_freq[idx]
                    .store(params.car_freq, Ordering::Relaxed);
                track
                    .fmmi_step_car_detune[idx]
                    .store(params.car_detune, Ordering::Relaxed);
                track
                    .fmmi_step_mod_value[idx]
                    .store(params.mod_value, Ordering::Relaxed);
                track
                    .fmmi_step_mod_detune[idx]
                    .store(params.mod_detune, Ordering::Relaxed);
                track
                    .fmmi_step_index[idx]
                    .store(params.index, Ordering::Relaxed);
                track
                    .fmmi_step_feedback[idx]
                    .store(params.feedback, Ordering::Relaxed);
                track
                    .fmmi_step_drive[idx]
                    .store(params.drive, Ordering::Relaxed);
                track
                    .fmmi_step_out_level[idx]
                    .store(params.out_level, Ordering::Relaxed);
                track
                    .fmmi_step_amp_attack[idx]
                    .store(params.amp_attack, Ordering::Relaxed);
                track
                    .fmmi_step_amp_decay[idx]
                    .store(params.amp_decay, Ordering::Relaxed);
                track
                    .fmmi_step_amp_sustain[idx]
                    .store(params.amp_sustain, Ordering::Relaxed);
                track
                    .fmmi_step_amp_release[idx]
                    .store(params.amp_release, Ordering::Relaxed);
                track
                    .fmmi_step_gate_length[idx]
                    .store(params.gate_length, Ordering::Relaxed);
            }
        }
    }
}

fn truncate_label(input: &str, max_chars: usize, ellipses: bool) -> String {
    if max_chars == 0 {
        return input.to_string();
    }
    let mut chars = input.chars();
    let clipped: String = chars.by_ref().take(max_chars).collect();
    if chars.next().is_some() {
        if ellipses {
            format!("{clipped}...")
        } else {
            clipped
        }
    } else {
        clipped
    }
}

fn syndrm_lane_mask(lane: u32) -> u16 {
    if lane < SYNDRM_LANES as u32 {
        1u16 << lane
    } else {
        0
    }
}

fn syndrm_all_lanes_mask() -> u16 {
    if SYNDRM_LANES == 0 {
        0
    } else {
        (1u16 << SYNDRM_LANES) - 1
    }
}

fn syndrm_randomize_steps(
    track: &Track,
    rng_state: &mut u32,
    lanes: u16,
    start: usize,
    len: usize,
    amount: f32,
) {
    let amt = amount.clamp(0.0, 1.0);
    if amt <= 0.0 {
        return;
    }
    let end = (start + len).min(SYNDRM_STEPS);
    for step in start..end {
        if (lanes & (1 << 0)) != 0 {
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.kick_sequencer_grid[step]
                    .store(syndrm_rand_bool(rng_state), Ordering::Relaxed);
            }
        }
        if (lanes & (1 << 1)) != 0 {
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.snare_sequencer_grid[step]
                    .store(syndrm_rand_bool(rng_state), Ordering::Relaxed);
            }
        }
        if (lanes & (1 << 2)) != 0 {
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.clap_sequencer_grid[step]
                    .store(syndrm_rand_bool(rng_state), Ordering::Relaxed);
            }
        }
        if (lanes & (1 << 3)) != 0 {
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.hat_sequencer_grid[step]
                    .store(syndrm_rand_bool(rng_state), Ordering::Relaxed);
            }
        }
        if (lanes & (1 << 4)) != 0 {
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.perc1_sequencer_grid[step]
                    .store(syndrm_rand_bool(rng_state), Ordering::Relaxed);
            }
        }
        if (lanes & (1 << 5)) != 0 {
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.perc2_sequencer_grid[step]
                    .store(syndrm_rand_bool(rng_state), Ordering::Relaxed);
            }
        }
        if (lanes & (1 << 6)) != 0 {
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track
                    .crash_sequencer_grid[step]
                    .store(syndrm_rand_bool(rng_state), Ordering::Relaxed);
            }
        }
        for channel_idx in 0..SYNDRM_SAMPLE_CHANNELS {
            let lane_bit = 1u16 << (7 + channel_idx);
            if (lanes & lane_bit) != 0 {
                if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                    track.samp_sequencer_grid[channel_idx][step]
                        .store(syndrm_rand_bool(rng_state), Ordering::Relaxed);
                }
            }
        }
    }
}

fn syndrm_randomize_params(
    track: &Track,
    rng_state: &mut u32,
    lanes: u16,
    start: usize,
    len: usize,
    amount: f32,
) {
    let amt = amount.clamp(0.0, 1.0);
    if amt <= 0.0 {
        return;
    }
    let lerp = |current: f32, target: f32| current + (target - current) * amt;
    if (lanes & (1 << 0)) != 0 {
        let current_pitch_env =
            f32::from_bits(track.kick_pitch_env_amount.load(Ordering::Relaxed));
        track
            .kick_pitch_env_amount
            .store(lerp(current_pitch_env, syndrm_rand_unit(rng_state)).to_bits(), Ordering::Relaxed);
    }
    let end = (start + len).min(SYNDRM_STEPS);
    for step in start..end {
        if (lanes & (1 << 0)) != 0 {
            track.kick_step_override_enabled[step].store(true, Ordering::Relaxed);
            let current_pitch = f32::from_bits(track.kick_step_pitch[step].load(Ordering::Relaxed));
            let current_decay = f32::from_bits(track.kick_step_decay[step].load(Ordering::Relaxed));
            let current_attack = f32::from_bits(track.kick_step_attack[step].load(Ordering::Relaxed));
            let current_drive = f32::from_bits(track.kick_step_drive[step].load(Ordering::Relaxed));
            let current_level = f32::from_bits(track.kick_step_level[step].load(Ordering::Relaxed));
            let current_filter_cutoff =
                f32::from_bits(track.kick_step_filter_cutoff[step].load(Ordering::Relaxed));
            let current_filter_resonance =
                f32::from_bits(track.kick_step_filter_resonance[step].load(Ordering::Relaxed));

            track.kick_step_pitch[step].store(
                lerp(current_pitch, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.kick_step_decay[step].store(
                lerp(current_decay, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.kick_step_attack[step].store(
                lerp(current_attack, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.kick_step_drive[step].store(
                lerp(current_drive, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.kick_step_level[step].store(
                lerp(current_level, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.kick_step_filter_type[step]
                    .store(syndrm_rand_filter_type(rng_state), Ordering::Relaxed);
            }
            track.kick_step_filter_cutoff[step].store(
                lerp(current_filter_cutoff, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.kick_step_filter_resonance[step].store(
                lerp(current_filter_resonance, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
        }
        if (lanes & (1 << 1)) != 0 {
            track.snare_step_override_enabled[step].store(true, Ordering::Relaxed);
            let current_tone = f32::from_bits(track.snare_step_tone[step].load(Ordering::Relaxed));
            let current_decay = f32::from_bits(track.snare_step_decay[step].load(Ordering::Relaxed));
            let current_snappy =
                f32::from_bits(track.snare_step_snappy[step].load(Ordering::Relaxed));
            let current_attack =
                f32::from_bits(track.snare_step_attack[step].load(Ordering::Relaxed));
            let current_drive = f32::from_bits(track.snare_step_drive[step].load(Ordering::Relaxed));
            let current_level = f32::from_bits(track.snare_step_level[step].load(Ordering::Relaxed));
            let current_filter_cutoff =
                f32::from_bits(track.snare_step_filter_cutoff[step].load(Ordering::Relaxed));
            let current_filter_resonance =
                f32::from_bits(track.snare_step_filter_resonance[step].load(Ordering::Relaxed));

            track.snare_step_tone[step].store(
                lerp(current_tone, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.snare_step_decay[step].store(
                lerp(current_decay, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.snare_step_snappy[step].store(
                lerp(current_snappy, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.snare_step_attack[step].store(
                lerp(current_attack, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.snare_step_drive[step].store(
                lerp(current_drive, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.snare_step_level[step].store(
                lerp(current_level, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.snare_step_filter_type[step]
                    .store(syndrm_rand_filter_type(rng_state), Ordering::Relaxed);
            }
            track.snare_step_filter_cutoff[step].store(
                lerp(current_filter_cutoff, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.snare_step_filter_resonance[step].store(
                lerp(current_filter_resonance, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
        }
        if (lanes & (1 << 2)) != 0 {
            track.clap_step_override_enabled[step].store(true, Ordering::Relaxed);
            let current_pitch = f32::from_bits(track.clap_step_pitch[step].load(Ordering::Relaxed));
            let current_decay = f32::from_bits(track.clap_step_decay[step].load(Ordering::Relaxed));
            let current_tone = f32::from_bits(track.clap_step_tone[step].load(Ordering::Relaxed));
            let current_drive = f32::from_bits(track.clap_step_drive[step].load(Ordering::Relaxed));
            let current_level = f32::from_bits(track.clap_step_level[step].load(Ordering::Relaxed));
            let current_filter_cutoff =
                f32::from_bits(track.clap_step_filter_cutoff[step].load(Ordering::Relaxed));
            let current_filter_resonance =
                f32::from_bits(track.clap_step_filter_resonance[step].load(Ordering::Relaxed));

            track.clap_step_pitch[step].store(
                lerp(current_pitch, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.clap_step_decay[step].store(
                lerp(current_decay, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.clap_step_tone[step].store(
                lerp(current_tone, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.clap_step_drive[step].store(
                lerp(current_drive, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.clap_step_level[step].store(
                lerp(current_level, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.clap_step_filter_type[step]
                    .store(syndrm_rand_filter_type(rng_state), Ordering::Relaxed);
            }
            track.clap_step_filter_cutoff[step].store(
                lerp(current_filter_cutoff, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.clap_step_filter_resonance[step].store(
                lerp(current_filter_resonance, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
        }
        if (lanes & (1 << 3)) != 0 {
            track.hat_step_override_enabled[step].store(true, Ordering::Relaxed);
            let current_pitch = f32::from_bits(track.hat_step_pitch[step].load(Ordering::Relaxed));
            let current_decay = f32::from_bits(track.hat_step_decay[step].load(Ordering::Relaxed));
            let current_tone = f32::from_bits(track.hat_step_tone[step].load(Ordering::Relaxed));
            let current_drive = f32::from_bits(track.hat_step_drive[step].load(Ordering::Relaxed));
            let current_level = f32::from_bits(track.hat_step_level[step].load(Ordering::Relaxed));
            let current_filter_cutoff =
                f32::from_bits(track.hat_step_filter_cutoff[step].load(Ordering::Relaxed));
            let current_filter_resonance =
                f32::from_bits(track.hat_step_filter_resonance[step].load(Ordering::Relaxed));

            track.hat_step_pitch[step].store(
                lerp(current_pitch, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.hat_step_decay[step].store(
                lerp(current_decay, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.hat_step_tone[step].store(
                lerp(current_tone, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.hat_step_drive[step].store(
                lerp(current_drive, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.hat_step_level[step].store(
                lerp(current_level, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.hat_step_filter_type[step]
                    .store(syndrm_rand_filter_type(rng_state), Ordering::Relaxed);
            }
            track.hat_step_filter_cutoff[step].store(
                lerp(current_filter_cutoff, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.hat_step_filter_resonance[step].store(
                lerp(current_filter_resonance, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
        }
        if (lanes & (1 << 4)) != 0 {
            track.perc1_step_override_enabled[step].store(true, Ordering::Relaxed);
            let current_pitch = f32::from_bits(track.perc1_step_pitch[step].load(Ordering::Relaxed));
            let current_decay = f32::from_bits(track.perc1_step_decay[step].load(Ordering::Relaxed));
            let current_tone = f32::from_bits(track.perc1_step_tone[step].load(Ordering::Relaxed));
            let current_drive = f32::from_bits(track.perc1_step_drive[step].load(Ordering::Relaxed));
            let current_level = f32::from_bits(track.perc1_step_level[step].load(Ordering::Relaxed));
            let current_filter_cutoff =
                f32::from_bits(track.perc1_step_filter_cutoff[step].load(Ordering::Relaxed));
            let current_filter_resonance =
                f32::from_bits(track.perc1_step_filter_resonance[step].load(Ordering::Relaxed));

            track.perc1_step_pitch[step].store(
                lerp(current_pitch, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.perc1_step_decay[step].store(
                lerp(current_decay, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.perc1_step_tone[step].store(
                lerp(current_tone, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.perc1_step_drive[step].store(
                lerp(current_drive, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.perc1_step_level[step].store(
                lerp(current_level, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.perc1_step_filter_type[step]
                    .store(syndrm_rand_filter_type(rng_state), Ordering::Relaxed);
            }
            track.perc1_step_filter_cutoff[step].store(
                lerp(current_filter_cutoff, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.perc1_step_filter_resonance[step].store(
                lerp(current_filter_resonance, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
        }
        if (lanes & (1 << 5)) != 0 {
            track.perc2_step_override_enabled[step].store(true, Ordering::Relaxed);
            let current_pitch = f32::from_bits(track.perc2_step_pitch[step].load(Ordering::Relaxed));
            let current_decay = f32::from_bits(track.perc2_step_decay[step].load(Ordering::Relaxed));
            let current_tone = f32::from_bits(track.perc2_step_tone[step].load(Ordering::Relaxed));
            let current_drive = f32::from_bits(track.perc2_step_drive[step].load(Ordering::Relaxed));
            let current_level = f32::from_bits(track.perc2_step_level[step].load(Ordering::Relaxed));
            let current_filter_cutoff =
                f32::from_bits(track.perc2_step_filter_cutoff[step].load(Ordering::Relaxed));
            let current_filter_resonance =
                f32::from_bits(track.perc2_step_filter_resonance[step].load(Ordering::Relaxed));

            track.perc2_step_pitch[step].store(
                lerp(current_pitch, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.perc2_step_decay[step].store(
                lerp(current_decay, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.perc2_step_tone[step].store(
                lerp(current_tone, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.perc2_step_drive[step].store(
                lerp(current_drive, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.perc2_step_level[step].store(
                lerp(current_level, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.perc2_step_filter_type[step]
                    .store(syndrm_rand_filter_type(rng_state), Ordering::Relaxed);
            }
            track.perc2_step_filter_cutoff[step].store(
                lerp(current_filter_cutoff, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.perc2_step_filter_resonance[step].store(
                lerp(current_filter_resonance, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
        }
        if (lanes & (1 << 6)) != 0 {
            track
                .crash_step_override_enabled[step]
                .store(true, Ordering::Relaxed);
            let current_pitch = f32::from_bits(track.crash_step_pitch[step].load(Ordering::Relaxed));
            let current_decay = f32::from_bits(track.crash_step_decay[step].load(Ordering::Relaxed));
            let current_tone = f32::from_bits(track.crash_step_tone[step].load(Ordering::Relaxed));
            let current_drive = f32::from_bits(track.crash_step_drive[step].load(Ordering::Relaxed));
            let current_level = f32::from_bits(track.crash_step_level[step].load(Ordering::Relaxed));
            let current_filter_cutoff =
                f32::from_bits(track.crash_step_filter_cutoff[step].load(Ordering::Relaxed));
            let current_filter_resonance =
                f32::from_bits(track.crash_step_filter_resonance[step].load(Ordering::Relaxed));

            track.crash_step_pitch[step].store(
                lerp(current_pitch, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.crash_step_decay[step].store(
                lerp(current_decay, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.crash_step_tone[step].store(
                lerp(current_tone, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.crash_step_drive[step].store(
                lerp(current_drive, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.crash_step_level[step].store(
                lerp(current_level, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                track.crash_step_filter_type[step]
                    .store(syndrm_rand_filter_type(rng_state), Ordering::Relaxed);
            }
            track.crash_step_filter_cutoff[step].store(
                lerp(current_filter_cutoff, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
            track.crash_step_filter_resonance[step].store(
                lerp(current_filter_resonance, syndrm_rand_unit(rng_state)).to_bits(),
                Ordering::Relaxed,
            );
        }
        for channel_idx in 0..SYNDRM_SAMPLE_CHANNELS {
            let lane_bit = 1u16 << (7 + channel_idx);
            if (lanes & lane_bit) != 0 {
                track.samp_step_override_enabled[channel_idx][step]
                    .store(true, Ordering::Relaxed);
                let current_pitch =
                    f32::from_bits(track.samp_step_pitch[channel_idx][step].load(Ordering::Relaxed));
                let current_attack =
                    f32::from_bits(track.samp_step_attack[channel_idx][step].load(Ordering::Relaxed));
                let current_decay =
                    f32::from_bits(track.samp_step_decay[channel_idx][step].load(Ordering::Relaxed));
                let current_drive =
                    f32::from_bits(track.samp_step_drive[channel_idx][step].load(Ordering::Relaxed));
                let current_level =
                    f32::from_bits(track.samp_step_level[channel_idx][step].load(Ordering::Relaxed));
                let current_filter_cutoff = f32::from_bits(
                    track.samp_step_filter_cutoff[channel_idx][step].load(Ordering::Relaxed),
                );
                let current_filter_resonance = f32::from_bits(
                    track.samp_step_filter_resonance[channel_idx][step].load(Ordering::Relaxed),
                );

                track.samp_step_pitch[channel_idx][step].store(
                    lerp(current_pitch, syndrm_rand_unit(rng_state)).to_bits(),
                    Ordering::Relaxed,
                );
                track.samp_step_attack[channel_idx][step].store(
                    lerp(current_attack, syndrm_rand_unit(rng_state)).to_bits(),
                    Ordering::Relaxed,
                );
                track.samp_step_decay[channel_idx][step].store(
                    lerp(current_decay, syndrm_rand_unit(rng_state)).to_bits(),
                    Ordering::Relaxed,
                );
                track.samp_step_drive[channel_idx][step].store(
                    lerp(current_drive, syndrm_rand_unit(rng_state)).to_bits(),
                    Ordering::Relaxed,
                );
                track.samp_step_level[channel_idx][step].store(
                    lerp(current_level, syndrm_rand_unit(rng_state)).to_bits(),
                    Ordering::Relaxed,
                );
                if amt >= 1.0 || syndrm_rand_unit(rng_state) <= amt {
                    track.samp_step_filter_type[channel_idx][step]
                        .store(syndrm_rand_filter_type(rng_state), Ordering::Relaxed);
                }
                track.samp_step_filter_cutoff[channel_idx][step].store(
                    lerp(current_filter_cutoff, syndrm_rand_unit(rng_state)).to_bits(),
                    Ordering::Relaxed,
                );
                track.samp_step_filter_resonance[channel_idx][step].store(
                    lerp(current_filter_resonance, syndrm_rand_unit(rng_state)).to_bits(),
                    Ordering::Relaxed,
                );
            }
        }
    }
}

fn syndrm_randomize_apply(
    track: &Track,
    lanes: u16,
    start: usize,
    len: usize,
    randomize_steps: bool,
    randomize_params: bool,
    amount: f32,
) {
    let mut rng_state = track.syndrm_rng_state.load(Ordering::Relaxed);
    if randomize_steps {
        syndrm_randomize_steps(track, &mut rng_state, lanes, start, len, amount);
    }
    if randomize_params {
        syndrm_randomize_params(track, &mut rng_state, lanes, start, len, amount);
    }
    track.syndrm_rng_state.store(rng_state, Ordering::Relaxed);
}

fn syndrm_clear_steps(track: &Track, lanes: u16, start: usize, len: usize) {
    let end = (start + len).min(SYNDRM_STEPS);
    for step in start..end {
        if (lanes & (1 << 0)) != 0 {
            track.kick_sequencer_grid[step].store(false, Ordering::Relaxed);
        }
        if (lanes & (1 << 1)) != 0 {
            track.snare_sequencer_grid[step].store(false, Ordering::Relaxed);
        }
        if (lanes & (1 << 2)) != 0 {
            track.clap_sequencer_grid[step].store(false, Ordering::Relaxed);
        }
        if (lanes & (1 << 3)) != 0 {
            track.hat_sequencer_grid[step].store(false, Ordering::Relaxed);
        }
        if (lanes & (1 << 4)) != 0 {
            track.perc1_sequencer_grid[step].store(false, Ordering::Relaxed);
        }
        if (lanes & (1 << 5)) != 0 {
            track.perc2_sequencer_grid[step].store(false, Ordering::Relaxed);
        }
        if (lanes & (1 << 6)) != 0 {
            track.crash_sequencer_grid[step].store(false, Ordering::Relaxed);
        }
        for channel_idx in 0..SYNDRM_SAMPLE_CHANNELS {
            let lane_bit = 1u16 << (7 + channel_idx);
            if (lanes & lane_bit) != 0 {
                track.samp_sequencer_grid[channel_idx][step]
                    .store(false, Ordering::Relaxed);
            }
        }
    }
}

fn syndrm_clear_params(track: &Track, lanes: u16, start: usize, len: usize) {
    let end = (start + len).min(SYNDRM_STEPS);
    let kick_pitch = f32::from_bits(track.kick_pitch.load(Ordering::Relaxed));
    let kick_decay = f32::from_bits(track.kick_decay.load(Ordering::Relaxed));
    let kick_attack = f32::from_bits(track.kick_attack.load(Ordering::Relaxed));
    let kick_drive = f32::from_bits(track.kick_drive.load(Ordering::Relaxed));
    let kick_level = f32::from_bits(track.kick_level.load(Ordering::Relaxed));
    let kick_filter_type = track.kick_filter_type.load(Ordering::Relaxed);
    let kick_filter_cutoff = f32::from_bits(track.kick_filter_cutoff.load(Ordering::Relaxed));
    let kick_filter_resonance =
        f32::from_bits(track.kick_filter_resonance.load(Ordering::Relaxed));

    let snare_tone = f32::from_bits(track.snare_tone.load(Ordering::Relaxed));
    let snare_decay = f32::from_bits(track.snare_decay.load(Ordering::Relaxed));
    let snare_snappy = f32::from_bits(track.snare_snappy.load(Ordering::Relaxed));
    let snare_attack = f32::from_bits(track.snare_attack.load(Ordering::Relaxed));
    let snare_drive = f32::from_bits(track.snare_drive.load(Ordering::Relaxed));
    let snare_level = f32::from_bits(track.snare_level.load(Ordering::Relaxed));
    let snare_filter_type = track.snare_filter_type.load(Ordering::Relaxed);
    let snare_filter_cutoff = f32::from_bits(track.snare_filter_cutoff.load(Ordering::Relaxed));
    let snare_filter_resonance =
        f32::from_bits(track.snare_filter_resonance.load(Ordering::Relaxed));

    let clap_pitch = f32::from_bits(track.clap_pitch.load(Ordering::Relaxed));
    let clap_decay = f32::from_bits(track.clap_decay.load(Ordering::Relaxed));
    let clap_tone = f32::from_bits(track.clap_tone.load(Ordering::Relaxed));
    let clap_drive = f32::from_bits(track.clap_drive.load(Ordering::Relaxed));
    let clap_level = f32::from_bits(track.clap_level.load(Ordering::Relaxed));
    let clap_filter_type = track.clap_filter_type.load(Ordering::Relaxed);
    let clap_filter_cutoff = f32::from_bits(track.clap_filter_cutoff.load(Ordering::Relaxed));
    let clap_filter_resonance =
        f32::from_bits(track.clap_filter_resonance.load(Ordering::Relaxed));

    let hat_pitch = f32::from_bits(track.hat_pitch.load(Ordering::Relaxed));
    let hat_decay = f32::from_bits(track.hat_decay.load(Ordering::Relaxed));
    let hat_tone = f32::from_bits(track.hat_tone.load(Ordering::Relaxed));
    let hat_drive = f32::from_bits(track.hat_drive.load(Ordering::Relaxed));
    let hat_level = f32::from_bits(track.hat_level.load(Ordering::Relaxed));
    let hat_filter_type = track.hat_filter_type.load(Ordering::Relaxed);
    let hat_filter_cutoff = f32::from_bits(track.hat_filter_cutoff.load(Ordering::Relaxed));
    let hat_filter_resonance =
        f32::from_bits(track.hat_filter_resonance.load(Ordering::Relaxed));
    let perc1_pitch = f32::from_bits(track.perc1_pitch.load(Ordering::Relaxed));
    let perc1_decay = f32::from_bits(track.perc1_decay.load(Ordering::Relaxed));
    let perc1_tone = f32::from_bits(track.perc1_tone.load(Ordering::Relaxed));
    let perc1_drive = f32::from_bits(track.perc1_drive.load(Ordering::Relaxed));
    let perc1_level = f32::from_bits(track.perc1_level.load(Ordering::Relaxed));
    let perc1_filter_type = track.perc1_filter_type.load(Ordering::Relaxed);
    let perc1_filter_cutoff =
        f32::from_bits(track.perc1_filter_cutoff.load(Ordering::Relaxed));
    let perc1_filter_resonance =
        f32::from_bits(track.perc1_filter_resonance.load(Ordering::Relaxed));
    let perc2_pitch = f32::from_bits(track.perc2_pitch.load(Ordering::Relaxed));
    let perc2_decay = f32::from_bits(track.perc2_decay.load(Ordering::Relaxed));
    let perc2_tone = f32::from_bits(track.perc2_tone.load(Ordering::Relaxed));
    let perc2_drive = f32::from_bits(track.perc2_drive.load(Ordering::Relaxed));
    let perc2_level = f32::from_bits(track.perc2_level.load(Ordering::Relaxed));
    let perc2_filter_type = track.perc2_filter_type.load(Ordering::Relaxed);
    let perc2_filter_cutoff =
        f32::from_bits(track.perc2_filter_cutoff.load(Ordering::Relaxed));
    let perc2_filter_resonance =
        f32::from_bits(track.perc2_filter_resonance.load(Ordering::Relaxed));
    let crash_pitch = f32::from_bits(track.crash_pitch.load(Ordering::Relaxed));
    let crash_decay = f32::from_bits(track.crash_decay.load(Ordering::Relaxed));
    let crash_tone = f32::from_bits(track.crash_tone.load(Ordering::Relaxed));
    let crash_drive = f32::from_bits(track.crash_drive.load(Ordering::Relaxed));
    let crash_level = f32::from_bits(track.crash_level.load(Ordering::Relaxed));
    let crash_filter_type = track.crash_filter_type.load(Ordering::Relaxed);
    let crash_filter_cutoff =
        f32::from_bits(track.crash_filter_cutoff.load(Ordering::Relaxed));
    let crash_filter_resonance =
        f32::from_bits(track.crash_filter_resonance.load(Ordering::Relaxed));

    let mut samp_pitch = [0.0f32; SYNDRM_SAMPLE_CHANNELS];
    let mut samp_attack = [0.0f32; SYNDRM_SAMPLE_CHANNELS];
    let mut samp_decay = [0.0f32; SYNDRM_SAMPLE_CHANNELS];
    let mut samp_drive = [0.0f32; SYNDRM_SAMPLE_CHANNELS];
    let mut samp_level = [0.0f32; SYNDRM_SAMPLE_CHANNELS];
    let mut samp_filter_type = [0u32; SYNDRM_SAMPLE_CHANNELS];
    let mut samp_filter_cutoff = [0.0f32; SYNDRM_SAMPLE_CHANNELS];
    let mut samp_filter_resonance = [0.0f32; SYNDRM_SAMPLE_CHANNELS];
    for channel_idx in 0..SYNDRM_SAMPLE_CHANNELS {
        samp_pitch[channel_idx] =
            f32::from_bits(track.samp_pitch[channel_idx].load(Ordering::Relaxed));
        samp_attack[channel_idx] =
            f32::from_bits(track.samp_attack[channel_idx].load(Ordering::Relaxed));
        samp_decay[channel_idx] =
            f32::from_bits(track.samp_decay[channel_idx].load(Ordering::Relaxed));
        samp_drive[channel_idx] =
            f32::from_bits(track.samp_drive[channel_idx].load(Ordering::Relaxed));
        samp_level[channel_idx] =
            f32::from_bits(track.samp_level[channel_idx].load(Ordering::Relaxed));
        samp_filter_type[channel_idx] =
            track.samp_filter_type[channel_idx].load(Ordering::Relaxed);
        samp_filter_cutoff[channel_idx] =
            f32::from_bits(track.samp_filter_cutoff[channel_idx].load(Ordering::Relaxed));
        samp_filter_resonance[channel_idx] =
            f32::from_bits(track.samp_filter_resonance[channel_idx].load(Ordering::Relaxed));
    }

    for step in start..end {
        if (lanes & (1 << 0)) != 0 {
            track.kick_step_override_enabled[step].store(false, Ordering::Relaxed);
            track.kick_step_pitch[step].store(kick_pitch.to_bits(), Ordering::Relaxed);
            track.kick_step_decay[step].store(kick_decay.to_bits(), Ordering::Relaxed);
            track.kick_step_attack[step].store(kick_attack.to_bits(), Ordering::Relaxed);
            track.kick_step_drive[step].store(kick_drive.to_bits(), Ordering::Relaxed);
            track.kick_step_level[step].store(kick_level.to_bits(), Ordering::Relaxed);
            track.kick_step_filter_type[step].store(kick_filter_type, Ordering::Relaxed);
            track.kick_step_filter_cutoff[step].store(kick_filter_cutoff.to_bits(), Ordering::Relaxed);
            track.kick_step_filter_resonance[step]
                .store(kick_filter_resonance.to_bits(), Ordering::Relaxed);
        }
        if (lanes & (1 << 1)) != 0 {
            track.snare_step_override_enabled[step].store(false, Ordering::Relaxed);
            track.snare_step_tone[step].store(snare_tone.to_bits(), Ordering::Relaxed);
            track.snare_step_decay[step].store(snare_decay.to_bits(), Ordering::Relaxed);
            track.snare_step_snappy[step].store(snare_snappy.to_bits(), Ordering::Relaxed);
            track.snare_step_attack[step].store(snare_attack.to_bits(), Ordering::Relaxed);
            track.snare_step_drive[step].store(snare_drive.to_bits(), Ordering::Relaxed);
            track.snare_step_level[step].store(snare_level.to_bits(), Ordering::Relaxed);
            track.snare_step_filter_type[step].store(snare_filter_type, Ordering::Relaxed);
            track.snare_step_filter_cutoff[step].store(snare_filter_cutoff.to_bits(), Ordering::Relaxed);
            track.snare_step_filter_resonance[step]
                .store(snare_filter_resonance.to_bits(), Ordering::Relaxed);
        }
        if (lanes & (1 << 2)) != 0 {
            track.clap_step_override_enabled[step].store(false, Ordering::Relaxed);
            track.clap_step_pitch[step].store(clap_pitch.to_bits(), Ordering::Relaxed);
            track.clap_step_decay[step].store(clap_decay.to_bits(), Ordering::Relaxed);
            track.clap_step_tone[step].store(clap_tone.to_bits(), Ordering::Relaxed);
            track.clap_step_drive[step].store(clap_drive.to_bits(), Ordering::Relaxed);
            track.clap_step_level[step].store(clap_level.to_bits(), Ordering::Relaxed);
            track.clap_step_filter_type[step].store(clap_filter_type, Ordering::Relaxed);
            track.clap_step_filter_cutoff[step]
                .store(clap_filter_cutoff.to_bits(), Ordering::Relaxed);
            track.clap_step_filter_resonance[step]
                .store(clap_filter_resonance.to_bits(), Ordering::Relaxed);
        }
        if (lanes & (1 << 3)) != 0 {
            track.hat_step_override_enabled[step].store(false, Ordering::Relaxed);
            track.hat_step_pitch[step].store(hat_pitch.to_bits(), Ordering::Relaxed);
            track.hat_step_decay[step].store(hat_decay.to_bits(), Ordering::Relaxed);
            track.hat_step_tone[step].store(hat_tone.to_bits(), Ordering::Relaxed);
            track.hat_step_drive[step].store(hat_drive.to_bits(), Ordering::Relaxed);
            track.hat_step_level[step].store(hat_level.to_bits(), Ordering::Relaxed);
            track.hat_step_filter_type[step].store(hat_filter_type, Ordering::Relaxed);
            track.hat_step_filter_cutoff[step].store(hat_filter_cutoff.to_bits(), Ordering::Relaxed);
            track.hat_step_filter_resonance[step]
                .store(hat_filter_resonance.to_bits(), Ordering::Relaxed);
        }
        if (lanes & (1 << 4)) != 0 {
            track.perc1_step_override_enabled[step].store(false, Ordering::Relaxed);
            track
                .perc1_step_pitch[step]
                .store(perc1_pitch.to_bits(), Ordering::Relaxed);
            track
                .perc1_step_decay[step]
                .store(perc1_decay.to_bits(), Ordering::Relaxed);
            track
                .perc1_step_tone[step]
                .store(perc1_tone.to_bits(), Ordering::Relaxed);
            track
                .perc1_step_drive[step]
                .store(perc1_drive.to_bits(), Ordering::Relaxed);
            track
                .perc1_step_level[step]
                .store(perc1_level.to_bits(), Ordering::Relaxed);
            track
                .perc1_step_filter_type[step]
                .store(perc1_filter_type, Ordering::Relaxed);
            track
                .perc1_step_filter_cutoff[step]
                .store(perc1_filter_cutoff.to_bits(), Ordering::Relaxed);
            track
                .perc1_step_filter_resonance[step]
                .store(perc1_filter_resonance.to_bits(), Ordering::Relaxed);
        }
        if (lanes & (1 << 5)) != 0 {
            track.perc2_step_override_enabled[step].store(false, Ordering::Relaxed);
            track
                .perc2_step_pitch[step]
                .store(perc2_pitch.to_bits(), Ordering::Relaxed);
            track
                .perc2_step_decay[step]
                .store(perc2_decay.to_bits(), Ordering::Relaxed);
            track
                .perc2_step_tone[step]
                .store(perc2_tone.to_bits(), Ordering::Relaxed);
            track
                .perc2_step_drive[step]
                .store(perc2_drive.to_bits(), Ordering::Relaxed);
            track
                .perc2_step_level[step]
                .store(perc2_level.to_bits(), Ordering::Relaxed);
            track
                .perc2_step_filter_type[step]
                .store(perc2_filter_type, Ordering::Relaxed);
            track
                .perc2_step_filter_cutoff[step]
                .store(perc2_filter_cutoff.to_bits(), Ordering::Relaxed);
            track
                .perc2_step_filter_resonance[step]
                .store(perc2_filter_resonance.to_bits(), Ordering::Relaxed);
        }
        if (lanes & (1 << 6)) != 0 {
            track
                .crash_step_override_enabled[step]
                .store(false, Ordering::Relaxed);
            track
                .crash_step_pitch[step]
                .store(crash_pitch.to_bits(), Ordering::Relaxed);
            track
                .crash_step_decay[step]
                .store(crash_decay.to_bits(), Ordering::Relaxed);
            track
                .crash_step_tone[step]
                .store(crash_tone.to_bits(), Ordering::Relaxed);
            track
                .crash_step_drive[step]
                .store(crash_drive.to_bits(), Ordering::Relaxed);
            track
                .crash_step_level[step]
                .store(crash_level.to_bits(), Ordering::Relaxed);
            track
                .crash_step_filter_type[step]
                .store(crash_filter_type, Ordering::Relaxed);
            track
                .crash_step_filter_cutoff[step]
                .store(crash_filter_cutoff.to_bits(), Ordering::Relaxed);
            track
                .crash_step_filter_resonance[step]
                .store(crash_filter_resonance.to_bits(), Ordering::Relaxed);
        }
        for channel_idx in 0..SYNDRM_SAMPLE_CHANNELS {
            let lane_bit = 1u16 << (7 + channel_idx);
            if (lanes & lane_bit) != 0 {
                track.samp_step_override_enabled[channel_idx][step]
                    .store(false, Ordering::Relaxed);
                track.samp_step_pitch[channel_idx][step]
                    .store(samp_pitch[channel_idx].to_bits(), Ordering::Relaxed);
                track.samp_step_attack[channel_idx][step]
                    .store(samp_attack[channel_idx].to_bits(), Ordering::Relaxed);
                track.samp_step_decay[channel_idx][step]
                    .store(samp_decay[channel_idx].to_bits(), Ordering::Relaxed);
                track.samp_step_drive[channel_idx][step]
                    .store(samp_drive[channel_idx].to_bits(), Ordering::Relaxed);
                track.samp_step_level[channel_idx][step]
                    .store(samp_level[channel_idx].to_bits(), Ordering::Relaxed);
                track.samp_step_filter_type[channel_idx][step]
                    .store(samp_filter_type[channel_idx], Ordering::Relaxed);
                track.samp_step_filter_cutoff[channel_idx][step]
                    .store(samp_filter_cutoff[channel_idx].to_bits(), Ordering::Relaxed);
                track.samp_step_filter_resonance[channel_idx][step]
                    .store(samp_filter_resonance[channel_idx].to_bits(), Ordering::Relaxed);
            }
        }
    }
}

fn syndrm_clear_apply(
    track: &Track,
    lanes: u16,
    start: usize,
    len: usize,
    clear_steps: bool,
    clear_params: bool,
) {
    if clear_steps {
        syndrm_clear_steps(track, lanes, start, len);
    }
    if clear_params {
        syndrm_clear_params(track, lanes, start, len);
    }
}

fn syndrm_copy_steps_lane(track: &Track, lane: usize, start: usize, len: usize) -> Vec<bool> {
    let end = (start + len).min(SYNDRM_STEPS);
    let mut data = Vec::with_capacity(end.saturating_sub(start));
    for step in start..end {
        let value = match lane {
            0 => track.kick_sequencer_grid[step].load(Ordering::Relaxed),
            1 => track.snare_sequencer_grid[step].load(Ordering::Relaxed),
            2 => track.clap_sequencer_grid[step].load(Ordering::Relaxed),
            3 => track.hat_sequencer_grid[step].load(Ordering::Relaxed),
            4 => track.perc1_sequencer_grid[step].load(Ordering::Relaxed),
            5 => track.perc2_sequencer_grid[step].load(Ordering::Relaxed),
            6 => track.crash_sequencer_grid[step].load(Ordering::Relaxed),
            _ => {
                if lane >= 7 && lane < SYNDRM_LANES {
                    let samp_idx = lane - 7;
                    track.samp_sequencer_grid[samp_idx][step].load(Ordering::Relaxed)
                } else {
                    false
                }
            }
        };
        data.push(value);
    }
    data
}

fn syndrm_paste_steps_lane(track: &Track, lane: usize, dest_start: usize, data: &[bool]) {
    let end = (dest_start + data.len()).min(SYNDRM_STEPS);
    let len = end.saturating_sub(dest_start);
    for offset in 0..len {
        let step = dest_start + offset;
        let value = data[offset];
        match lane {
            0 => track.kick_sequencer_grid[step].store(value, Ordering::Relaxed),
            1 => track.snare_sequencer_grid[step].store(value, Ordering::Relaxed),
            2 => track.clap_sequencer_grid[step].store(value, Ordering::Relaxed),
            3 => track.hat_sequencer_grid[step].store(value, Ordering::Relaxed),
            4 => track.perc1_sequencer_grid[step].store(value, Ordering::Relaxed),
            5 => track.perc2_sequencer_grid[step].store(value, Ordering::Relaxed),
            6 => track.crash_sequencer_grid[step].store(value, Ordering::Relaxed),
            _ => {
                if lane >= 7 && lane < SYNDRM_LANES {
                    let samp_idx = lane - 7;
                    track.samp_sequencer_grid[samp_idx][step].store(value, Ordering::Relaxed);
                }
            }
        }
    }
}

fn syndrm_copy_params_lane(
    track: &Track,
    lane: usize,
    start: usize,
    len: usize,
) -> SynDRMLaneParamsCopy {
    let end = (start + len).min(SYNDRM_STEPS);
    let count = end.saturating_sub(start);
    if count == 0 {
        return SynDRMLaneParamsCopy::None;
    }

    match lane {
        0 => {
            let mut override_enabled = Vec::with_capacity(count);
            let mut pitch = Vec::with_capacity(count);
            let mut decay = Vec::with_capacity(count);
            let mut attack = Vec::with_capacity(count);
            let mut drive = Vec::with_capacity(count);
            let mut level = Vec::with_capacity(count);
            let mut filter_type = Vec::with_capacity(count);
            let mut filter_cutoff = Vec::with_capacity(count);
            let mut filter_resonance = Vec::with_capacity(count);
            let mut retrig_enabled = Vec::with_capacity(count);
            let mut retrig_division = Vec::with_capacity(count);
            for step in start..end {
                override_enabled.push(track.kick_step_override_enabled[step].load(Ordering::Relaxed));
                pitch.push(track.kick_step_pitch[step].load(Ordering::Relaxed));
                decay.push(track.kick_step_decay[step].load(Ordering::Relaxed));
                attack.push(track.kick_step_attack[step].load(Ordering::Relaxed));
                drive.push(track.kick_step_drive[step].load(Ordering::Relaxed));
                level.push(track.kick_step_level[step].load(Ordering::Relaxed));
                filter_type.push(track.kick_step_filter_type[step].load(Ordering::Relaxed));
                filter_cutoff.push(track.kick_step_filter_cutoff[step].load(Ordering::Relaxed));
                filter_resonance.push(
                    track.kick_step_filter_resonance[step].load(Ordering::Relaxed),
                );
                retrig_enabled.push(track.kick_step_retrig_enabled[step].load(Ordering::Relaxed));
                retrig_division.push(
                    track.kick_step_retrig_division[step].load(Ordering::Relaxed),
                );
            }
            SynDRMLaneParamsCopy::Kick {
                override_enabled,
                pitch,
                decay,
                attack,
                drive,
                level,
                filter_type,
                filter_cutoff,
                filter_resonance,
                retrig_enabled,
                retrig_division,
            }
        }
        1 => {
            let mut override_enabled = Vec::with_capacity(count);
            let mut tone = Vec::with_capacity(count);
            let mut decay = Vec::with_capacity(count);
            let mut snappy = Vec::with_capacity(count);
            let mut attack = Vec::with_capacity(count);
            let mut drive = Vec::with_capacity(count);
            let mut level = Vec::with_capacity(count);
            let mut filter_type = Vec::with_capacity(count);
            let mut filter_cutoff = Vec::with_capacity(count);
            let mut filter_resonance = Vec::with_capacity(count);
            let mut retrig_enabled = Vec::with_capacity(count);
            let mut retrig_division = Vec::with_capacity(count);
            for step in start..end {
                override_enabled.push(track.snare_step_override_enabled[step].load(Ordering::Relaxed));
                tone.push(track.snare_step_tone[step].load(Ordering::Relaxed));
                decay.push(track.snare_step_decay[step].load(Ordering::Relaxed));
                snappy.push(track.snare_step_snappy[step].load(Ordering::Relaxed));
                attack.push(track.snare_step_attack[step].load(Ordering::Relaxed));
                drive.push(track.snare_step_drive[step].load(Ordering::Relaxed));
                level.push(track.snare_step_level[step].load(Ordering::Relaxed));
                filter_type.push(track.snare_step_filter_type[step].load(Ordering::Relaxed));
                filter_cutoff.push(track.snare_step_filter_cutoff[step].load(Ordering::Relaxed));
                filter_resonance.push(
                    track.snare_step_filter_resonance[step].load(Ordering::Relaxed),
                );
                retrig_enabled.push(track.snare_step_retrig_enabled[step].load(Ordering::Relaxed));
                retrig_division.push(
                    track.snare_step_retrig_division[step].load(Ordering::Relaxed),
                );
            }
            SynDRMLaneParamsCopy::Snare {
                override_enabled,
                tone,
                decay,
                snappy,
                attack,
                drive,
                level,
                filter_type,
                filter_cutoff,
                filter_resonance,
                retrig_enabled,
                retrig_division,
            }
        }
        2 | 3 | 4 | 5 | 6 => {
            let mut override_enabled = Vec::with_capacity(count);
            let mut pitch = Vec::with_capacity(count);
            let mut decay = Vec::with_capacity(count);
            let mut tone = Vec::with_capacity(count);
            let mut drive = Vec::with_capacity(count);
            let mut level = Vec::with_capacity(count);
            let mut filter_type = Vec::with_capacity(count);
            let mut filter_cutoff = Vec::with_capacity(count);
            let mut filter_resonance = Vec::with_capacity(count);
            let mut retrig_enabled = Vec::with_capacity(count);
            let mut retrig_division = Vec::with_capacity(count);
            for step in start..end {
                match lane {
                    2 => {
                        override_enabled.push(
                            track.clap_step_override_enabled[step].load(Ordering::Relaxed),
                        );
                        pitch.push(track.clap_step_pitch[step].load(Ordering::Relaxed));
                        decay.push(track.clap_step_decay[step].load(Ordering::Relaxed));
                        tone.push(track.clap_step_tone[step].load(Ordering::Relaxed));
                        drive.push(track.clap_step_drive[step].load(Ordering::Relaxed));
                        level.push(track.clap_step_level[step].load(Ordering::Relaxed));
                        filter_type.push(track.clap_step_filter_type[step].load(Ordering::Relaxed));
                        filter_cutoff.push(
                            track.clap_step_filter_cutoff[step].load(Ordering::Relaxed),
                        );
                        filter_resonance.push(
                            track.clap_step_filter_resonance[step].load(Ordering::Relaxed),
                        );
                        retrig_enabled.push(
                            track.clap_step_retrig_enabled[step].load(Ordering::Relaxed),
                        );
                        retrig_division.push(
                            track.clap_step_retrig_division[step].load(Ordering::Relaxed),
                        );
                    }
                    3 => {
                        override_enabled.push(
                            track.hat_step_override_enabled[step].load(Ordering::Relaxed),
                        );
                        pitch.push(track.hat_step_pitch[step].load(Ordering::Relaxed));
                        decay.push(track.hat_step_decay[step].load(Ordering::Relaxed));
                        tone.push(track.hat_step_tone[step].load(Ordering::Relaxed));
                        drive.push(track.hat_step_drive[step].load(Ordering::Relaxed));
                        level.push(track.hat_step_level[step].load(Ordering::Relaxed));
                        filter_type.push(track.hat_step_filter_type[step].load(Ordering::Relaxed));
                        filter_cutoff.push(
                            track.hat_step_filter_cutoff[step].load(Ordering::Relaxed),
                        );
                        filter_resonance.push(
                            track.hat_step_filter_resonance[step].load(Ordering::Relaxed),
                        );
                        retrig_enabled.push(
                            track.hat_step_retrig_enabled[step].load(Ordering::Relaxed),
                        );
                        retrig_division.push(
                            track.hat_step_retrig_division[step].load(Ordering::Relaxed),
                        );
                    }
                    4 => {
                        override_enabled.push(
                            track.perc1_step_override_enabled[step].load(Ordering::Relaxed),
                        );
                        pitch.push(track.perc1_step_pitch[step].load(Ordering::Relaxed));
                        decay.push(track.perc1_step_decay[step].load(Ordering::Relaxed));
                        tone.push(track.perc1_step_tone[step].load(Ordering::Relaxed));
                        drive.push(track.perc1_step_drive[step].load(Ordering::Relaxed));
                        level.push(track.perc1_step_level[step].load(Ordering::Relaxed));
                        filter_type.push(track.perc1_step_filter_type[step].load(Ordering::Relaxed));
                        filter_cutoff.push(
                            track.perc1_step_filter_cutoff[step].load(Ordering::Relaxed),
                        );
                        filter_resonance.push(
                            track.perc1_step_filter_resonance[step].load(Ordering::Relaxed),
                        );
                        retrig_enabled.push(
                            track.perc1_step_retrig_enabled[step].load(Ordering::Relaxed),
                        );
                        retrig_division.push(
                            track.perc1_step_retrig_division[step].load(Ordering::Relaxed),
                        );
                    }
                    5 => {
                        override_enabled.push(
                            track.perc2_step_override_enabled[step].load(Ordering::Relaxed),
                        );
                        pitch.push(track.perc2_step_pitch[step].load(Ordering::Relaxed));
                        decay.push(track.perc2_step_decay[step].load(Ordering::Relaxed));
                        tone.push(track.perc2_step_tone[step].load(Ordering::Relaxed));
                        drive.push(track.perc2_step_drive[step].load(Ordering::Relaxed));
                        level.push(track.perc2_step_level[step].load(Ordering::Relaxed));
                        filter_type.push(track.perc2_step_filter_type[step].load(Ordering::Relaxed));
                        filter_cutoff.push(
                            track.perc2_step_filter_cutoff[step].load(Ordering::Relaxed),
                        );
                        filter_resonance.push(
                            track.perc2_step_filter_resonance[step].load(Ordering::Relaxed),
                        );
                        retrig_enabled.push(
                            track.perc2_step_retrig_enabled[step].load(Ordering::Relaxed),
                        );
                        retrig_division.push(
                            track.perc2_step_retrig_division[step].load(Ordering::Relaxed),
                        );
                    }
                    _ => {
                        override_enabled.push(
                            track.crash_step_override_enabled[step].load(Ordering::Relaxed),
                        );
                        pitch.push(track.crash_step_pitch[step].load(Ordering::Relaxed));
                        decay.push(track.crash_step_decay[step].load(Ordering::Relaxed));
                        tone.push(track.crash_step_tone[step].load(Ordering::Relaxed));
                        drive.push(track.crash_step_drive[step].load(Ordering::Relaxed));
                        level.push(track.crash_step_level[step].load(Ordering::Relaxed));
                        filter_type.push(track.crash_step_filter_type[step].load(Ordering::Relaxed));
                        filter_cutoff.push(
                            track.crash_step_filter_cutoff[step].load(Ordering::Relaxed),
                        );
                        filter_resonance.push(
                            track.crash_step_filter_resonance[step].load(Ordering::Relaxed),
                        );
                        retrig_enabled.push(
                            track.crash_step_retrig_enabled[step].load(Ordering::Relaxed),
                        );
                        retrig_division.push(
                            track.crash_step_retrig_division[step].load(Ordering::Relaxed),
                        );
                    }
                }
            }
            SynDRMLaneParamsCopy::PitchTone {
                override_enabled,
                pitch,
                decay,
                tone,
                drive,
                level,
                filter_type,
                filter_cutoff,
                filter_resonance,
                retrig_enabled,
                retrig_division,
            }
        }
        _ => {
            if lane >= 7 && lane < SYNDRM_LANES {
                let samp_idx = lane - 7;
                let mut override_enabled = Vec::with_capacity(count);
                let mut pitch = Vec::with_capacity(count);
                let mut attack = Vec::with_capacity(count);
                let mut decay = Vec::with_capacity(count);
                let mut drive = Vec::with_capacity(count);
                let mut level = Vec::with_capacity(count);
                let mut filter_type = Vec::with_capacity(count);
                let mut filter_cutoff = Vec::with_capacity(count);
                let mut filter_resonance = Vec::with_capacity(count);
                let mut retrig_enabled = Vec::with_capacity(count);
                let mut retrig_division = Vec::with_capacity(count);
                for step in start..end {
                    override_enabled.push(
                        track.samp_step_override_enabled[samp_idx][step].load(Ordering::Relaxed),
                    );
                    pitch.push(track.samp_step_pitch[samp_idx][step].load(Ordering::Relaxed));
                    attack.push(track.samp_step_attack[samp_idx][step].load(Ordering::Relaxed));
                    decay.push(track.samp_step_decay[samp_idx][step].load(Ordering::Relaxed));
                    drive.push(track.samp_step_drive[samp_idx][step].load(Ordering::Relaxed));
                    level.push(track.samp_step_level[samp_idx][step].load(Ordering::Relaxed));
                    filter_type.push(
                        track.samp_step_filter_type[samp_idx][step].load(Ordering::Relaxed),
                    );
                    filter_cutoff.push(
                        track.samp_step_filter_cutoff[samp_idx][step].load(Ordering::Relaxed),
                    );
                    filter_resonance.push(
                        track.samp_step_filter_resonance[samp_idx][step].load(Ordering::Relaxed),
                    );
                    retrig_enabled.push(
                        track.samp_step_retrig_enabled[samp_idx][step].load(Ordering::Relaxed),
                    );
                    retrig_division.push(
                        track.samp_step_retrig_division[samp_idx][step].load(Ordering::Relaxed),
                    );
                }
                SynDRMLaneParamsCopy::Samp {
                    override_enabled,
                    pitch,
                    attack,
                    decay,
                    drive,
                    level,
                    filter_type,
                    filter_cutoff,
                    filter_resonance,
                    retrig_enabled,
                    retrig_division,
                }
            } else {
                SynDRMLaneParamsCopy::None
            }
        }
    }
}

fn syndrm_paste_params_lane(
    track: &Track,
    lane: usize,
    dest_start: usize,
    params: &SynDRMLaneParamsCopy,
) {
    let max_len = match params {
        SynDRMLaneParamsCopy::Kick { override_enabled, .. } => override_enabled.len(),
        SynDRMLaneParamsCopy::Snare { override_enabled, .. } => override_enabled.len(),
        SynDRMLaneParamsCopy::PitchTone { override_enabled, .. } => override_enabled.len(),
        SynDRMLaneParamsCopy::Samp { override_enabled, .. } => override_enabled.len(),
        SynDRMLaneParamsCopy::None => 0,
    };
    let end = (dest_start + max_len).min(SYNDRM_STEPS);
    let len = end.saturating_sub(dest_start);
    if len == 0 {
        return;
    }

    match params {
        SynDRMLaneParamsCopy::Kick {
            override_enabled,
            pitch,
            decay,
            attack,
            drive,
            level,
            filter_type,
            filter_cutoff,
            filter_resonance,
            retrig_enabled,
            retrig_division,
        } if lane == 0 => {
            for offset in 0..len {
                let step = dest_start + offset;
                track.kick_step_override_enabled[step]
                    .store(override_enabled[offset], Ordering::Relaxed);
                track.kick_step_pitch[step].store(pitch[offset], Ordering::Relaxed);
                track.kick_step_decay[step].store(decay[offset], Ordering::Relaxed);
                track.kick_step_attack[step].store(attack[offset], Ordering::Relaxed);
                track.kick_step_drive[step].store(drive[offset], Ordering::Relaxed);
                track.kick_step_level[step].store(level[offset], Ordering::Relaxed);
                track.kick_step_filter_type[step].store(filter_type[offset], Ordering::Relaxed);
                track.kick_step_filter_cutoff[step].store(filter_cutoff[offset], Ordering::Relaxed);
                track.kick_step_filter_resonance[step]
                    .store(filter_resonance[offset], Ordering::Relaxed);
                track.kick_step_retrig_enabled[step]
                    .store(retrig_enabled[offset], Ordering::Relaxed);
                track.kick_step_retrig_division[step]
                    .store(retrig_division[offset], Ordering::Relaxed);
            }
        }
        SynDRMLaneParamsCopy::Snare {
            override_enabled,
            tone,
            decay,
            snappy,
            attack,
            drive,
            level,
            filter_type,
            filter_cutoff,
            filter_resonance,
            retrig_enabled,
            retrig_division,
        } if lane == 1 => {
            for offset in 0..len {
                let step = dest_start + offset;
                track.snare_step_override_enabled[step]
                    .store(override_enabled[offset], Ordering::Relaxed);
                track.snare_step_tone[step].store(tone[offset], Ordering::Relaxed);
                track.snare_step_decay[step].store(decay[offset], Ordering::Relaxed);
                track.snare_step_snappy[step].store(snappy[offset], Ordering::Relaxed);
                track.snare_step_attack[step].store(attack[offset], Ordering::Relaxed);
                track.snare_step_drive[step].store(drive[offset], Ordering::Relaxed);
                track.snare_step_level[step].store(level[offset], Ordering::Relaxed);
                track.snare_step_filter_type[step].store(filter_type[offset], Ordering::Relaxed);
                track.snare_step_filter_cutoff[step].store(filter_cutoff[offset], Ordering::Relaxed);
                track.snare_step_filter_resonance[step]
                    .store(filter_resonance[offset], Ordering::Relaxed);
                track.snare_step_retrig_enabled[step]
                    .store(retrig_enabled[offset], Ordering::Relaxed);
                track.snare_step_retrig_division[step]
                    .store(retrig_division[offset], Ordering::Relaxed);
            }
        }
        SynDRMLaneParamsCopy::PitchTone {
            override_enabled,
            pitch,
            decay,
            tone,
            drive,
            level,
            filter_type,
            filter_cutoff,
            filter_resonance,
            retrig_enabled,
            retrig_division,
        } if (2..=6).contains(&lane) => {
            for offset in 0..len {
                let step = dest_start + offset;
                match lane {
                    2 => {
                        track.clap_step_override_enabled[step]
                            .store(override_enabled[offset], Ordering::Relaxed);
                        track.clap_step_pitch[step].store(pitch[offset], Ordering::Relaxed);
                        track.clap_step_decay[step].store(decay[offset], Ordering::Relaxed);
                        track.clap_step_tone[step].store(tone[offset], Ordering::Relaxed);
                        track.clap_step_drive[step].store(drive[offset], Ordering::Relaxed);
                        track.clap_step_level[step].store(level[offset], Ordering::Relaxed);
                        track.clap_step_filter_type[step].store(filter_type[offset], Ordering::Relaxed);
                        track.clap_step_filter_cutoff[step]
                            .store(filter_cutoff[offset], Ordering::Relaxed);
                        track.clap_step_filter_resonance[step]
                            .store(filter_resonance[offset], Ordering::Relaxed);
                        track.clap_step_retrig_enabled[step]
                            .store(retrig_enabled[offset], Ordering::Relaxed);
                        track.clap_step_retrig_division[step]
                            .store(retrig_division[offset], Ordering::Relaxed);
                    }
                    3 => {
                        track.hat_step_override_enabled[step]
                            .store(override_enabled[offset], Ordering::Relaxed);
                        track.hat_step_pitch[step].store(pitch[offset], Ordering::Relaxed);
                        track.hat_step_decay[step].store(decay[offset], Ordering::Relaxed);
                        track.hat_step_tone[step].store(tone[offset], Ordering::Relaxed);
                        track.hat_step_drive[step].store(drive[offset], Ordering::Relaxed);
                        track.hat_step_level[step].store(level[offset], Ordering::Relaxed);
                        track.hat_step_filter_type[step].store(filter_type[offset], Ordering::Relaxed);
                        track.hat_step_filter_cutoff[step]
                            .store(filter_cutoff[offset], Ordering::Relaxed);
                        track.hat_step_filter_resonance[step]
                            .store(filter_resonance[offset], Ordering::Relaxed);
                        track.hat_step_retrig_enabled[step]
                            .store(retrig_enabled[offset], Ordering::Relaxed);
                        track.hat_step_retrig_division[step]
                            .store(retrig_division[offset], Ordering::Relaxed);
                    }
                    4 => {
                        track.perc1_step_override_enabled[step]
                            .store(override_enabled[offset], Ordering::Relaxed);
                        track.perc1_step_pitch[step].store(pitch[offset], Ordering::Relaxed);
                        track.perc1_step_decay[step].store(decay[offset], Ordering::Relaxed);
                        track.perc1_step_tone[step].store(tone[offset], Ordering::Relaxed);
                        track.perc1_step_drive[step].store(drive[offset], Ordering::Relaxed);
                        track.perc1_step_level[step].store(level[offset], Ordering::Relaxed);
                        track.perc1_step_filter_type[step]
                            .store(filter_type[offset], Ordering::Relaxed);
                        track.perc1_step_filter_cutoff[step]
                            .store(filter_cutoff[offset], Ordering::Relaxed);
                        track.perc1_step_filter_resonance[step]
                            .store(filter_resonance[offset], Ordering::Relaxed);
                        track.perc1_step_retrig_enabled[step]
                            .store(retrig_enabled[offset], Ordering::Relaxed);
                        track.perc1_step_retrig_division[step]
                            .store(retrig_division[offset], Ordering::Relaxed);
                    }
                    5 => {
                        track.perc2_step_override_enabled[step]
                            .store(override_enabled[offset], Ordering::Relaxed);
                        track.perc2_step_pitch[step].store(pitch[offset], Ordering::Relaxed);
                        track.perc2_step_decay[step].store(decay[offset], Ordering::Relaxed);
                        track.perc2_step_tone[step].store(tone[offset], Ordering::Relaxed);
                        track.perc2_step_drive[step].store(drive[offset], Ordering::Relaxed);
                        track.perc2_step_level[step].store(level[offset], Ordering::Relaxed);
                        track.perc2_step_filter_type[step]
                            .store(filter_type[offset], Ordering::Relaxed);
                        track.perc2_step_filter_cutoff[step]
                            .store(filter_cutoff[offset], Ordering::Relaxed);
                        track.perc2_step_filter_resonance[step]
                            .store(filter_resonance[offset], Ordering::Relaxed);
                        track.perc2_step_retrig_enabled[step]
                            .store(retrig_enabled[offset], Ordering::Relaxed);
                        track.perc2_step_retrig_division[step]
                            .store(retrig_division[offset], Ordering::Relaxed);
                    }
                    _ => {
                        track.crash_step_override_enabled[step]
                            .store(override_enabled[offset], Ordering::Relaxed);
                        track.crash_step_pitch[step].store(pitch[offset], Ordering::Relaxed);
                        track.crash_step_decay[step].store(decay[offset], Ordering::Relaxed);
                        track.crash_step_tone[step].store(tone[offset], Ordering::Relaxed);
                        track.crash_step_drive[step].store(drive[offset], Ordering::Relaxed);
                        track.crash_step_level[step].store(level[offset], Ordering::Relaxed);
                        track.crash_step_filter_type[step]
                            .store(filter_type[offset], Ordering::Relaxed);
                        track.crash_step_filter_cutoff[step]
                            .store(filter_cutoff[offset], Ordering::Relaxed);
                        track.crash_step_filter_resonance[step]
                            .store(filter_resonance[offset], Ordering::Relaxed);
                        track.crash_step_retrig_enabled[step]
                            .store(retrig_enabled[offset], Ordering::Relaxed);
                        track.crash_step_retrig_division[step]
                            .store(retrig_division[offset], Ordering::Relaxed);
                    }
                }
            }
        }
        SynDRMLaneParamsCopy::Samp {
            override_enabled,
            pitch,
            attack,
            decay,
            drive,
            level,
            filter_type,
            filter_cutoff,
            filter_resonance,
            retrig_enabled,
            retrig_division,
        } if lane >= 7 && lane < SYNDRM_LANES => {
            let samp_idx = lane - 7;
            for offset in 0..len {
                let step = dest_start + offset;
                track.samp_step_override_enabled[samp_idx][step]
                    .store(override_enabled[offset], Ordering::Relaxed);
                track.samp_step_pitch[samp_idx][step].store(pitch[offset], Ordering::Relaxed);
                track.samp_step_attack[samp_idx][step].store(attack[offset], Ordering::Relaxed);
                track.samp_step_decay[samp_idx][step].store(decay[offset], Ordering::Relaxed);
                track.samp_step_drive[samp_idx][step].store(drive[offset], Ordering::Relaxed);
                track.samp_step_level[samp_idx][step].store(level[offset], Ordering::Relaxed);
                track.samp_step_filter_type[samp_idx][step]
                    .store(filter_type[offset], Ordering::Relaxed);
                track.samp_step_filter_cutoff[samp_idx][step]
                    .store(filter_cutoff[offset], Ordering::Relaxed);
                track.samp_step_filter_resonance[samp_idx][step]
                    .store(filter_resonance[offset], Ordering::Relaxed);
                track.samp_step_retrig_enabled[samp_idx][step]
                    .store(retrig_enabled[offset], Ordering::Relaxed);
                track.samp_step_retrig_division[samp_idx][step]
                    .store(retrig_division[offset], Ordering::Relaxed);
            }
        }
        _ => {}
    }
}

fn syndrm_copy_apply(
    track: &Track,
    lanes: u16,
    start: usize,
    len: usize,
    copy_steps: bool,
    copy_params: bool,
    page_scoped: bool,
) {
    let end = (start + len).min(SYNDRM_STEPS);
    let len = end.saturating_sub(start);
    let mut buffer = track.syndrm_copy_buffer.lock();
    buffer.has_data = len > 0 && (copy_steps || copy_params);
    buffer.lanes_mask = lanes;
    buffer.start = start;
    buffer.len = len;
    buffer.include_steps = copy_steps;
    buffer.include_params = copy_params;
    buffer.page_scoped = page_scoped;
    buffer.source_lane = if lanes.count_ones() == 1 {
        Some(lanes.trailing_zeros())
    } else {
        None
    };
    buffer.steps = vec![Vec::new(); SYNDRM_LANES];
    buffer.params = vec![SynDRMLaneParamsCopy::None; SYNDRM_LANES];
    if !buffer.has_data {
        return;
    }
    for lane in 0..SYNDRM_LANES {
        if (lanes & (1 << lane)) == 0 {
            continue;
        }
        if copy_steps {
            buffer.steps[lane] = syndrm_copy_steps_lane(track, lane, start, len);
        }
        if copy_params {
            buffer.params[lane] = syndrm_copy_params_lane(track, lane, start, len);
        }
    }
}

fn syndrm_paste_apply(track: &Track, target_lane: u32, target_page: usize) {
    let buffer = track.syndrm_copy_buffer.lock();
    if !buffer.has_data || buffer.len == 0 {
        return;
    }
    let dest_start = if buffer.page_scoped {
        target_page * SYNDRM_PAGE_SIZE
    } else {
        0
    };
    let end = (dest_start + buffer.len).min(SYNDRM_STEPS);
    let len = end.saturating_sub(dest_start);
    if len == 0 {
        return;
    }
    let target_lanes = if buffer.source_lane.is_some() {
        syndrm_lane_mask(target_lane)
    } else {
        buffer.lanes_mask
    };
    for lane in 0..SYNDRM_LANES {
        if (target_lanes & (1 << lane)) == 0 {
            continue;
        }
        let source_lane = buffer.source_lane.map(|lane| lane as usize).unwrap_or(lane);
        if buffer.include_steps {
            let data = &buffer.steps[source_lane];
            if !data.is_empty() {
                let data_len = data.len().min(len);
                syndrm_paste_steps_lane(track, lane, dest_start, &data[..data_len]);
            }
        }
        let allow_params = buffer.include_params
            && (buffer.source_lane.is_none() || source_lane == lane);
        if allow_params {
            let params = &buffer.params[source_lane];
            syndrm_paste_params_lane(track, lane, dest_start, params);
        }
    }
}

fn mosaic_cc_bipolar(value: f32) -> f32 {
    let cc = (value.clamp(0.0, 1.0) * 127.0).round();
    ((cc - 64.0) / 64.0).clamp(-1.0, 1.0)
}

fn sample_at_linear_ring(buffer: &[Vec<f32>], channel: usize, pos: f32) -> f32 {
    if buffer.is_empty() {
        return 0.0;
    }
    let channel = channel.min(buffer.len() - 1);
    let len = buffer[channel].len();
    if len == 0 {
        return 0.0;
    }
    let mut idx = pos.floor();
    if idx < 0.0 {
        idx = 0.0;
    }
    let idx0 = (idx as usize) % len;
    let idx1 = (idx0 + 1) % len;
    let frac = (pos - idx0 as f32).clamp(0.0, 1.0);
    let a = buffer[channel][idx0];
    let b = buffer[channel][idx1];
    a + (b - a) * frac
}

fn open_docs() {
    let exe_dir = std::env::current_exe()
        .ok()
        .and_then(|path| path.parent().map(|dir| dir.to_path_buf()));

    let mut candidates = Vec::new();
    if let Some(dir) = exe_dir.clone() {
        candidates.push(dir.join("documentation").join("index.html"));
        #[cfg(target_os = "macos")]
        {
            if let Some(contents) = dir.parent() {
                candidates.push(contents.join("Resources").join("documentation").join("index.html"));
            }
        }
    }
    candidates.push(std::env::current_dir().unwrap_or_default().join("documentation").join("index.html"));

    let doc_path = candidates.into_iter().find(|path| path.exists());
    let Some(doc_path) = doc_path else {
        eprintln!("Documentation not found. Expected documentation/index.html next to the app.");
        return;
    };

    #[cfg(target_os = "windows")]
    {
        let _ = std::process::Command::new("cmd")
            .args(["/C", "start", "", doc_path.to_string_lossy().as_ref()])
            .spawn();
    }
    #[cfg(target_os = "macos")]
    {
        let _ = std::process::Command::new("open")
            .arg(doc_path)
            .spawn();
    }
    #[cfg(target_os = "linux")]
    {
        let _ = std::process::Command::new("xdg-open")
            .arg(doc_path)
            .spawn();
    }
}

fn smooth_meter(prev: f32, target: f32) -> f32 {
    let attack = 0.6;
    let release = 0.96;
    let next = if target > prev {
        prev + (target - prev) * attack
    } else {
        prev * release + target * (1.0 - release)
    };
    next.clamp(0.0, 1.0)
}

fn smooth_param(current: f32, target: f32, num_samples: usize, sample_rate: f32) -> f32 {
    let smoothing_samples =
        (sample_rate * (MOSAIC_PARAM_SMOOTH_MS / 1000.0)).max(1.0);
    let step = (target - current) / smoothing_samples;
    let mut next = current + step * num_samples as f32;
    if (target - current).signum() != (target - next).signum() {
        next = target;
    }
    next
}

fn reflect_comb_max_len(base: usize) -> usize {
    ((base as f32)
        * (REFLECT_MAX_SAMPLE_RATE as f32 / 44_100.0)
        * REFLECT_REVERB_MAX_SCALE)
        .ceil() as usize
        + 1
}

fn reflect_ap_max_len(base: usize) -> usize {
    ((base as f32)
        * (REFLECT_MAX_SAMPLE_RATE as f32 / 44_100.0)
        * REFLECT_REVERB_MAX_SCALE)
        .ceil() as usize
        + 1
}

fn reflect_time_seconds(time_norm: f32, mode: u32, tempo: f32) -> f32 {
    let time_norm = time_norm.clamp(0.0, 1.0);
    if mode == 3 {
        let min_sec = 0.0027;
        let max_sec = REFLECT_MAX_DELAY_SECONDS;
        return min_sec + (max_sec - min_sec) * time_norm;
    }

    let base_divisions = [
        4.0,
        2.0,
        1.0,
        0.5,
        0.25,
        0.125,
        0.0625,
        0.03125,
        0.015625,
    ];
    let idx = ((base_divisions.len() - 1) as f32 * time_norm)
        .round()
        .clamp(0.0, (base_divisions.len() - 1) as f32) as usize;
    let mut bars = base_divisions[idx];
    match mode {
        1 => bars *= 1.5,       // dotted
        2 => bars *= 2.0 / 3.0, // triplet
        _ => {}
    }
    let seconds_per_bar = (60.0 / tempo.clamp(20.0, 300.0)) * 4.0;
    (bars * seconds_per_bar).max(0.001)
}

fn ring_rate_hz(rate_norm: f32, mode: u32, tempo: f32) -> f32 {
    let rate_norm = rate_norm.clamp(0.0, 1.0);
    if mode == 0 {
        return RING_LFO_RATE_MIN_HZ
            + rate_norm * (RING_LFO_RATE_MAX_HZ - RING_LFO_RATE_MIN_HZ);
    }

    let base_divisions = [
        32.0, 16.0, 8.0, 4.0, 2.0, 1.0, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625,
    ];
    let idx = ((base_divisions.len() - 1) as f32 * rate_norm)
        .round()
        .clamp(0.0, (base_divisions.len() - 1) as f32) as usize;
    let mut division = base_divisions[idx];
    match mode {
        2 => division *= 1.5,       // dotted
        3 => division *= 2.0 / 3.0, // triplet
        _ => {}
    }
    let bps = tempo.clamp(20.0, 300.0) / 60.0;
    (bps / division).max(0.01)
}

fn ring_quantize_freq(freq: f32, scale_mode: u32) -> f32 {
    let freq = freq.max(1.0);
    let scale = match scale_mode {
        1 => [0, 2, 4, 5, 7, 9, 11],
        2 => [0, 2, 3, 5, 7, 8, 10],
        _ => return freq,
    };
    let note = 69.0 + 12.0 * (freq / 440.0).log2();
    let base_octave = (note / 12.0).floor();
    let semitone = ((note - base_octave * 12.0).round() as i32).rem_euclid(12);
    let mut closest = scale[0];
    let mut best_dist = 12;
    for &deg in scale.iter() {
        let dist = (deg - semitone).abs();
        if dist < best_dist {
            best_dist = dist;
            closest = deg;
        }
    }
    let quant_note = base_octave * 12.0 + closest as f32;
    440.0 * 2.0f32.powf((quant_note - 69.0) / 12.0)
}

fn count_in_samples(tempo: f32, sample_rate: u32, ticks: u32) -> u32 {
    if ticks == 0 {
        return 0;
    }
    let tempo = tempo.clamp(20.0, 300.0);
    let sr = sample_rate.max(1) as f32;
    let samples_per_beat = (sr * 60.0 / tempo.max(1.0)).max(1.0);
    let ticks = ticks.min(METRONOME_COUNT_IN_MAX_TICKS) as f32;
    (samples_per_beat * ticks).round().max(1.0) as u32
}

fn build_time_labels(duration_secs: f32) -> Vec<SharedString> {
    let d = duration_secs.max(0.0);
    let marks = [0.0, 0.25, 0.5, 0.75, 1.0];
    marks
        .iter()
        .map(|t| {
            let seconds = d * t;
            if seconds >= 10.0 {
                SharedString::from(format!("{:.0}s", seconds))
            } else {
                SharedString::from(format!("{:.1}s", seconds))
            }
        })
        .collect()
}

fn sample_at_linear(
    samples: &[Vec<f32>],
    channel: usize,
    pos: f32,
    loop_start: usize,
    loop_end: usize,
    loop_active: bool,
    num_samples: usize,
) -> f32 {
    if samples.is_empty() || num_samples == 0 {
        return 0.0;
    }
    let pos = wrap_loop_pos(pos, loop_start, loop_end, loop_active, num_samples);
    let idx0 = pos.floor() as usize;
    let frac = pos - idx0 as f32;
    let idx1 = if loop_active && loop_end > loop_start {
        let end = loop_end.min(num_samples);
        if idx0 + 1 < end {
            idx0 + 1
        } else {
            loop_start.min(num_samples.saturating_sub(1))
        }
    } else {
        (idx0 + 1).min(num_samples.saturating_sub(1))
    };
    let s0 = samples[channel][idx0];
    let s1 = samples[channel][idx1];
    s0 + (s1 - s0) * frac
}

fn load_audio_file(
    path: &std::path::Path,
) -> Result<(Vec<Vec<f32>>, u32), Box<dyn std::error::Error>> {
    use symphonia::core::audio::AudioBufferRef;
    use symphonia::core::codecs::{DecoderOptions, CODEC_TYPE_NULL};
    use symphonia::core::errors::Error;
    use symphonia::core::formats::FormatOptions;
    use symphonia::core::io::MediaSourceStream;
    use symphonia::core::meta::MetadataOptions;
    use symphonia::core::probe::Hint;

    let file = std::fs::File::open(path)?;
    let mss = MediaSourceStream::new(Box::new(file), Default::default());
    let mut hint = Hint::new();
    if let Some(ext) = path.extension().and_then(|s| s.to_str()) {
        hint.with_extension(ext);
    }

    let meta_opts = MetadataOptions::default();
    let fmt_opts = FormatOptions::default();
    let probed = symphonia::default::get_probe().format(&hint, mss, &fmt_opts, &meta_opts)?;
    let mut format = probed.format;
    let track = format
        .tracks()
        .iter()
        .find(|t| t.codec_params.codec != CODEC_TYPE_NULL)
        .ok_or_else(|| "no supported audio tracks")?;

    let dec_opts = DecoderOptions::default();
    let mut decoder = symphonia::default::get_codecs().make(&track.codec_params, &dec_opts)?;

    let mut samples: Vec<Vec<f32>> = vec![];
    let sample_rate = track.codec_params.sample_rate.unwrap_or(44_100);
    let track_id = track.id;

    loop {
        let packet = match format.next_packet() {
            Ok(packet) => packet,
            Err(Error::IoError(ref e)) if e.kind() == std::io::ErrorKind::UnexpectedEof => break,
            Err(e) => return Err(Box::new(e)),
        };

        if packet.track_id() != track_id {
            continue;
        }

        let decoded = decoder.decode(&packet)?;

        if samples.is_empty() {
            samples = vec![vec![]; decoded.spec().channels.count()];
        }

        match decoded {
            AudioBufferRef::F32(buf) => {
                for (i, plane) in buf.planes().planes().iter().enumerate() {
                    samples[i].extend_from_slice(plane);
                }
            }
            _ => {
                let mut buf = decoded.make_equivalent::<f32>();
                decoded.convert(&mut buf);
                for (i, plane) in buf.planes().planes().iter().enumerate() {
                    samples[i].extend_from_slice(plane);
                }
            }
        }
    }

    Ok((samples, sample_rate))
}

fn image_from_rgba(width: u32, height: u32, data: &[u8]) -> Image {
    let mut buffer = SharedPixelBuffer::<Rgba8Pixel>::new(width, height);
    let pixels = buffer.make_mut_slice();
    for (pixel, chunk) in pixels.iter_mut().zip(data.chunks_exact(4)) {
        *pixel = Rgba8Pixel {
            r: chunk[0],
            g: chunk[1],
            b: chunk[2],
            a: chunk[3],
        };
    }
    Image::from_rgba8(buffer)
}

#[derive(Debug)]
enum MediaLoadError {
    NoVideoStream,
    Ffmpeg(String),
}

impl std::fmt::Display for MediaLoadError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MediaLoadError::NoVideoStream => write!(f, "no video stream found"),
            MediaLoadError::Ffmpeg(msg) => write!(f, "ffmpeg error: {msg}"),
        }
    }
}

impl std::error::Error for MediaLoadError {}

fn load_media_file(
    path: &std::path::Path,
) -> Result<(Vec<Vec<f32>>, u32, Option<VideoCache>), Box<dyn std::error::Error>> {
    match load_audio_video_ffmpeg(path) {
        Ok((samples, sample_rate, video)) => Ok((samples, sample_rate, Some(video))),
        Err(MediaLoadError::NoVideoStream) => {
            load_audio_file(path).map(|(samples, sample_rate)| (samples, sample_rate, None))
        }
        Err(err) => Err(Box::new(err)),
    }
}

fn load_audio_video_ffmpeg(
    path: &std::path::Path,
) -> Result<(Vec<Vec<f32>>, u32, VideoCache), MediaLoadError> {
    use ffmpeg_next as ffmpeg;
    use ffmpeg::format::Pixel;
    use ffmpeg::media::Type;
    use ffmpeg::software::scaling::Flags as ScalingFlags;
    use ffmpeg::software::{resampling, scaling};
    use ffmpeg::util::format::sample::{Sample, Type as SampleType};

    static FFMPEG_INIT: Once = Once::new();
    FFMPEG_INIT.call_once(|| {
        let _ = ffmpeg::init();
    });

    let mut input = ffmpeg::format::input(&path).map_err(|e| {
        MediaLoadError::Ffmpeg(format!("failed to open media: {e:?}"))
    })?;

    let video_stream = input.streams().best(Type::Video);
    let audio_stream = input.streams().best(Type::Audio);

    let video_stream = video_stream.ok_or(MediaLoadError::NoVideoStream)?;
    let audio_stream = audio_stream.ok_or_else(|| {
        MediaLoadError::Ffmpeg("no audio stream found".to_string())
    })?;

    let video_stream_index = video_stream.index();
    let audio_stream_index = audio_stream.index();

    let mut video_decoder = ffmpeg::codec::Context::from_parameters(video_stream.parameters())
        .map_err(|e| MediaLoadError::Ffmpeg(format!("video params: {e:?}")))?
        .decoder()
        .video()
        .map_err(|e| MediaLoadError::Ffmpeg(format!("video decoder: {e:?}")))?;
    let mut audio_decoder = ffmpeg::codec::Context::from_parameters(audio_stream.parameters())
        .map_err(|e| MediaLoadError::Ffmpeg(format!("audio params: {e:?}")))?
        .decoder()
        .audio()
        .map_err(|e| MediaLoadError::Ffmpeg(format!("audio decoder: {e:?}")))?;

    let width = video_decoder.width();
    let height = video_decoder.height();

    let mut scaler = scaling::Context::get(
        video_decoder.format(),
        width,
        height,
        Pixel::RGBA,
        width,
        height,
        ScalingFlags::BILINEAR,
    )
    .map_err(|e| MediaLoadError::Ffmpeg(format!("scaler: {e:?}")))?;

    let out_sample_format = Sample::F32(SampleType::Planar);
    let mut resampler = resampling::Context::get(
        audio_decoder.format(),
        audio_decoder.channel_layout(),
        audio_decoder.rate(),
        out_sample_format,
        audio_decoder.channel_layout(),
        audio_decoder.rate(),
    )
    .map_err(|e| MediaLoadError::Ffmpeg(format!("resampler: {e:?}")))?;

    let channels = audio_decoder.channel_layout().channels() as usize;
    let mut samples: Vec<Vec<f32>> = vec![Vec::new(); channels.max(1)];
    let mut frames: Vec<VideoFrame> = Vec::new();

    let time_base = video_stream.time_base();
    let fps = {
        let rate = video_stream.avg_frame_rate();
        if rate.denominator() != 0 {
            rate.numerator() as f32 / rate.denominator() as f32
        } else {
            30.0
        }
    };

    let mut video_frame = ffmpeg::frame::Video::empty();
    let mut rgba_frame = ffmpeg::frame::Video::empty();
    let mut audio_frame = ffmpeg::frame::Audio::empty();

    for (stream, packet) in input.packets() {
        if stream.index() == video_stream_index {
            if video_decoder.send_packet(&packet).is_ok() {
                while video_decoder.receive_frame(&mut video_frame).is_ok() {
                    scaler
                        .run(&video_frame, &mut rgba_frame)
                        .map_err(|e| MediaLoadError::Ffmpeg(format!("scale: {e:?}")))?;
                    let stride = rgba_frame.stride(0);
                    let data = rgba_frame.data(0);
                    let mut buffer = vec![0u8; (width * height * 4) as usize];
                    for y in 0..height as usize {
                        let row_start = y * stride;
                        let row_end = row_start + (width * 4) as usize;
                        let dst_start = y * (width * 4) as usize;
                        let dst_end = dst_start + (width * 4) as usize;
                        buffer[dst_start..dst_end].copy_from_slice(&data[row_start..row_end]);
                    }
                    let pts = video_frame.pts().unwrap_or(0);
                    let timestamp = pts as f32 * time_base.numerator() as f32
                        / time_base.denominator() as f32;
                    frames.push(VideoFrame {
                        timestamp,
                        data: Arc::new(buffer),
                    });
                }
            }
        } else if stream.index() == audio_stream_index {
            if audio_decoder.send_packet(&packet).is_ok() {
                while audio_decoder.receive_frame(&mut audio_frame).is_ok() {
                    let mut out = ffmpeg::frame::Audio::empty();
                    resampler
                        .run(&audio_frame, &mut out)
                        .map_err(|e| MediaLoadError::Ffmpeg(format!("resample: {e:?}")))?;
                    let out_samples = out.samples() as usize;
                    let out_channels = out.channels() as usize;
                    if samples.len() < out_channels {
                        samples.resize_with(out_channels, Vec::new);
                    }
                    for ch in 0..out_channels {
                        let data = out.data(ch);
                        let data = unsafe {
                            std::slice::from_raw_parts(
                                data.as_ptr() as *const f32,
                                out_samples,
                            )
                        };
                        samples[ch].extend_from_slice(data);
                    }
                }
            }
        }
    }

    let _ = video_decoder.send_eof();
    while video_decoder.receive_frame(&mut video_frame).is_ok() {
        scaler
            .run(&video_frame, &mut rgba_frame)
            .map_err(|e| MediaLoadError::Ffmpeg(format!("scale: {e:?}")))?;
        let stride = rgba_frame.stride(0);
        let data = rgba_frame.data(0);
        let mut buffer = vec![0u8; (width * height * 4) as usize];
        for y in 0..height as usize {
            let row_start = y * stride;
            let row_end = row_start + (width * 4) as usize;
            let dst_start = y * (width * 4) as usize;
            let dst_end = dst_start + (width * 4) as usize;
            buffer[dst_start..dst_end].copy_from_slice(&data[row_start..row_end]);
        }
        let pts = video_frame.pts().unwrap_or(0);
        let timestamp = pts as f32 * time_base.numerator() as f32
            / time_base.denominator() as f32;
        frames.push(VideoFrame {
            timestamp,
            data: Arc::new(buffer),
        });
    }

    let _ = audio_decoder.send_eof();
    while audio_decoder.receive_frame(&mut audio_frame).is_ok() {
        let mut out = ffmpeg::frame::Audio::empty();
        resampler
            .run(&audio_frame, &mut out)
            .map_err(|e| MediaLoadError::Ffmpeg(format!("resample: {e:?}")))?;
        let out_samples = out.samples() as usize;
        let out_channels = out.channels() as usize;
        if samples.len() < out_channels {
            samples.resize_with(out_channels, Vec::new);
        }
        for ch in 0..out_channels {
            let data = out.data(ch);
            let data = unsafe {
                std::slice::from_raw_parts(
                    data.as_ptr() as *const f32,
                    out_samples,
                )
            };
            samples[ch].extend_from_slice(data);
        }
    }

    let sample_rate = audio_decoder.rate() as u32;
    let video = VideoCache {
        frames,
        width,
        height,
        fps: if fps.is_finite() && fps > 0.0 { fps } else { 30.0 },
    };

    Ok((samples, sample_rate, video))
}

fn save_track_sample(track: &Track, path: &PathBuf) -> Result<(), Box<dyn std::error::Error>> {
    let samples = track.samples.lock();
    if samples.is_empty() || samples[0].is_empty() {
        return Err("No sample data to save".into());
    }
    let num_channels = samples.len().max(1);
    let num_samples = samples[0].len();
    let spec = hound::WavSpec {
        channels: num_channels as u16,
        sample_rate: 44100,
        bits_per_sample: 32,
        sample_format: hound::SampleFormat::Float,
    };
    let mut writer = hound::WavWriter::create(path, spec)?;
    for i in 0..num_samples {
        for ch in 0..num_channels {
            let sample = samples.get(ch).and_then(|buf| buf.get(i)).copied().unwrap_or(0.0);
            writer.write_sample(sample)?;
        }
    }
    writer.finalize()?;
    Ok(())
}


fn capture_track_params(track: &Track, params: &mut HashMap<String, f32>) {
    let f = |a: &AtomicU32| f32::from_bits(a.load(Ordering::Relaxed));
    let b = |a: &AtomicBool| if a.load(Ordering::Relaxed) { 1.0 } else { 0.0 };
    let u = |a: &AtomicU32| a.load(Ordering::Relaxed) as f32;
    let i = |a: &AtomicI32| a.load(Ordering::Relaxed) as f32;

    params.insert("level".to_string(), f(&track.level));
    params.insert("muted".to_string(), b(&track.is_muted));
    params.insert("tape_speed".to_string(), f(&track.tape_speed));
    params.insert("tape_rate_mode".to_string(), u(&track.tape_rate_mode));
    params.insert("tape_rotate".to_string(), f(&track.tape_rotate));
    params.insert("tape_glide".to_string(), f(&track.tape_glide));
    params.insert("tape_sos".to_string(), f(&track.tape_sos));
    params.insert("tape_reverse".to_string(), b(&track.tape_reverse));
    params.insert("tape_freeze".to_string(), b(&track.tape_freeze));
    params.insert("tape_keylock".to_string(), b(&track.tape_keylock));
    params.insert("tape_monitor".to_string(), b(&track.tape_monitor));
    params.insert("tape_overdub".to_string(), b(&track.tape_overdub));
    params.insert("loop_start".to_string(), f(&track.loop_start));
    params.insert("trigger_start".to_string(), f(&track.trigger_start));
    params.insert("loop_length".to_string(), f(&track.loop_length));
    params.insert("loop_xfade".to_string(), f(&track.loop_xfade));
    params.insert("loop_enabled".to_string(), b(&track.loop_enabled));
    params.insert("loop_mode".to_string(), u(&track.loop_mode));
    params.insert("granular_type".to_string(), u(&track.granular_type));
    params.insert("mosaic_pitch".to_string(), f(&track.mosaic_pitch));
    params.insert("mosaic_rate".to_string(), f(&track.mosaic_rate));
    params.insert("mosaic_size".to_string(), f(&track.mosaic_size));
    params.insert("mosaic_contour".to_string(), f(&track.mosaic_contour));
    params.insert("mosaic_warp".to_string(), f(&track.mosaic_warp));
    params.insert("mosaic_spray".to_string(), f(&track.mosaic_spray));
    params.insert("mosaic_pattern".to_string(), f(&track.mosaic_pattern));
    params.insert("mosaic_wet".to_string(), f(&track.mosaic_wet));
    params.insert("mosaic_post_gain".to_string(), f(&track.mosaic_post_gain));
    params.insert("mosaic_spatial".to_string(), f(&track.mosaic_spatial));
    params.insert("mosaic_detune".to_string(), f(&track.mosaic_detune));
    params.insert("mosaic_rand_rate".to_string(), f(&track.mosaic_rand_rate));
    params.insert("mosaic_rand_size".to_string(), f(&track.mosaic_rand_size));
    params.insert("mosaic_sos".to_string(), f(&track.mosaic_sos));
    params.insert("mosaic_enabled".to_string(), b(&track.mosaic_enabled));
    params.insert("mosaic_loop_lock".to_string(), b(&track.mosaic_loop_lock));
    params.insert("ring_cutoff".to_string(), f(&track.ring_cutoff));
    params.insert("ring_resonance".to_string(), f(&track.ring_resonance));
    params.insert("ring_decay".to_string(), f(&track.ring_decay));
    params.insert("ring_decay_mode".to_string(), u(&track.ring_decay_mode));
    params.insert("ring_pitch".to_string(), f(&track.ring_pitch));
    params.insert("ring_tone".to_string(), f(&track.ring_tone));
    params.insert("ring_tilt".to_string(), f(&track.ring_tilt));
    params.insert("ring_slope".to_string(), f(&track.ring_slope));
    params.insert("ring_wet".to_string(), f(&track.ring_wet));
    params.insert("ring_detune".to_string(), f(&track.ring_detune));
    params.insert("ring_waves".to_string(), f(&track.ring_waves));
    params.insert("ring_waves_rate".to_string(), f(&track.ring_waves_rate));
    params.insert("ring_waves_rate_mode".to_string(), u(&track.ring_waves_rate_mode));
    params.insert("ring_noise".to_string(), f(&track.ring_noise));
    params.insert("ring_noise_rate".to_string(), f(&track.ring_noise_rate));
    params.insert("ring_noise_rate_mode".to_string(), u(&track.ring_noise_rate_mode));
    params.insert("ring_scale".to_string(), u(&track.ring_scale));
    params.insert("ring_pre_post".to_string(), b(&track.ring_pre_post));
    params.insert("ring_enabled".to_string(), b(&track.ring_enabled));
    params.insert("g8_enabled".to_string(), b(&track.g8_enabled));
    params.insert("g8_rate_index".to_string(), u(&track.g8_rate_index));
    for i in 0..G8_STEPS {
        params.insert(format!("g8_step_{}", i), f(&track.g8_steps[i]));
    }
    params.insert("modul8_enabled".to_string(), b(&track.modul8_enabled));
    for i in 0..MODUL8_LFOS {
        params.insert(format!("modul8_wave_{}", i), u(&track.modul8_wave[i]));
        params.insert(format!("modul8_rate_{}", i), f(&track.modul8_rate[i]));
        params.insert(format!("modul8_sync_{}", i), b(&track.modul8_sync[i]));
        params.insert(format!("modul8_division_{}", i), u(&track.modul8_division[i]));
        params.insert(format!("modul8_amount_{}", i), f(&track.modul8_amount[i]));
        params.insert(format!("modul8_bias_{}", i), f(&track.modul8_bias[i]));
        params.insert(format!("modul8_target_{}", i), u(&track.modul8_target[i]));
    }
    params.insert("texture_enabled".to_string(), b(&track.texture_enabled));
    params.insert("texture_gate".to_string(), b(&track.texture_gate));
    params.insert("texture_drive".to_string(), f(&track.texture_drive));
    params.insert("texture_compress".to_string(), f(&track.texture_compress));
    params.insert("texture_crush".to_string(), f(&track.texture_crush));
    params.insert("texture_tilt".to_string(), f(&track.texture_tilt));
    params.insert("texture_noise".to_string(), f(&track.texture_noise));
    params.insert(
        "texture_noise_decay".to_string(),
        f(&track.texture_noise_decay),
    );
    params.insert(
        "texture_noise_color".to_string(),
        f(&track.texture_noise_color),
    );
    params.insert("texture_wet".to_string(), f(&track.texture_wet));
    params.insert("texture_post_gain".to_string(), f(&track.texture_post_gain));
    params.insert("reflect_enabled".to_string(), b(&track.reflect_enabled));
    params.insert("reflect_freeze".to_string(), b(&track.reflect_freeze));
    params.insert("reflect_delay".to_string(), f(&track.reflect_delay));
    params.insert("reflect_time".to_string(), f(&track.reflect_time));
    params.insert("reflect_time_mode".to_string(), u(&track.reflect_time_mode));
    params.insert("reflect_reverb".to_string(), f(&track.reflect_reverb));
    params.insert("reflect_size".to_string(), f(&track.reflect_size));
    params.insert("reflect_feedback".to_string(), f(&track.reflect_feedback));
    params.insert("reflect_spread".to_string(), f(&track.reflect_spread));
    params.insert("reflect_damp".to_string(), f(&track.reflect_damp));
    params.insert("reflect_decay".to_string(), f(&track.reflect_decay));
    params.insert(
        "reflect_post_gain".to_string(),
        f(&track.reflect_post_gain),
    );

    for i in 0..4 {
        params.insert(format!("animate_slot_type_{}", i), u(&track.animate_slot_types[i]));
        params.insert(format!("animate_slot_wavetable_{}", i), u(&track.animate_slot_wavetables[i]));
        params.insert(format!("animate_slot_sample_{}", i), u(&track.animate_slot_samples[i]));
        params.insert(format!("animate_slot_coarse_{}", i), f(&track.animate_slot_coarse[i]));
        params.insert(format!("animate_slot_fine_{}", i), f(&track.animate_slot_fine[i]));
        params.insert(format!("animate_slot_level_{}", i), f(&track.animate_slot_level[i]));
        params.insert(format!("animate_slot_pan_{}", i), f(&track.animate_slot_pan[i]));
        params.insert(format!("animate_slot_wt_lfo_amount_{}", i), f(&track.animate_slot_wt_lfo_amount[i]));
        params.insert(format!("animate_slot_wt_lfo_shape_{}", i), u(&track.animate_slot_wt_lfo_shape[i]));
        params.insert(format!("animate_slot_wt_lfo_rate_{}", i), f(&track.animate_slot_wt_lfo_rate[i]));
        params.insert(format!("animate_slot_wt_lfo_sync_{}", i), b(&track.animate_slot_wt_lfo_sync[i]));
        params.insert(format!("animate_slot_wt_lfo_division_{}", i), u(&track.animate_slot_wt_lfo_division[i]));
        params.insert(format!("animate_slot_sample_start_{}", i), f(&track.animate_slot_sample_start[i]));
        params.insert(format!("animate_slot_loop_start_{}", i), f(&track.animate_slot_loop_start[i]));
        params.insert(format!("animate_slot_loop_end_{}", i), f(&track.animate_slot_loop_end[i]));
        params.insert(format!("animate_slot_filter_type_{}", i), u(&track.animate_slot_filter_type[i]));
        params.insert(format!("animate_slot_filter_cutoff_{}", i), f(&track.animate_slot_filter_cutoff[i]));
        params.insert(format!("animate_slot_filter_resonance_{}", i), f(&track.animate_slot_filter_resonance[i]));
    }
    params.insert("animate_slot_a_attack".to_string(), f(&track.animate_slot_a_attack));
    params.insert("animate_slot_a_decay".to_string(), f(&track.animate_slot_a_decay));
    params.insert("animate_slot_a_sustain".to_string(), f(&track.animate_slot_a_sustain));
    params.insert("animate_slot_a_release".to_string(), f(&track.animate_slot_a_release));

    params.insert("animate_vector_x".to_string(), f(&track.animate_vector_x));
    params.insert("animate_vector_y".to_string(), f(&track.animate_vector_y));
    params.insert("animate_lfo_x_waveform".to_string(), u(&track.animate_lfo_x_waveform));
    params.insert("animate_lfo_x_sync".to_string(), b(&track.animate_lfo_x_sync));
    params.insert("animate_lfo_x_division".to_string(), u(&track.animate_lfo_x_division));
    params.insert("animate_lfo_x_rate".to_string(), f(&track.animate_lfo_x_rate));
    params.insert("animate_lfo_x_amount".to_string(), f(&track.animate_lfo_x_amount));
    params.insert("animate_lfo_y_waveform".to_string(), u(&track.animate_lfo_y_waveform));
    params.insert("animate_lfo_y_sync".to_string(), b(&track.animate_lfo_y_sync));
    params.insert("animate_lfo_y_division".to_string(), u(&track.animate_lfo_y_division));
    params.insert("animate_lfo_y_rate".to_string(), f(&track.animate_lfo_y_rate));
    params.insert("animate_lfo_y_amount".to_string(), f(&track.animate_lfo_y_amount));

    params.insert("fmmi_car_wave".to_string(), u(&track.fmmi_car_wave));
    params.insert("fmmi_car_freq".to_string(), f(&track.fmmi_car_freq));
    params.insert("fmmi_car_detune".to_string(), f(&track.fmmi_car_detune));
    params.insert("fmmi_mod_wave".to_string(), u(&track.fmmi_mod_wave));
    params.insert("fmmi_mod_mode".to_string(), u(&track.fmmi_mod_mode));
    params.insert("fmmi_mod_value".to_string(), f(&track.fmmi_mod_value));
    params.insert("fmmi_mod_detune".to_string(), f(&track.fmmi_mod_detune));
    params.insert("fmmi_index".to_string(), f(&track.fmmi_index));
    params.insert("fmmi_feedback".to_string(), f(&track.fmmi_feedback));
    params.insert("fmmi_drive".to_string(), f(&track.fmmi_drive));
    params.insert("fmmi_out_level".to_string(), f(&track.fmmi_out_level));
    params.insert("fmmi_amp_attack".to_string(), f(&track.fmmi_amp_attack));
    params.insert("fmmi_amp_decay".to_string(), f(&track.fmmi_amp_decay));
    params.insert("fmmi_amp_sustain".to_string(), f(&track.fmmi_amp_sustain));
    params.insert("fmmi_amp_release".to_string(), f(&track.fmmi_amp_release));
    params.insert("fmmi_gate_length".to_string(), f(&track.fmmi_gate_length));
    params.insert("fmmi_prob".to_string(), f(&track.fmmi_prob));
    params.insert("fmmi_poly_enabled".to_string(), b(&track.fmmi_poly_enabled));
    params.insert("fmmi_page".to_string(), u(&track.fmmi_page));
    params.insert("fmmi_edit_step".to_string(), u(&track.fmmi_edit_step));
    params.insert(
        "fmmi_rand_note_enabled".to_string(),
        b(&track.fmmi_rand_note_enabled),
    );
    params.insert(
        "fmmi_rand_car_wave_enabled".to_string(),
        b(&track.fmmi_rand_car_wave_enabled),
    );
    params.insert(
        "fmmi_rand_mod_wave_enabled".to_string(),
        b(&track.fmmi_rand_mod_wave_enabled),
    );
    params.insert(
        "fmmi_rand_mod_mode_enabled".to_string(),
        b(&track.fmmi_rand_mod_mode_enabled),
    );
    params.insert(
        "fmmi_rand_car_freq_enabled".to_string(),
        b(&track.fmmi_rand_car_freq_enabled),
    );
    params.insert(
        "fmmi_rand_car_detune_enabled".to_string(),
        b(&track.fmmi_rand_car_detune_enabled),
    );
    params.insert(
        "fmmi_rand_mod_value_enabled".to_string(),
        b(&track.fmmi_rand_mod_value_enabled),
    );
    params.insert(
        "fmmi_rand_mod_detune_enabled".to_string(),
        b(&track.fmmi_rand_mod_detune_enabled),
    );
    params.insert(
        "fmmi_rand_index_enabled".to_string(),
        b(&track.fmmi_rand_index_enabled),
    );
    params.insert(
        "fmmi_rand_feedback_enabled".to_string(),
        b(&track.fmmi_rand_feedback_enabled),
    );
    params.insert(
        "fmmi_rand_drive_enabled".to_string(),
        b(&track.fmmi_rand_drive_enabled),
    );
    params.insert(
        "fmmi_rand_out_level_enabled".to_string(),
        b(&track.fmmi_rand_out_level_enabled),
    );
    params.insert(
        "fmmi_rand_amp_attack_enabled".to_string(),
        b(&track.fmmi_rand_amp_attack_enabled),
    );
    params.insert(
        "fmmi_rand_amp_decay_enabled".to_string(),
        b(&track.fmmi_rand_amp_decay_enabled),
    );
    params.insert(
        "fmmi_rand_amp_sustain_enabled".to_string(),
        b(&track.fmmi_rand_amp_sustain_enabled),
    );
    params.insert(
        "fmmi_rand_amp_release_enabled".to_string(),
        b(&track.fmmi_rand_amp_release_enabled),
    );
    params.insert(
        "fmmi_rand_gate_length_enabled".to_string(),
        b(&track.fmmi_rand_gate_length_enabled),
    );
    params.insert(
        "fmmi_randomize_amount".to_string(),
        f(&track.fmmi_randomize_amount),
    );
    params.insert(
        "fmmi_randomize_steps_amount".to_string(),
        f(&track.fmmi_randomize_steps_amount),
    );
    params.insert("fmmi_scale_index".to_string(), u(&track.fmmi_scale_index));
    for i in 0..FMMI_STEPS {
        params.insert(
            format!("fmmi_step_note_{}", i),
            track.fmmi_step_note[i].load(Ordering::Relaxed) as f32,
        );
        params.insert(
            format!("fmmi_step_car_wave_{}", i),
            track.fmmi_step_car_wave[i].load(Ordering::Relaxed) as f32,
        );
        params.insert(
            format!("fmmi_step_mod_wave_{}", i),
            track.fmmi_step_mod_wave[i].load(Ordering::Relaxed) as f32,
        );
        params.insert(
            format!("fmmi_step_mod_mode_{}", i),
            track.fmmi_step_mod_mode[i].load(Ordering::Relaxed) as f32,
        );
        params.insert(format!("fmmi_step_car_freq_{}", i), f(&track.fmmi_step_car_freq[i]));
        params.insert(
            format!("fmmi_step_car_detune_{}", i),
            f(&track.fmmi_step_car_detune[i]),
        );
        params.insert(format!("fmmi_step_mod_value_{}", i), f(&track.fmmi_step_mod_value[i]));
        params.insert(
            format!("fmmi_step_mod_detune_{}", i),
            f(&track.fmmi_step_mod_detune[i]),
        );
        params.insert(format!("fmmi_step_index_{}", i), f(&track.fmmi_step_index[i]));
        params.insert(format!("fmmi_step_feedback_{}", i), f(&track.fmmi_step_feedback[i]));
        params.insert(format!("fmmi_step_drive_{}", i), f(&track.fmmi_step_drive[i]));
        params.insert(
            format!("fmmi_step_out_level_{}", i),
            f(&track.fmmi_step_out_level[i]),
        );
        params.insert(
            format!("fmmi_step_amp_attack_{}", i),
            f(&track.fmmi_step_amp_attack[i]),
        );
        params.insert(
            format!("fmmi_step_amp_decay_{}", i),
            f(&track.fmmi_step_amp_decay[i]),
        );
        params.insert(
            format!("fmmi_step_amp_sustain_{}", i),
            f(&track.fmmi_step_amp_sustain[i]),
        );
        params.insert(
            format!("fmmi_step_amp_release_{}", i),
            f(&track.fmmi_step_amp_release[i]),
        );
        params.insert(
            format!("fmmi_step_gate_length_{}", i),
            f(&track.fmmi_step_gate_length[i]),
        );
    }

    for osc in 0..3 {
        params.insert(format!("monomi_osc_wave_{}", osc), u(&track.monomi_osc_wave[osc]));
        params.insert(format!("monomi_osc_octave_{}", osc), u(&track.monomi_osc_octave[osc]));
        params.insert(format!("monomi_osc_detune_{}", osc), f(&track.monomi_osc_detune[osc]));
        params.insert(format!("monomi_osc_mix_{}", osc), f(&track.monomi_osc_mix[osc]));
        params.insert(format!("monomi_osc_pwm_{}", osc), f(&track.monomi_osc_pwm[osc]));
    }
    params.insert("monomi_cutoff".to_string(), f(&track.monomi_cutoff));
    params.insert("monomi_resonance".to_string(), f(&track.monomi_resonance));
    params.insert("monomi_filter_morph".to_string(), f(&track.monomi_filter_morph));
    params.insert("monomi_filter_mode".to_string(), u(&track.monomi_filter_mode));
    params.insert("monomi_volume".to_string(), f(&track.monomi_volume));
    params.insert("monomi_amp_attack".to_string(), f(&track.monomi_amp_attack));
    params.insert("monomi_amp_decay".to_string(), f(&track.monomi_amp_decay));
    params.insert("monomi_amp_sustain".to_string(), f(&track.monomi_amp_sustain));
    params.insert("monomi_amp_release".to_string(), f(&track.monomi_amp_release));
    params.insert("monomi_filter_attack".to_string(), f(&track.monomi_filter_attack));
    params.insert("monomi_filter_decay".to_string(), f(&track.monomi_filter_decay));
    params.insert("monomi_filter_sustain".to_string(), f(&track.monomi_filter_sustain));
    params.insert("monomi_filter_release".to_string(), f(&track.monomi_filter_release));
    params.insert("monomi_filter_intensity".to_string(), f(&track.monomi_filter_intensity));
    params.insert("monomi_filter_polarity".to_string(), f(&track.monomi_filter_polarity));
    params.insert("monomi_filter_saturation".to_string(), f(&track.monomi_filter_saturation));
    params.insert("monomi_filter_sat_env".to_string(), f(&track.monomi_filter_sat_env));
    params.insert("monomi_filter_sat_pre".to_string(), b(&track.monomi_filter_sat_pre));
    params.insert("monomi_mix_comp_mode".to_string(), u(&track.monomi_mix_comp_mode));
    params.insert("monomi_glide".to_string(), f(&track.monomi_glide));
    params.insert("monomi_prob".to_string(), f(&track.monomi_prob));
    params.insert("monomi_scale_index".to_string(), u(&track.monomi_scale_index));
    params.insert("monomi_page".to_string(), u(&track.monomi_page));
    params.insert("monomi_edit_step".to_string(), u(&track.monomi_edit_step));
    for i in 0..3 {
        params.insert(format!("monomi_lfo_shape_{}", i), u(&track.monomi_lfo_shape[i]));
        params.insert(format!("monomi_lfo_target_{}", i), u(&track.monomi_lfo_target[i]));
        params.insert(format!("monomi_lfo_amount_{}", i), f(&track.monomi_lfo_amount[i]));
        params.insert(format!("monomi_lfo_rate_{}", i), f(&track.monomi_lfo_rate[i]));
        params.insert(format!("monomi_lfo_sync_{}", i), b(&track.monomi_lfo_sync[i]));
        params.insert(format!("monomi_lfo_steps_{}", i), u(&track.monomi_lfo_steps[i]));
    }
    params.insert("monomi_rand_cutoff".to_string(), b(&track.monomi_rand_cutoff));
    params.insert("monomi_rand_resonance".to_string(), b(&track.monomi_rand_resonance));
    params.insert("monomi_rand_env_attack".to_string(), b(&track.monomi_rand_env_attack));
    params.insert("monomi_rand_env_decay".to_string(), b(&track.monomi_rand_env_decay));
    params.insert("monomi_rand_env_sustain".to_string(), b(&track.monomi_rand_env_sustain));
    params.insert("monomi_rand_env_release".to_string(), b(&track.monomi_rand_env_release));
    params.insert("monomi_rand_gate".to_string(), b(&track.monomi_rand_gate));
    params.insert("monomi_rand_filter_morph".to_string(), b(&track.monomi_rand_filter_morph));
    params.insert("monomi_rand_glide".to_string(), b(&track.monomi_rand_glide));
    params.insert("monomi_rand_osc1_mix".to_string(), b(&track.monomi_rand_osc_mix[0]));
    params.insert("monomi_rand_osc2_mix".to_string(), b(&track.monomi_rand_osc_mix[1]));
    params.insert("monomi_rand_osc3_mix".to_string(), b(&track.monomi_rand_osc_mix[2]));
    params.insert(
        "monomi_rand_osc1_detune".to_string(),
        b(&track.monomi_rand_osc_detune[0]),
    );
    params.insert(
        "monomi_rand_osc2_detune".to_string(),
        b(&track.monomi_rand_osc_detune[1]),
    );
    params.insert(
        "monomi_rand_osc3_detune".to_string(),
        b(&track.monomi_rand_osc_detune[2]),
    );
    params.insert("monomi_rand_osc1_pwm".to_string(), b(&track.monomi_rand_osc_pwm[0]));
    params.insert("monomi_rand_osc2_pwm".to_string(), b(&track.monomi_rand_osc_pwm[1]));
    params.insert("monomi_rand_osc3_pwm".to_string(), b(&track.monomi_rand_osc_pwm[2]));
    params.insert(
        "monomi_randomize_amount".to_string(),
        f(&track.monomi_randomize_amount),
    );
    for step in 0..MONOMI_STEPS {
        params.insert(format!("monomi_step_note_{}", step), i(&track.monomi_step_note[step]));
        params.insert(
            format!("monomi_step_cutoff_{}", step),
            f(&track.monomi_step_cutoff[step]),
        );
        params.insert(
            format!("monomi_step_resonance_{}", step),
            f(&track.monomi_step_resonance[step]),
        );
        params.insert(
            format!("monomi_step_env_attack_{}", step),
            f(&track.monomi_step_env_attack[step]),
        );
        params.insert(
            format!("monomi_step_env_decay_{}", step),
            f(&track.monomi_step_env_decay[step]),
        );
        params.insert(
            format!("monomi_step_env_sustain_{}", step),
            f(&track.monomi_step_env_sustain[step]),
        );
        params.insert(
            format!("monomi_step_env_release_{}", step),
            f(&track.monomi_step_env_release[step]),
        );
        params.insert(format!("monomi_step_gate_{}", step), f(&track.monomi_step_gate[step]));
        params.insert(
            format!("monomi_step_filter_morph_{}", step),
            f(&track.monomi_step_filter_morph[step]),
        );
        params.insert(format!("monomi_step_glide_{}", step), f(&track.monomi_step_glide[step]));
        for osc in 0..3 {
            params.insert(
                format!("monomi_step_osc{}_mix_{}", osc + 1, step),
                f(&track.monomi_step_osc_mix[osc][step]),
            );
            params.insert(
                format!("monomi_step_osc{}_detune_{}", osc + 1, step),
                f(&track.monomi_step_osc_detune[osc][step]),
            );
            params.insert(
                format!("monomi_step_osc{}_pwm_{}", osc + 1, step),
                f(&track.monomi_step_osc_pwm[osc][step]),
            );
        }
    }

    params.insert("kick_pitch".to_string(), f(&track.kick_pitch));
    params.insert("kick_decay".to_string(), f(&track.kick_decay));
    params.insert("kick_attack".to_string(), f(&track.kick_attack));
    params.insert(
        "kick_pitch_env_amount".to_string(),
        f(&track.kick_pitch_env_amount),
    );
    params.insert("kick_drive".to_string(), f(&track.kick_drive));
    params.insert("kick_level".to_string(), f(&track.kick_level));
    params.insert("kick_filter_type".to_string(), u(&track.kick_filter_type));
    params.insert("kick_filter_cutoff".to_string(), f(&track.kick_filter_cutoff));
    params.insert("kick_filter_resonance".to_string(), f(&track.kick_filter_resonance));
    params.insert("kick_filter_pre_drive".to_string(), b(&track.kick_filter_pre_drive));
    params.insert("kick_cut_group".to_string(), u(&track.kick_cut_group));
    params.insert("kick_cut_by".to_string(), u(&track.kick_cut_by));
    params.insert("kick_prob".to_string(), f(&track.kick_prob));
    params.insert("kick_lane_enabled".to_string(), b(&track.kick_lane_enabled));
    params.insert("snare_tone".to_string(), f(&track.snare_tone));
    params.insert("snare_decay".to_string(), f(&track.snare_decay));
    params.insert("snare_snappy".to_string(), f(&track.snare_snappy));
    params.insert("snare_attack".to_string(), f(&track.snare_attack));
    params.insert("snare_drive".to_string(), f(&track.snare_drive));
    params.insert("snare_level".to_string(), f(&track.snare_level));
    params.insert("snare_filter_type".to_string(), u(&track.snare_filter_type));
    params.insert("snare_filter_cutoff".to_string(), f(&track.snare_filter_cutoff));
    params.insert("snare_filter_resonance".to_string(), f(&track.snare_filter_resonance));
    params.insert("snare_filter_pre_drive".to_string(), b(&track.snare_filter_pre_drive));
    params.insert("snare_cut_group".to_string(), u(&track.snare_cut_group));
    params.insert("snare_cut_by".to_string(), u(&track.snare_cut_by));
    params.insert("snare_prob".to_string(), f(&track.snare_prob));
    params.insert("snare_lane_enabled".to_string(), b(&track.snare_lane_enabled));
    params.insert("clap_pitch".to_string(), f(&track.clap_pitch));
    params.insert("clap_decay".to_string(), f(&track.clap_decay));
    params.insert("clap_tone".to_string(), f(&track.clap_tone));
    params.insert("clap_drive".to_string(), f(&track.clap_drive));
    params.insert("clap_level".to_string(), f(&track.clap_level));
    params.insert("clap_filter_type".to_string(), u(&track.clap_filter_type));
    params.insert("clap_filter_cutoff".to_string(), f(&track.clap_filter_cutoff));
    params.insert(
        "clap_filter_resonance".to_string(),
        f(&track.clap_filter_resonance),
    );
    params.insert(
        "clap_filter_pre_drive".to_string(),
        b(&track.clap_filter_pre_drive),
    );
    params.insert("clap_cut_group".to_string(), u(&track.clap_cut_group));
    params.insert("clap_cut_by".to_string(), u(&track.clap_cut_by));
    params.insert("clap_prob".to_string(), f(&track.clap_prob));
    params.insert("clap_lane_enabled".to_string(), b(&track.clap_lane_enabled));
    params.insert("hat_pitch".to_string(), f(&track.hat_pitch));
    params.insert("hat_decay".to_string(), f(&track.hat_decay));
    params.insert("hat_tone".to_string(), f(&track.hat_tone));
    params.insert("hat_drive".to_string(), f(&track.hat_drive));
    params.insert("hat_level".to_string(), f(&track.hat_level));
    params.insert("hat_filter_type".to_string(), u(&track.hat_filter_type));
    params.insert("hat_filter_cutoff".to_string(), f(&track.hat_filter_cutoff));
    params.insert("hat_filter_resonance".to_string(), f(&track.hat_filter_resonance));
    params.insert("hat_filter_pre_drive".to_string(), b(&track.hat_filter_pre_drive));
    params.insert("hat_cut_group".to_string(), u(&track.hat_cut_group));
    params.insert("hat_cut_by".to_string(), u(&track.hat_cut_by));
    params.insert("hat_prob".to_string(), f(&track.hat_prob));
    params.insert("hat_lane_enabled".to_string(), b(&track.hat_lane_enabled));
    params.insert("perc1_pitch".to_string(), f(&track.perc1_pitch));
    params.insert("perc1_decay".to_string(), f(&track.perc1_decay));
    params.insert("perc1_tone".to_string(), f(&track.perc1_tone));
    params.insert("perc1_drive".to_string(), f(&track.perc1_drive));
    params.insert("perc1_level".to_string(), f(&track.perc1_level));
    params.insert("perc1_filter_type".to_string(), u(&track.perc1_filter_type));
    params.insert("perc1_filter_cutoff".to_string(), f(&track.perc1_filter_cutoff));
    params.insert(
        "perc1_filter_resonance".to_string(),
        f(&track.perc1_filter_resonance),
    );
    params.insert(
        "perc1_filter_pre_drive".to_string(),
        b(&track.perc1_filter_pre_drive),
    );
    params.insert("perc1_cut_group".to_string(), u(&track.perc1_cut_group));
    params.insert("perc1_cut_by".to_string(), u(&track.perc1_cut_by));
    params.insert("perc1_prob".to_string(), f(&track.perc1_prob));
    params.insert("perc1_lane_enabled".to_string(), b(&track.perc1_lane_enabled));
    params.insert("perc2_pitch".to_string(), f(&track.perc2_pitch));
    params.insert("perc2_decay".to_string(), f(&track.perc2_decay));
    params.insert("perc2_tone".to_string(), f(&track.perc2_tone));
    params.insert("perc2_drive".to_string(), f(&track.perc2_drive));
    params.insert("perc2_level".to_string(), f(&track.perc2_level));
    params.insert("perc2_filter_type".to_string(), u(&track.perc2_filter_type));
    params.insert("perc2_filter_cutoff".to_string(), f(&track.perc2_filter_cutoff));
    params.insert(
        "perc2_filter_resonance".to_string(),
        f(&track.perc2_filter_resonance),
    );
    params.insert(
        "perc2_filter_pre_drive".to_string(),
        b(&track.perc2_filter_pre_drive),
    );
    params.insert("perc2_cut_group".to_string(), u(&track.perc2_cut_group));
    params.insert("perc2_cut_by".to_string(), u(&track.perc2_cut_by));
    params.insert("perc2_prob".to_string(), f(&track.perc2_prob));
    params.insert("perc2_lane_enabled".to_string(), b(&track.perc2_lane_enabled));
    params.insert("crash_pitch".to_string(), f(&track.crash_pitch));
    params.insert("crash_decay".to_string(), f(&track.crash_decay));
    params.insert("crash_tone".to_string(), f(&track.crash_tone));
    params.insert("crash_drive".to_string(), f(&track.crash_drive));
    params.insert("crash_level".to_string(), f(&track.crash_level));
    params.insert("crash_filter_type".to_string(), u(&track.crash_filter_type));
    params.insert("crash_filter_cutoff".to_string(), f(&track.crash_filter_cutoff));
    params.insert(
        "crash_filter_resonance".to_string(),
        f(&track.crash_filter_resonance),
    );
    params.insert(
        "crash_filter_pre_drive".to_string(),
        b(&track.crash_filter_pre_drive),
    );
    params.insert("crash_cut_group".to_string(), u(&track.crash_cut_group));
    params.insert("crash_cut_by".to_string(), u(&track.crash_cut_by));
    params.insert("crash_prob".to_string(), f(&track.crash_prob));
    params.insert("crash_lane_enabled".to_string(), b(&track.crash_lane_enabled));
    for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
        params.insert(
            format!("samp_cut_group_{}", samp_idx),
            u(&track.samp_cut_group[samp_idx]),
        );
        params.insert(
            format!("samp_cut_by_{}", samp_idx),
            u(&track.samp_cut_by[samp_idx]),
        );
        params.insert(
            format!("samp_prob_{}", samp_idx),
            f(&track.samp_prob[samp_idx]),
        );
        params.insert(
            format!("samp_lane_enabled_{}", samp_idx),
            b(&track.samp_lane_enabled[samp_idx]),
        );
    }
    params.insert("syndrm_page".to_string(), u(&track.syndrm_page));
    params.insert("syndrm_edit_lane".to_string(), u(&track.syndrm_edit_lane));
    params.insert("syndrm_edit_step".to_string(), u(&track.syndrm_edit_step));
    params.insert("syndrm_step_hold".to_string(), b(&track.syndrm_step_hold));
    params.insert(
        "syndrm_randomize_amount".to_string(),
        f(&track.syndrm_randomize_amount),
    );
    for i in 0..SYNDRM_STEPS {
        params.insert(
            format!("syndrm_kick_step_override_{}", i),
            b(&track.kick_step_override_enabled[i]),
        );
        params.insert(format!("syndrm_kick_step_pitch_{}", i), f(&track.kick_step_pitch[i]));
        params.insert(format!("syndrm_kick_step_decay_{}", i), f(&track.kick_step_decay[i]));
        params.insert(format!("syndrm_kick_step_attack_{}", i), f(&track.kick_step_attack[i]));
        params.insert(format!("syndrm_kick_step_drive_{}", i), f(&track.kick_step_drive[i]));
        params.insert(format!("syndrm_kick_step_level_{}", i), f(&track.kick_step_level[i]));
        params.insert(
            format!("syndrm_kick_step_filter_type_{}", i),
            u(&track.kick_step_filter_type[i]),
        );
        params.insert(
            format!("syndrm_kick_step_filter_cutoff_{}", i),
            f(&track.kick_step_filter_cutoff[i]),
        );
        params.insert(
            format!("syndrm_kick_step_filter_resonance_{}", i),
            f(&track.kick_step_filter_resonance[i]),
        );
        params.insert(
            format!("syndrm_kick_step_retrig_enabled_{}", i),
            b(&track.kick_step_retrig_enabled[i]),
        );
        params.insert(
            format!("syndrm_kick_step_retrig_division_{}", i),
            u(&track.kick_step_retrig_division[i]),
        );
        params.insert(
            format!("syndrm_snare_step_override_{}", i),
            b(&track.snare_step_override_enabled[i]),
        );
        params.insert(format!("syndrm_snare_step_tone_{}", i), f(&track.snare_step_tone[i]));
        params.insert(format!("syndrm_snare_step_decay_{}", i), f(&track.snare_step_decay[i]));
        params.insert(
            format!("syndrm_snare_step_snappy_{}", i),
            f(&track.snare_step_snappy[i]),
        );
        params.insert(
            format!("syndrm_snare_step_attack_{}", i),
            f(&track.snare_step_attack[i]),
        );
        params.insert(format!("syndrm_snare_step_drive_{}", i), f(&track.snare_step_drive[i]));
        params.insert(format!("syndrm_snare_step_level_{}", i), f(&track.snare_step_level[i]));
        params.insert(
            format!("syndrm_snare_step_filter_type_{}", i),
            u(&track.snare_step_filter_type[i]),
        );
        params.insert(
            format!("syndrm_snare_step_filter_cutoff_{}", i),
            f(&track.snare_step_filter_cutoff[i]),
        );
        params.insert(
            format!("syndrm_snare_step_filter_resonance_{}", i),
            f(&track.snare_step_filter_resonance[i]),
        );
        params.insert(
            format!("syndrm_snare_step_retrig_enabled_{}", i),
            b(&track.snare_step_retrig_enabled[i]),
        );
        params.insert(
            format!("syndrm_snare_step_retrig_division_{}", i),
            u(&track.snare_step_retrig_division[i]),
        );
        params.insert(
            format!("syndrm_clap_step_override_{}", i),
            b(&track.clap_step_override_enabled[i]),
        );
        params.insert(
            format!("syndrm_clap_step_pitch_{}", i),
            f(&track.clap_step_pitch[i]),
        );
        params.insert(
            format!("syndrm_clap_step_decay_{}", i),
            f(&track.clap_step_decay[i]),
        );
        params.insert(
            format!("syndrm_clap_step_tone_{}", i),
            f(&track.clap_step_tone[i]),
        );
        params.insert(
            format!("syndrm_clap_step_drive_{}", i),
            f(&track.clap_step_drive[i]),
        );
        params.insert(
            format!("syndrm_clap_step_level_{}", i),
            f(&track.clap_step_level[i]),
        );
        params.insert(
            format!("syndrm_clap_step_filter_type_{}", i),
            u(&track.clap_step_filter_type[i]),
        );
        params.insert(
            format!("syndrm_clap_step_filter_cutoff_{}", i),
            f(&track.clap_step_filter_cutoff[i]),
        );
        params.insert(
            format!("syndrm_clap_step_filter_resonance_{}", i),
            f(&track.clap_step_filter_resonance[i]),
        );
        params.insert(
            format!("syndrm_clap_step_retrig_enabled_{}", i),
            b(&track.clap_step_retrig_enabled[i]),
        );
        params.insert(
            format!("syndrm_clap_step_retrig_division_{}", i),
            u(&track.clap_step_retrig_division[i]),
        );
        params.insert(
            format!("syndrm_hat_step_override_{}", i),
            b(&track.hat_step_override_enabled[i]),
        );
        params.insert(format!("syndrm_hat_step_pitch_{}", i), f(&track.hat_step_pitch[i]));
        params.insert(format!("syndrm_hat_step_decay_{}", i), f(&track.hat_step_decay[i]));
        params.insert(format!("syndrm_hat_step_tone_{}", i), f(&track.hat_step_tone[i]));
        params.insert(format!("syndrm_hat_step_drive_{}", i), f(&track.hat_step_drive[i]));
        params.insert(format!("syndrm_hat_step_level_{}", i), f(&track.hat_step_level[i]));
        params.insert(
            format!("syndrm_hat_step_filter_type_{}", i),
            u(&track.hat_step_filter_type[i]),
        );
        params.insert(
            format!("syndrm_hat_step_filter_cutoff_{}", i),
            f(&track.hat_step_filter_cutoff[i]),
        );
        params.insert(
            format!("syndrm_hat_step_filter_resonance_{}", i),
            f(&track.hat_step_filter_resonance[i]),
        );
        params.insert(
            format!("syndrm_hat_step_retrig_enabled_{}", i),
            b(&track.hat_step_retrig_enabled[i]),
        );
        params.insert(
            format!("syndrm_hat_step_retrig_division_{}", i),
            u(&track.hat_step_retrig_division[i]),
        );
        params.insert(
            format!("syndrm_perc1_step_override_{}", i),
            b(&track.perc1_step_override_enabled[i]),
        );
        params.insert(
            format!("syndrm_perc1_step_pitch_{}", i),
            f(&track.perc1_step_pitch[i]),
        );
        params.insert(
            format!("syndrm_perc1_step_decay_{}", i),
            f(&track.perc1_step_decay[i]),
        );
        params.insert(
            format!("syndrm_perc1_step_tone_{}", i),
            f(&track.perc1_step_tone[i]),
        );
        params.insert(
            format!("syndrm_perc1_step_drive_{}", i),
            f(&track.perc1_step_drive[i]),
        );
        params.insert(
            format!("syndrm_perc1_step_level_{}", i),
            f(&track.perc1_step_level[i]),
        );
        params.insert(
            format!("syndrm_perc1_step_filter_type_{}", i),
            u(&track.perc1_step_filter_type[i]),
        );
        params.insert(
            format!("syndrm_perc1_step_filter_cutoff_{}", i),
            f(&track.perc1_step_filter_cutoff[i]),
        );
        params.insert(
            format!("syndrm_perc1_step_filter_resonance_{}", i),
            f(&track.perc1_step_filter_resonance[i]),
        );
        params.insert(
            format!("syndrm_perc1_step_retrig_enabled_{}", i),
            b(&track.perc1_step_retrig_enabled[i]),
        );
        params.insert(
            format!("syndrm_perc1_step_retrig_division_{}", i),
            u(&track.perc1_step_retrig_division[i]),
        );
        params.insert(
            format!("syndrm_perc2_step_override_{}", i),
            b(&track.perc2_step_override_enabled[i]),
        );
        params.insert(
            format!("syndrm_perc2_step_pitch_{}", i),
            f(&track.perc2_step_pitch[i]),
        );
        params.insert(
            format!("syndrm_perc2_step_decay_{}", i),
            f(&track.perc2_step_decay[i]),
        );
        params.insert(
            format!("syndrm_perc2_step_tone_{}", i),
            f(&track.perc2_step_tone[i]),
        );
        params.insert(
            format!("syndrm_perc2_step_drive_{}", i),
            f(&track.perc2_step_drive[i]),
        );
        params.insert(
            format!("syndrm_perc2_step_level_{}", i),
            f(&track.perc2_step_level[i]),
        );
        params.insert(
            format!("syndrm_perc2_step_filter_type_{}", i),
            u(&track.perc2_step_filter_type[i]),
        );
        params.insert(
            format!("syndrm_perc2_step_filter_cutoff_{}", i),
            f(&track.perc2_step_filter_cutoff[i]),
        );
        params.insert(
            format!("syndrm_perc2_step_filter_resonance_{}", i),
            f(&track.perc2_step_filter_resonance[i]),
        );
        params.insert(
            format!("syndrm_perc2_step_retrig_enabled_{}", i),
            b(&track.perc2_step_retrig_enabled[i]),
        );
        params.insert(
            format!("syndrm_perc2_step_retrig_division_{}", i),
            u(&track.perc2_step_retrig_division[i]),
        );
        params.insert(
            format!("syndrm_crash_step_override_{}", i),
            b(&track.crash_step_override_enabled[i]),
        );
        params.insert(
            format!("syndrm_crash_step_pitch_{}", i),
            f(&track.crash_step_pitch[i]),
        );
        params.insert(
            format!("syndrm_crash_step_decay_{}", i),
            f(&track.crash_step_decay[i]),
        );
        params.insert(
            format!("syndrm_crash_step_tone_{}", i),
            f(&track.crash_step_tone[i]),
        );
        params.insert(
            format!("syndrm_crash_step_drive_{}", i),
            f(&track.crash_step_drive[i]),
        );
        params.insert(
            format!("syndrm_crash_step_level_{}", i),
            f(&track.crash_step_level[i]),
        );
        params.insert(
            format!("syndrm_crash_step_filter_type_{}", i),
            u(&track.crash_step_filter_type[i]),
        );
        params.insert(
            format!("syndrm_crash_step_filter_cutoff_{}", i),
            f(&track.crash_step_filter_cutoff[i]),
        );
        params.insert(
            format!("syndrm_crash_step_filter_resonance_{}", i),
            f(&track.crash_step_filter_resonance[i]),
        );
        params.insert(
            format!("syndrm_crash_step_retrig_enabled_{}", i),
            b(&track.crash_step_retrig_enabled[i]),
        );
        params.insert(
            format!("syndrm_crash_step_retrig_division_{}", i),
            u(&track.crash_step_retrig_division[i]),
        );
    }

    params.insert("void_base_freq".to_string(), f(&track.void_base_freq));
    params.insert("void_chaos_depth".to_string(), f(&track.void_chaos_depth));
    params.insert("void_entropy".to_string(), f(&track.void_entropy));
    params.insert("void_feedback".to_string(), f(&track.void_feedback));
    params.insert("void_diffusion".to_string(), f(&track.void_diffusion));
    params.insert("void_mod_rate".to_string(), f(&track.void_mod_rate));
    params.insert("void_level".to_string(), f(&track.void_level));
    params.insert("void_pan".to_string(), f(&track.void_pan));
    params.insert("void_width".to_string(), f(&track.void_width));
    params.insert("void_close_decay".to_string(), f(&track.void_close_decay));
    params.insert("void_filter_cutoff".to_string(), f(&track.void_filter_cutoff));
    params.insert("void_filter_resonance".to_string(), f(&track.void_filter_resonance));
    params.insert("void_drive".to_string(), f(&track.void_drive));
    params.insert("void_filter_pre_drive".to_string(), b(&track.void_filter_pre_drive));
    params.insert("void_enabled".to_string(), b(&track.void_enabled));
}

fn apply_track_params(track: &Track, params: &HashMap<String, f32>) {
    let sf = |a: &AtomicU32, name: &str| {
        if let Some(&v) = params.get(name) {
            a.store(v.to_bits(), Ordering::Relaxed);
        }
    };
    let sb = |a: &AtomicBool, name: &str| {
        if let Some(&v) = params.get(name) {
            a.store(v > 0.5, Ordering::Relaxed);
        }
    };
    let su = |a: &AtomicU32, name: &str| {
        if let Some(&v) = params.get(name) {
            a.store(v as u32, Ordering::Relaxed);
        }
    };
    let si = |a: &AtomicI32, name: &str| {
        if let Some(&v) = params.get(name) {
            a.store(v.round() as i32, Ordering::Relaxed);
        }
    };
    let su_clamp_0_14 = |a: &AtomicU32, name: &str| {
        if let Some(&v) = params.get(name) {
            let clamped = v.round().clamp(0.0, 14.0) as u32;
            a.store(clamped, Ordering::Relaxed);
        }
    };
    let sf_clamp_0_1 = |a: &AtomicU32, name: &str| {
        if let Some(&v) = params.get(name) {
            a.store(v.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    };

    sf(&track.level, "level");
    sb(&track.is_muted, "muted");
    sf(&track.tape_speed, "tape_speed");
    sf(&track.tape_speed_smooth, "tape_speed");
    su(&track.tape_rate_mode, "tape_rate_mode");
    sf(&track.tape_rotate, "tape_rotate");
    sf(&track.tape_rotate_smooth, "tape_rotate");
    sf(&track.tape_glide, "tape_glide");
    sf(&track.tape_glide_smooth, "tape_glide");
    sf(&track.tape_sos, "tape_sos");
    sb(&track.tape_reverse, "tape_reverse");
    sb(&track.tape_freeze, "tape_freeze");
    sb(&track.tape_keylock, "tape_keylock");
    sb(&track.tape_monitor, "tape_monitor");
    sb(&track.tape_overdub, "tape_overdub");
    sf(&track.loop_start, "loop_start");
    sf(&track.loop_start_smooth, "loop_start");
    sf(&track.trigger_start, "trigger_start");
    sf(&track.loop_length, "loop_length");
    sf(&track.loop_length_smooth, "loop_length");
    sf(&track.loop_xfade, "loop_xfade");
    sf(&track.loop_xfade_smooth, "loop_xfade");
    sb(&track.loop_enabled, "loop_enabled");
    su(&track.loop_mode, "loop_mode");
    su(&track.granular_type, "granular_type");
    sf(&track.mosaic_pitch, "mosaic_pitch");
    sf(&track.mosaic_rate, "mosaic_rate");
    sf(&track.mosaic_size, "mosaic_size");
    sf(&track.mosaic_contour, "mosaic_contour");
    sf(&track.mosaic_warp, "mosaic_warp");
    sf(&track.mosaic_spray, "mosaic_spray");
    sf(&track.mosaic_pattern, "mosaic_pattern");
    sf(&track.mosaic_wet, "mosaic_wet");
    track
        .mosaic_post_gain
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    sf(&track.mosaic_post_gain, "mosaic_post_gain");
    sf(&track.mosaic_spatial, "mosaic_spatial");
    sf(&track.mosaic_detune, "mosaic_detune");
    sf(&track.mosaic_rand_rate, "mosaic_rand_rate");
    sf(&track.mosaic_rand_size, "mosaic_rand_size");
    sf(&track.mosaic_sos, "mosaic_sos");
    sb(&track.mosaic_enabled, "mosaic_enabled");
    sb(&track.mosaic_loop_lock, "mosaic_loop_lock");
    track.mosaic_post_gain_smooth.store(
        track.mosaic_post_gain.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    sf(&track.ring_cutoff, "ring_cutoff");
    sf(&track.ring_resonance, "ring_resonance");
    sf(&track.ring_decay, "ring_decay");
    su(&track.ring_decay_mode, "ring_decay_mode");
    sf(&track.ring_pitch, "ring_pitch");
    sf(&track.ring_tone, "ring_tone");
    sf(&track.ring_tilt, "ring_tilt");
    sf(&track.ring_slope, "ring_slope");
    sf(&track.ring_wet, "ring_wet");
    sf(&track.ring_detune, "ring_detune");
    sf(&track.ring_waves, "ring_waves");
    sf(&track.ring_waves_rate, "ring_waves_rate");
    su(&track.ring_waves_rate_mode, "ring_waves_rate_mode");
    sf(&track.ring_noise, "ring_noise");
    sf(&track.ring_noise_rate, "ring_noise_rate");
    su(&track.ring_noise_rate_mode, "ring_noise_rate_mode");
    su(&track.ring_scale, "ring_scale");
    sb(&track.ring_pre_post, "ring_pre_post");
    sb(&track.ring_enabled, "ring_enabled");
    track.texture_enabled.store(false, Ordering::Relaxed);
    track.texture_gate.store(false, Ordering::Relaxed);
    track.texture_drive.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_drive_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_compress
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_compress_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.texture_crush.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_crush_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.texture_tilt.store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .texture_tilt_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track.texture_noise.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_noise_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_noise_decay
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_noise_decay_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_noise_color
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track
        .texture_noise_color_smooth
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    track.texture_wet.store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_wet_smooth
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track
        .texture_noise_env
        .store(0.0f32.to_bits(), Ordering::Relaxed);
    track.texture_noise_rng.store(0x2468_1357, Ordering::Relaxed);
    track.texture_crush_phase.store(0, Ordering::Relaxed);
    for channel in 0..2 {
        track
            .texture_noise_lp[channel]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .texture_tilt_lp[channel]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .texture_crush_hold[channel]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
    }
    sb(&track.texture_enabled, "texture_enabled");
    sb(&track.texture_gate, "texture_gate");
    sf(&track.texture_drive, "texture_drive");
    sf(&track.texture_compress, "texture_compress");
    sf(&track.texture_crush, "texture_crush");
    sf(&track.texture_tilt, "texture_tilt");
    sf(&track.texture_noise, "texture_noise");
    sf(&track.texture_noise_decay, "texture_noise_decay");
    sf(&track.texture_noise_color, "texture_noise_color");
    sf(&track.texture_wet, "texture_wet");
    track
        .texture_post_gain
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    sf(&track.texture_post_gain, "texture_post_gain");
    sb(&track.reflect_enabled, "reflect_enabled");
    sb(&track.reflect_freeze, "reflect_freeze");
    sf(&track.reflect_delay, "reflect_delay");
    sf(&track.reflect_time, "reflect_time");
    su(&track.reflect_time_mode, "reflect_time_mode");
    sf(&track.reflect_reverb, "reflect_reverb");
    sf(&track.reflect_size, "reflect_size");
    sf(&track.reflect_feedback, "reflect_feedback");
    sf(&track.reflect_spread, "reflect_spread");
    sf(&track.reflect_damp, "reflect_damp");
    sf(&track.reflect_decay, "reflect_decay");
    track
        .reflect_post_gain
        .store(0.5f32.to_bits(), Ordering::Relaxed);
    sf(&track.reflect_post_gain, "reflect_post_gain");
    track
        .reflect_delay_smooth
        .store(track.reflect_delay.load(Ordering::Relaxed), Ordering::Relaxed);
    track
        .reflect_time_smooth
        .store(track.reflect_time.load(Ordering::Relaxed), Ordering::Relaxed);
    track
        .reflect_reverb_smooth
        .store(track.reflect_reverb.load(Ordering::Relaxed), Ordering::Relaxed);
    track
        .reflect_size_smooth
        .store(track.reflect_size.load(Ordering::Relaxed), Ordering::Relaxed);
    track
        .reflect_feedback_smooth
        .store(track.reflect_feedback.load(Ordering::Relaxed), Ordering::Relaxed);
    track
        .reflect_spread_smooth
        .store(track.reflect_spread.load(Ordering::Relaxed), Ordering::Relaxed);
    track
        .reflect_damp_smooth
        .store(track.reflect_damp.load(Ordering::Relaxed), Ordering::Relaxed);
    track
        .reflect_decay_smooth
        .store(track.reflect_decay.load(Ordering::Relaxed), Ordering::Relaxed);
    track
        .reflect_post_gain_smooth
        .store(track.reflect_post_gain.load(Ordering::Relaxed), Ordering::Relaxed);
    track.texture_drive_smooth.store(
        track.texture_drive.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.texture_compress_smooth.store(
        track.texture_compress.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.texture_crush_smooth.store(
        track.texture_crush.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.texture_tilt_smooth.store(
        track.texture_tilt.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.texture_noise_smooth.store(
        track.texture_noise.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.texture_noise_decay_smooth.store(
        track.texture_noise_decay.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.texture_noise_color_smooth.store(
        track.texture_noise_color.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.texture_wet_smooth.store(
        track.texture_wet.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.texture_post_gain_smooth.store(
        track.texture_post_gain.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.g8_enabled.store(false, Ordering::Relaxed);
    track.g8_rate_index.store(0, Ordering::Relaxed);
    for step in track.g8_steps.iter() {
        step.store(1.0f32.to_bits(), Ordering::Relaxed);
    }
    track
        .g8_gain_smooth
        .store(1.0f32.to_bits(), Ordering::Relaxed);
    sb(&track.g8_enabled, "g8_enabled");
    su(&track.g8_rate_index, "g8_rate_index");
    for i in 0..G8_STEPS {
        sf(&track.g8_steps[i], &format!("g8_step_{}", i));
    }
    track.modul8_enabled.store(false, Ordering::Relaxed);
    for i in 0..MODUL8_LFOS {
        track.modul8_wave[i].store(0, Ordering::Relaxed);
        track.modul8_rate[i].store(1.0f32.to_bits(), Ordering::Relaxed);
        track.modul8_sync[i].store(true, Ordering::Relaxed);
        track.modul8_division[i].store(0, Ordering::Relaxed);
        track.modul8_amount[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.modul8_bias[i].store(0.5f32.to_bits(), Ordering::Relaxed);
        track.modul8_target[i].store(0, Ordering::Relaxed);
        track.modul8_phase[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track.modul8_snh[i].store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .modul8_base_value[i]
            .store(0.0f32.to_bits(), Ordering::Relaxed);
        track
            .modul8_base_target[i]
            .store(u32::MAX, Ordering::Relaxed);
    }
    track.modul8_rng_state.store(0x89ab_cdef, Ordering::Relaxed);
    sb(&track.modul8_enabled, "modul8_enabled");
    for i in 0..MODUL8_LFOS {
        su(&track.modul8_wave[i], &format!("modul8_wave_{}", i));
        sf(&track.modul8_rate[i], &format!("modul8_rate_{}", i));
        sb(&track.modul8_sync[i], &format!("modul8_sync_{}", i));
        su(&track.modul8_division[i], &format!("modul8_division_{}", i));
        sf(&track.modul8_amount[i], &format!("modul8_amount_{}", i));
        sf(&track.modul8_bias[i], &format!("modul8_bias_{}", i));
        su(&track.modul8_target[i], &format!("modul8_target_{}", i));
    }
    track
        .animate_slot_a_attack
        .store(0.01f32.to_bits(), Ordering::Relaxed);
    track
        .animate_slot_a_decay
        .store(0.1f32.to_bits(), Ordering::Relaxed);
    track
        .animate_slot_a_sustain
        .store(0.8f32.to_bits(), Ordering::Relaxed);
    track
        .animate_slot_a_release
        .store(0.3f32.to_bits(), Ordering::Relaxed);
    sf(&track.animate_slot_a_attack, "animate_slot_a_attack");
    sf(&track.animate_slot_a_decay, "animate_slot_a_decay");
    sf(&track.animate_slot_a_sustain, "animate_slot_a_sustain");
    sf(&track.animate_slot_a_release, "animate_slot_a_release");

    for i in 0..4 {
        su(&track.animate_slot_types[i], &format!("animate_slot_type_{}", i));
        su(&track.animate_slot_wavetables[i], &format!("animate_slot_wavetable_{}", i));
        su(&track.animate_slot_samples[i], &format!("animate_slot_sample_{}", i));
        sf(&track.animate_slot_coarse[i], &format!("animate_slot_coarse_{}", i));
        sf(&track.animate_slot_fine[i], &format!("animate_slot_fine_{}", i));
        sf(&track.animate_slot_level[i], &format!("animate_slot_level_{}", i));
        sf(&track.animate_slot_pan[i], &format!("animate_slot_pan_{}", i));
        sf(&track.animate_slot_wt_lfo_amount[i], &format!("animate_slot_wt_lfo_amount_{}", i));
        su(&track.animate_slot_wt_lfo_shape[i], &format!("animate_slot_wt_lfo_shape_{}", i));
        sf(&track.animate_slot_wt_lfo_rate[i], &format!("animate_slot_wt_lfo_rate_{}", i));
        sb(&track.animate_slot_wt_lfo_sync[i], &format!("animate_slot_wt_lfo_sync_{}", i));
        su(&track.animate_slot_wt_lfo_division[i], &format!("animate_slot_wt_lfo_division_{}", i));
        sf(&track.animate_slot_sample_start[i], &format!("animate_slot_sample_start_{}", i));
        sf(&track.animate_slot_loop_start[i], &format!("animate_slot_loop_start_{}", i));
        sf(&track.animate_slot_loop_end[i], &format!("animate_slot_loop_end_{}", i));
        su(&track.animate_slot_filter_type[i], &format!("animate_slot_filter_type_{}", i));
        sf(&track.animate_slot_filter_cutoff[i], &format!("animate_slot_filter_cutoff_{}", i));
        sf(&track.animate_slot_filter_resonance[i], &format!("animate_slot_filter_resonance_{}", i));
    }

    sf(&track.animate_vector_x, "animate_vector_x");
    sf(&track.animate_vector_y, "animate_vector_y");
    su(&track.animate_lfo_x_waveform, "animate_lfo_x_waveform");
    sb(&track.animate_lfo_x_sync, "animate_lfo_x_sync");
    su(&track.animate_lfo_x_division, "animate_lfo_x_division");
    sf(&track.animate_lfo_x_rate, "animate_lfo_x_rate");
    sf(&track.animate_lfo_x_amount, "animate_lfo_x_amount");
    su(&track.animate_lfo_y_waveform, "animate_lfo_y_waveform");
    sb(&track.animate_lfo_y_sync, "animate_lfo_y_sync");
    su(&track.animate_lfo_y_division, "animate_lfo_y_division");
    sf(&track.animate_lfo_y_rate, "animate_lfo_y_rate");
    sf(&track.animate_lfo_y_amount, "animate_lfo_y_amount");

    su(&track.fmmi_car_wave, "fmmi_car_wave");
    sf(&track.fmmi_car_freq, "fmmi_car_freq");
    sf(&track.fmmi_car_detune, "fmmi_car_detune");
    su(&track.fmmi_mod_wave, "fmmi_mod_wave");
    su(&track.fmmi_mod_mode, "fmmi_mod_mode");
    sf(&track.fmmi_mod_value, "fmmi_mod_value");
    sf(&track.fmmi_mod_detune, "fmmi_mod_detune");
    sf(&track.fmmi_index, "fmmi_index");
    sf(&track.fmmi_feedback, "fmmi_feedback");
    sf(&track.fmmi_drive, "fmmi_drive");
    sf(&track.fmmi_out_level, "fmmi_out_level");
    sf(&track.fmmi_amp_attack, "fmmi_amp_attack");
    sf(&track.fmmi_amp_decay, "fmmi_amp_decay");
    sf(&track.fmmi_amp_sustain, "fmmi_amp_sustain");
        sf(&track.fmmi_amp_release, "fmmi_amp_release");
    sf(&track.fmmi_gate_length, "fmmi_gate_length");
    sf(&track.fmmi_prob, "fmmi_prob");
    sb(&track.fmmi_poly_enabled, "fmmi_poly_enabled");
    su(&track.fmmi_page, "fmmi_page");
    su(&track.fmmi_edit_step, "fmmi_edit_step");
    track.fmmi_rand_note_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_car_wave_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_mod_wave_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_mod_mode_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_car_freq_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_car_detune_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_mod_value_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_mod_detune_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_index_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_feedback_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_drive_enabled.store(true, Ordering::Relaxed);
    track.fmmi_rand_out_level_enabled.store(true, Ordering::Relaxed);
    sb(&track.fmmi_rand_note_enabled, "fmmi_rand_note_enabled");
    sb(
        &track.fmmi_rand_car_wave_enabled,
        "fmmi_rand_car_wave_enabled",
    );
    sb(
        &track.fmmi_rand_mod_wave_enabled,
        "fmmi_rand_mod_wave_enabled",
    );
    sb(
        &track.fmmi_rand_mod_mode_enabled,
        "fmmi_rand_mod_mode_enabled",
    );
    sb(
        &track.fmmi_rand_car_freq_enabled,
        "fmmi_rand_car_freq_enabled",
    );
    sb(
        &track.fmmi_rand_car_detune_enabled,
        "fmmi_rand_car_detune_enabled",
    );
    sb(
        &track.fmmi_rand_mod_value_enabled,
        "fmmi_rand_mod_value_enabled",
    );
    sb(
        &track.fmmi_rand_mod_detune_enabled,
        "fmmi_rand_mod_detune_enabled",
    );
    sb(&track.fmmi_rand_index_enabled, "fmmi_rand_index_enabled");
    sb(
        &track.fmmi_rand_feedback_enabled,
        "fmmi_rand_feedback_enabled",
    );
    sb(&track.fmmi_rand_drive_enabled, "fmmi_rand_drive_enabled");
    sb(
        &track.fmmi_rand_out_level_enabled,
        "fmmi_rand_out_level_enabled",
    );
    sb(
        &track.fmmi_rand_amp_attack_enabled,
        "fmmi_rand_amp_attack_enabled",
    );
    sb(
        &track.fmmi_rand_amp_decay_enabled,
        "fmmi_rand_amp_decay_enabled",
    );
    sb(
        &track.fmmi_rand_amp_sustain_enabled,
        "fmmi_rand_amp_sustain_enabled",
    );
    sb(
        &track.fmmi_rand_amp_release_enabled,
        "fmmi_rand_amp_release_enabled",
    );
    sb(
        &track.fmmi_rand_gate_length_enabled,
        "fmmi_rand_gate_length_enabled",
    );
    sf_clamp_0_1(&track.fmmi_randomize_amount, "fmmi_randomize_amount");
    sf_clamp_0_1(
        &track.fmmi_randomize_steps_amount,
        "fmmi_randomize_steps_amount",
    );
    su(&track.fmmi_scale_index, "fmmi_scale_index");
    for i in 0..FMMI_STEPS {
        track.fmmi_step_car_wave[i].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_wave[i].store(-1, Ordering::Relaxed);
        track.fmmi_step_mod_mode[i].store(-1, Ordering::Relaxed);
        track.fmmi_step_car_freq[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_car_detune[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_mod_detune[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_out_level[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_amp_attack[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_amp_decay[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_amp_sustain[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_amp_release[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        track.fmmi_step_gate_length[i].store((-1.0f32).to_bits(), Ordering::Relaxed);
        if let Some(&v) = params.get(&format!("fmmi_step_note_{}", i)) {
            track.fmmi_step_note[i].store(v as i32, Ordering::Relaxed);
        }
        if let Some(&v) = params.get(&format!("fmmi_step_car_wave_{}", i)) {
            track
                .fmmi_step_car_wave[i]
                .store(v.round() as i32, Ordering::Relaxed);
        }
        if let Some(&v) = params.get(&format!("fmmi_step_mod_wave_{}", i)) {
            track
                .fmmi_step_mod_wave[i]
                .store(v.round() as i32, Ordering::Relaxed);
        }
        if let Some(&v) = params.get(&format!("fmmi_step_mod_mode_{}", i)) {
            track
                .fmmi_step_mod_mode[i]
                .store(v.round() as i32, Ordering::Relaxed);
        }
        sf(
            &track.fmmi_step_car_freq[i],
            &format!("fmmi_step_car_freq_{}", i),
        );
        sf(
            &track.fmmi_step_car_detune[i],
            &format!("fmmi_step_car_detune_{}", i),
        );
        sf(
            &track.fmmi_step_mod_value[i],
            &format!("fmmi_step_mod_value_{}", i),
        );
        sf(
            &track.fmmi_step_mod_detune[i],
            &format!("fmmi_step_mod_detune_{}", i),
        );
        sf(&track.fmmi_step_index[i], &format!("fmmi_step_index_{}", i));
        sf(
            &track.fmmi_step_feedback[i],
            &format!("fmmi_step_feedback_{}", i),
        );
        sf(&track.fmmi_step_drive[i], &format!("fmmi_step_drive_{}", i));
        sf(
            &track.fmmi_step_out_level[i],
            &format!("fmmi_step_out_level_{}", i),
        );
        sf(
            &track.fmmi_step_amp_attack[i],
            &format!("fmmi_step_amp_attack_{}", i),
        );
        sf(
            &track.fmmi_step_amp_decay[i],
            &format!("fmmi_step_amp_decay_{}", i),
        );
        sf(
            &track.fmmi_step_amp_sustain[i],
            &format!("fmmi_step_amp_sustain_{}", i),
        );
        sf(
            &track.fmmi_step_amp_release[i],
            &format!("fmmi_step_amp_release_{}", i),
        );
        sf(
            &track.fmmi_step_gate_length[i],
            &format!("fmmi_step_gate_length_{}", i),
        );
    }
    track.fmmi_current_car_freq.store(
        track.fmmi_car_freq.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.fmmi_current_car_detune.store(
        track.fmmi_car_detune.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.fmmi_current_mod_value.store(
        track.fmmi_mod_value.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.fmmi_current_mod_detune.store(
        track.fmmi_mod_detune.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.fmmi_current_index.store(
        track.fmmi_index.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.fmmi_current_feedback.store(
        track.fmmi_feedback.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.fmmi_current_drive.store(
        track.fmmi_drive.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );
    track.fmmi_current_out_level.store(
        track.fmmi_out_level.load(Ordering::Relaxed),
        Ordering::Relaxed,
    );

    for osc in 0..3 {
        su(&track.monomi_osc_wave[osc], &format!("monomi_osc_wave_{}", osc));
        su(&track.monomi_osc_octave[osc], &format!("monomi_osc_octave_{}", osc));
        sf(&track.monomi_osc_detune[osc], &format!("monomi_osc_detune_{}", osc));
        sf(&track.monomi_osc_mix[osc], &format!("monomi_osc_mix_{}", osc));
        sf(&track.monomi_osc_pwm[osc], &format!("monomi_osc_pwm_{}", osc));
    }
    sf(&track.monomi_cutoff, "monomi_cutoff");
    sf(&track.monomi_resonance, "monomi_resonance");
    sf(&track.monomi_filter_morph, "monomi_filter_morph");
    su(&track.monomi_filter_mode, "monomi_filter_mode");
    sf_clamp_0_1(&track.monomi_volume, "monomi_volume");
    sf(&track.monomi_amp_attack, "monomi_amp_attack");
    sf(&track.monomi_amp_decay, "monomi_amp_decay");
    sf(&track.monomi_amp_sustain, "monomi_amp_sustain");
    sf(&track.monomi_amp_release, "monomi_amp_release");
    sf(&track.monomi_filter_attack, "monomi_filter_attack");
    sf(&track.monomi_filter_decay, "monomi_filter_decay");
    sf(&track.monomi_filter_sustain, "monomi_filter_sustain");
    sf(&track.monomi_filter_release, "monomi_filter_release");
    sf(&track.monomi_filter_intensity, "monomi_filter_intensity");
    sf(&track.monomi_filter_polarity, "monomi_filter_polarity");
    sf(&track.monomi_filter_saturation, "monomi_filter_saturation");
    sf(&track.monomi_filter_sat_env, "monomi_filter_sat_env");
    sb(&track.monomi_filter_sat_pre, "monomi_filter_sat_pre");
    su(&track.monomi_mix_comp_mode, "monomi_mix_comp_mode");
    sf(&track.monomi_glide, "monomi_glide");
    sf(&track.monomi_prob, "monomi_prob");
    su(&track.monomi_scale_index, "monomi_scale_index");
    su(&track.monomi_page, "monomi_page");
    su(&track.monomi_edit_step, "monomi_edit_step");
    for i in 0..3 {
        su(&track.monomi_lfo_shape[i], &format!("monomi_lfo_shape_{}", i));
        su(&track.monomi_lfo_target[i], &format!("monomi_lfo_target_{}", i));
        sf(&track.monomi_lfo_amount[i], &format!("monomi_lfo_amount_{}", i));
        sf(&track.monomi_lfo_rate[i], &format!("monomi_lfo_rate_{}", i));
        sb(&track.monomi_lfo_sync[i], &format!("monomi_lfo_sync_{}", i));
        su(&track.monomi_lfo_steps[i], &format!("monomi_lfo_steps_{}", i));
    }
    sb(&track.monomi_rand_cutoff, "monomi_rand_cutoff");
    sb(&track.monomi_rand_resonance, "monomi_rand_resonance");
    sb(&track.monomi_rand_env_attack, "monomi_rand_env_attack");
    sb(&track.monomi_rand_env_decay, "monomi_rand_env_decay");
    sb(&track.monomi_rand_env_sustain, "monomi_rand_env_sustain");
    sb(&track.monomi_rand_env_release, "monomi_rand_env_release");
    sb(&track.monomi_rand_gate, "monomi_rand_gate");
    sb(&track.monomi_rand_filter_morph, "monomi_rand_filter_morph");
    sb(&track.monomi_rand_glide, "monomi_rand_glide");
    sb(&track.monomi_rand_osc_mix[0], "monomi_rand_osc1_mix");
    sb(&track.monomi_rand_osc_mix[1], "monomi_rand_osc2_mix");
    sb(&track.monomi_rand_osc_mix[2], "monomi_rand_osc3_mix");
    sb(&track.monomi_rand_osc_detune[0], "monomi_rand_osc1_detune");
    sb(&track.monomi_rand_osc_detune[1], "monomi_rand_osc2_detune");
    sb(&track.monomi_rand_osc_detune[2], "monomi_rand_osc3_detune");
    sb(&track.monomi_rand_osc_pwm[0], "monomi_rand_osc1_pwm");
    sb(&track.monomi_rand_osc_pwm[1], "monomi_rand_osc2_pwm");
    sb(&track.monomi_rand_osc_pwm[2], "monomi_rand_osc3_pwm");
    sf_clamp_0_1(&track.monomi_randomize_amount, "monomi_randomize_amount");
    for i in 0..MONOMI_STEPS {
        si(&track.monomi_step_note[i], &format!("monomi_step_note_{}", i));
        sf(&track.monomi_step_cutoff[i], &format!("monomi_step_cutoff_{}", i));
        sf(
            &track.monomi_step_resonance[i],
            &format!("monomi_step_resonance_{}", i),
        );
        sf(
            &track.monomi_step_env_attack[i],
            &format!("monomi_step_env_attack_{}", i),
        );
        sf(
            &track.monomi_step_env_decay[i],
            &format!("monomi_step_env_decay_{}", i),
        );
        sf(
            &track.monomi_step_env_sustain[i],
            &format!("monomi_step_env_sustain_{}", i),
        );
        sf(
            &track.monomi_step_env_release[i],
            &format!("monomi_step_env_release_{}", i),
        );
        sf(&track.monomi_step_gate[i], &format!("monomi_step_gate_{}", i));
        sf(
            &track.monomi_step_filter_morph[i],
            &format!("monomi_step_filter_morph_{}", i),
        );
        sf(&track.monomi_step_glide[i], &format!("monomi_step_glide_{}", i));
        for osc in 0..3 {
            sf(
                &track.monomi_step_osc_mix[osc][i],
                &format!("monomi_step_osc{}_mix_{}", osc + 1, i),
            );
            sf(
                &track.monomi_step_osc_detune[osc][i],
                &format!("monomi_step_osc{}_detune_{}", osc + 1, i),
            );
            sf(
                &track.monomi_step_osc_pwm[osc][i],
                &format!("monomi_step_osc{}_pwm_{}", osc + 1, i),
            );
        }
    }

    sf(&track.kick_pitch, "kick_pitch");
    sf(&track.kick_decay, "kick_decay");
    sf(&track.kick_attack, "kick_attack");
    sf(&track.kick_pitch_env_amount, "kick_pitch_env_amount");
    sf(&track.kick_drive, "kick_drive");
    sf(&track.kick_level, "kick_level");
    su(&track.kick_filter_type, "kick_filter_type");
    sf(&track.kick_filter_cutoff, "kick_filter_cutoff");
    sf(&track.kick_filter_resonance, "kick_filter_resonance");
    sb(&track.kick_filter_pre_drive, "kick_filter_pre_drive");
    su_clamp_0_14(&track.kick_cut_group, "kick_cut_group");
    su_clamp_0_14(&track.kick_cut_by, "kick_cut_by");
    sf_clamp_0_1(&track.kick_prob, "kick_prob");
    sb(&track.kick_lane_enabled, "kick_lane_enabled");
    sf(&track.snare_tone, "snare_tone");
    sf(&track.snare_decay, "snare_decay");
    sf(&track.snare_snappy, "snare_snappy");
    sf(&track.snare_attack, "snare_attack");
    sf(&track.snare_drive, "snare_drive");
    sf(&track.snare_level, "snare_level");
    su(&track.snare_filter_type, "snare_filter_type");
    sf(&track.snare_filter_cutoff, "snare_filter_cutoff");
    sf(&track.snare_filter_resonance, "snare_filter_resonance");
    sb(&track.snare_filter_pre_drive, "snare_filter_pre_drive");
    su_clamp_0_14(&track.snare_cut_group, "snare_cut_group");
    su_clamp_0_14(&track.snare_cut_by, "snare_cut_by");
    sf_clamp_0_1(&track.snare_prob, "snare_prob");
    sb(&track.snare_lane_enabled, "snare_lane_enabled");
    sf(&track.clap_pitch, "clap_pitch");
    sf(&track.clap_decay, "clap_decay");
    sf(&track.clap_tone, "clap_tone");
    sf(&track.clap_drive, "clap_drive");
    sf(&track.clap_level, "clap_level");
    su(&track.clap_filter_type, "clap_filter_type");
    sf(&track.clap_filter_cutoff, "clap_filter_cutoff");
    sf(&track.clap_filter_resonance, "clap_filter_resonance");
    sb(&track.clap_filter_pre_drive, "clap_filter_pre_drive");
    su_clamp_0_14(&track.clap_cut_group, "clap_cut_group");
    su_clamp_0_14(&track.clap_cut_by, "clap_cut_by");
    sf_clamp_0_1(&track.clap_prob, "clap_prob");
    sb(&track.clap_lane_enabled, "clap_lane_enabled");
    sf(&track.hat_pitch, "hat_pitch");
    sf(&track.hat_decay, "hat_decay");
    sf(&track.hat_tone, "hat_tone");
    sf(&track.hat_drive, "hat_drive");
    sf(&track.hat_level, "hat_level");
    su(&track.hat_filter_type, "hat_filter_type");
    sf(&track.hat_filter_cutoff, "hat_filter_cutoff");
    sf(&track.hat_filter_resonance, "hat_filter_resonance");
    sb(&track.hat_filter_pre_drive, "hat_filter_pre_drive");
    su_clamp_0_14(&track.hat_cut_group, "hat_cut_group");
    su_clamp_0_14(&track.hat_cut_by, "hat_cut_by");
    sf_clamp_0_1(&track.hat_prob, "hat_prob");
    sb(&track.hat_lane_enabled, "hat_lane_enabled");
    sf(&track.perc1_pitch, "perc1_pitch");
    sf(&track.perc1_decay, "perc1_decay");
    sf(&track.perc1_tone, "perc1_tone");
    sf(&track.perc1_drive, "perc1_drive");
    sf(&track.perc1_level, "perc1_level");
    su(&track.perc1_filter_type, "perc1_filter_type");
    sf(&track.perc1_filter_cutoff, "perc1_filter_cutoff");
    sf(&track.perc1_filter_resonance, "perc1_filter_resonance");
    sb(&track.perc1_filter_pre_drive, "perc1_filter_pre_drive");
    su_clamp_0_14(&track.perc1_cut_group, "perc1_cut_group");
    su_clamp_0_14(&track.perc1_cut_by, "perc1_cut_by");
    sf_clamp_0_1(&track.perc1_prob, "perc1_prob");
    sb(&track.perc1_lane_enabled, "perc1_lane_enabled");
    sf(&track.perc2_pitch, "perc2_pitch");
    sf(&track.perc2_decay, "perc2_decay");
    sf(&track.perc2_tone, "perc2_tone");
    sf(&track.perc2_drive, "perc2_drive");
    sf(&track.perc2_level, "perc2_level");
    su(&track.perc2_filter_type, "perc2_filter_type");
    sf(&track.perc2_filter_cutoff, "perc2_filter_cutoff");
    sf(&track.perc2_filter_resonance, "perc2_filter_resonance");
    sb(&track.perc2_filter_pre_drive, "perc2_filter_pre_drive");
    su_clamp_0_14(&track.perc2_cut_group, "perc2_cut_group");
    su_clamp_0_14(&track.perc2_cut_by, "perc2_cut_by");
    sf_clamp_0_1(&track.perc2_prob, "perc2_prob");
    sb(&track.perc2_lane_enabled, "perc2_lane_enabled");
    sf(&track.crash_pitch, "crash_pitch");
    sf(&track.crash_decay, "crash_decay");
    sf(&track.crash_tone, "crash_tone");
    sf(&track.crash_drive, "crash_drive");
    sf(&track.crash_level, "crash_level");
    su(&track.crash_filter_type, "crash_filter_type");
    sf(&track.crash_filter_cutoff, "crash_filter_cutoff");
    sf(&track.crash_filter_resonance, "crash_filter_resonance");
    sb(&track.crash_filter_pre_drive, "crash_filter_pre_drive");
    su_clamp_0_14(&track.crash_cut_group, "crash_cut_group");
    su_clamp_0_14(&track.crash_cut_by, "crash_cut_by");
    sf_clamp_0_1(&track.crash_prob, "crash_prob");
    sb(&track.crash_lane_enabled, "crash_lane_enabled");
    for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
        su_clamp_0_14(
            &track.samp_cut_group[samp_idx],
            &format!("samp_cut_group_{}", samp_idx),
        );
        su_clamp_0_14(
            &track.samp_cut_by[samp_idx],
            &format!("samp_cut_by_{}", samp_idx),
        );
        sf_clamp_0_1(
            &track.samp_prob[samp_idx],
            &format!("samp_prob_{}", samp_idx),
        );
        sb(
            &track.samp_lane_enabled[samp_idx],
            &format!("samp_lane_enabled_{}", samp_idx),
        );
    }
    su(&track.syndrm_page, "syndrm_page");
    su(&track.syndrm_edit_lane, "syndrm_edit_lane");
    su(&track.syndrm_edit_step, "syndrm_edit_step");
    sb(&track.syndrm_step_hold, "syndrm_step_hold");
    sf_clamp_0_1(&track.syndrm_randomize_amount, "syndrm_randomize_amount");
    for i in 0..SYNDRM_STEPS {
        sb(&track.kick_step_override_enabled[i], &format!("syndrm_kick_step_override_{}", i));
        sf(&track.kick_step_pitch[i], &format!("syndrm_kick_step_pitch_{}", i));
        sf(&track.kick_step_decay[i], &format!("syndrm_kick_step_decay_{}", i));
        sf(&track.kick_step_attack[i], &format!("syndrm_kick_step_attack_{}", i));
        sf(&track.kick_step_drive[i], &format!("syndrm_kick_step_drive_{}", i));
        sf(&track.kick_step_level[i], &format!("syndrm_kick_step_level_{}", i));
        su(&track.kick_step_filter_type[i], &format!("syndrm_kick_step_filter_type_{}", i));
        sf(
            &track.kick_step_filter_cutoff[i],
            &format!("syndrm_kick_step_filter_cutoff_{}", i),
        );
        sf(
            &track.kick_step_filter_resonance[i],
            &format!("syndrm_kick_step_filter_resonance_{}", i),
        );
        sb(
            &track.kick_step_retrig_enabled[i],
            &format!("syndrm_kick_step_retrig_enabled_{}", i),
        );
        su(
            &track.kick_step_retrig_division[i],
            &format!("syndrm_kick_step_retrig_division_{}", i),
        );
        sb(&track.snare_step_override_enabled[i], &format!("syndrm_snare_step_override_{}", i));
        sf(&track.snare_step_tone[i], &format!("syndrm_snare_step_tone_{}", i));
        sf(&track.snare_step_decay[i], &format!("syndrm_snare_step_decay_{}", i));
        sf(
            &track.snare_step_snappy[i],
            &format!("syndrm_snare_step_snappy_{}", i),
        );
        sf(&track.snare_step_attack[i], &format!("syndrm_snare_step_attack_{}", i));
        sf(&track.snare_step_drive[i], &format!("syndrm_snare_step_drive_{}", i));
        sf(&track.snare_step_level[i], &format!("syndrm_snare_step_level_{}", i));
        su(
            &track.snare_step_filter_type[i],
            &format!("syndrm_snare_step_filter_type_{}", i),
        );
        sf(
            &track.snare_step_filter_cutoff[i],
            &format!("syndrm_snare_step_filter_cutoff_{}", i),
        );
        sf(
            &track.snare_step_filter_resonance[i],
            &format!("syndrm_snare_step_filter_resonance_{}", i),
        );
        sb(
            &track.snare_step_retrig_enabled[i],
            &format!("syndrm_snare_step_retrig_enabled_{}", i),
        );
        su(
            &track.snare_step_retrig_division[i],
            &format!("syndrm_snare_step_retrig_division_{}", i),
        );
        sb(&track.clap_step_override_enabled[i], &format!("syndrm_clap_step_override_{}", i));
        sf(&track.clap_step_pitch[i], &format!("syndrm_clap_step_pitch_{}", i));
        sf(&track.clap_step_decay[i], &format!("syndrm_clap_step_decay_{}", i));
        sf(&track.clap_step_tone[i], &format!("syndrm_clap_step_tone_{}", i));
        sf(&track.clap_step_drive[i], &format!("syndrm_clap_step_drive_{}", i));
        sf(&track.clap_step_level[i], &format!("syndrm_clap_step_level_{}", i));
        su(
            &track.clap_step_filter_type[i],
            &format!("syndrm_clap_step_filter_type_{}", i),
        );
        sf(
            &track.clap_step_filter_cutoff[i],
            &format!("syndrm_clap_step_filter_cutoff_{}", i),
        );
        sf(
            &track.clap_step_filter_resonance[i],
            &format!("syndrm_clap_step_filter_resonance_{}", i),
        );
        sb(
            &track.clap_step_retrig_enabled[i],
            &format!("syndrm_clap_step_retrig_enabled_{}", i),
        );
        su(
            &track.clap_step_retrig_division[i],
            &format!("syndrm_clap_step_retrig_division_{}", i),
        );
        sb(&track.hat_step_override_enabled[i], &format!("syndrm_hat_step_override_{}", i));
        sf(&track.hat_step_pitch[i], &format!("syndrm_hat_step_pitch_{}", i));
        sf(&track.hat_step_decay[i], &format!("syndrm_hat_step_decay_{}", i));
        sf(&track.hat_step_tone[i], &format!("syndrm_hat_step_tone_{}", i));
        sf(&track.hat_step_drive[i], &format!("syndrm_hat_step_drive_{}", i));
        sf(&track.hat_step_level[i], &format!("syndrm_hat_step_level_{}", i));
        su(
            &track.hat_step_filter_type[i],
            &format!("syndrm_hat_step_filter_type_{}", i),
        );
        sf(
            &track.hat_step_filter_cutoff[i],
            &format!("syndrm_hat_step_filter_cutoff_{}", i),
        );
        sf(
            &track.hat_step_filter_resonance[i],
            &format!("syndrm_hat_step_filter_resonance_{}", i),
        );
        sb(
            &track.hat_step_retrig_enabled[i],
            &format!("syndrm_hat_step_retrig_enabled_{}", i),
        );
        su(
            &track.hat_step_retrig_division[i],
            &format!("syndrm_hat_step_retrig_division_{}", i),
        );
        sb(
            &track.perc1_step_override_enabled[i],
            &format!("syndrm_perc1_step_override_{}", i),
        );
        sf(
            &track.perc1_step_pitch[i],
            &format!("syndrm_perc1_step_pitch_{}", i),
        );
        sf(
            &track.perc1_step_decay[i],
            &format!("syndrm_perc1_step_decay_{}", i),
        );
        sf(
            &track.perc1_step_tone[i],
            &format!("syndrm_perc1_step_tone_{}", i),
        );
        sf(
            &track.perc1_step_drive[i],
            &format!("syndrm_perc1_step_drive_{}", i),
        );
        sf(
            &track.perc1_step_level[i],
            &format!("syndrm_perc1_step_level_{}", i),
        );
        su(
            &track.perc1_step_filter_type[i],
            &format!("syndrm_perc1_step_filter_type_{}", i),
        );
        sf(
            &track.perc1_step_filter_cutoff[i],
            &format!("syndrm_perc1_step_filter_cutoff_{}", i),
        );
        sf(
            &track.perc1_step_filter_resonance[i],
            &format!("syndrm_perc1_step_filter_resonance_{}", i),
        );
        sb(
            &track.perc1_step_retrig_enabled[i],
            &format!("syndrm_perc1_step_retrig_enabled_{}", i),
        );
        su(
            &track.perc1_step_retrig_division[i],
            &format!("syndrm_perc1_step_retrig_division_{}", i),
        );
        sb(
            &track.perc2_step_override_enabled[i],
            &format!("syndrm_perc2_step_override_{}", i),
        );
        sf(
            &track.perc2_step_pitch[i],
            &format!("syndrm_perc2_step_pitch_{}", i),
        );
        sf(
            &track.perc2_step_decay[i],
            &format!("syndrm_perc2_step_decay_{}", i),
        );
        sf(
            &track.perc2_step_tone[i],
            &format!("syndrm_perc2_step_tone_{}", i),
        );
        sf(
            &track.perc2_step_drive[i],
            &format!("syndrm_perc2_step_drive_{}", i),
        );
        sf(
            &track.perc2_step_level[i],
            &format!("syndrm_perc2_step_level_{}", i),
        );
        su(
            &track.perc2_step_filter_type[i],
            &format!("syndrm_perc2_step_filter_type_{}", i),
        );
        sf(
            &track.perc2_step_filter_cutoff[i],
            &format!("syndrm_perc2_step_filter_cutoff_{}", i),
        );
        sf(
            &track.perc2_step_filter_resonance[i],
            &format!("syndrm_perc2_step_filter_resonance_{}", i),
        );
        sb(
            &track.perc2_step_retrig_enabled[i],
            &format!("syndrm_perc2_step_retrig_enabled_{}", i),
        );
        su(
            &track.perc2_step_retrig_division[i],
            &format!("syndrm_perc2_step_retrig_division_{}", i),
        );
        sb(
            &track.crash_step_override_enabled[i],
            &format!("syndrm_crash_step_override_{}", i),
        );
        sf(
            &track.crash_step_pitch[i],
            &format!("syndrm_crash_step_pitch_{}", i),
        );
        sf(
            &track.crash_step_decay[i],
            &format!("syndrm_crash_step_decay_{}", i),
        );
        sf(
            &track.crash_step_tone[i],
            &format!("syndrm_crash_step_tone_{}", i),
        );
        sf(
            &track.crash_step_drive[i],
            &format!("syndrm_crash_step_drive_{}", i),
        );
        sf(
            &track.crash_step_level[i],
            &format!("syndrm_crash_step_level_{}", i),
        );
        su(
            &track.crash_step_filter_type[i],
            &format!("syndrm_crash_step_filter_type_{}", i),
        );
        sf(
            &track.crash_step_filter_cutoff[i],
            &format!("syndrm_crash_step_filter_cutoff_{}", i),
        );
        sf(
            &track.crash_step_filter_resonance[i],
            &format!("syndrm_crash_step_filter_resonance_{}", i),
        );
        sb(
            &track.crash_step_retrig_enabled[i],
            &format!("syndrm_crash_step_retrig_enabled_{}", i),
        );
        su(
            &track.crash_step_retrig_division[i],
            &format!("syndrm_crash_step_retrig_division_{}", i),
        );
    }

    sf(&track.void_base_freq, "void_base_freq");
    sf(&track.void_chaos_depth, "void_chaos_depth");
    sf(&track.void_entropy, "void_entropy");
    sf(&track.void_feedback, "void_feedback");
    sf(&track.void_diffusion, "void_diffusion");
    sf(&track.void_mod_rate, "void_mod_rate");
    sf(&track.void_level, "void_level");
    sf(&track.void_pan, "void_pan");
    sf(&track.void_width, "void_width");
    sf(&track.void_close_decay, "void_close_decay");
    sf(&track.void_filter_cutoff, "void_filter_cutoff");
    sf(&track.void_filter_resonance, "void_filter_resonance");
    sf(&track.void_drive, "void_drive");
    sb(&track.void_filter_pre_drive, "void_filter_pre_drive");
    sb(&track.void_enabled, "void_enabled");

    // Smoothing state should derive from targets on load, not persisted.
    track
        .void_filter_cutoff_smooth
        .store(track.void_filter_cutoff.load(Ordering::Relaxed), Ordering::Relaxed);
    track
        .void_filter_resonance_smooth
        .store(track.void_filter_resonance.load(Ordering::Relaxed), Ordering::Relaxed);
    track
        .void_drive_smooth
        .store(track.void_drive.load(Ordering::Relaxed), Ordering::Relaxed);
}

struct VoidSeedDspState {
    sample_rate: f32,
    filter_moog: [Box<dyn AudioUnit>; 2],
    drive: Box<dyn AudioUnit>,
}

impl VoidSeedDspState {
    fn new() -> Self {
        Self {
            sample_rate: 0.0,
            filter_moog: [Box::new(moog()), Box::new(moog())],
            drive: Box::new(shape(Tanh(1.0))),
        }
    }

    fn set_sample_rate(&mut self, sr: f32) {
        if (self.sample_rate - sr).abs() < f32::EPSILON {
            return;
        }
        self.sample_rate = sr;
        let sr = sr as f64;
        self.filter_moog[0].set_sample_rate(sr);
        self.filter_moog[1].set_sample_rate(sr);
        self.drive.set_sample_rate(sr);
    }
}

fn save_project(
    tracks: &Arc<[Track; NUM_TRACKS]>,
    global_tempo: f32,
    params: &Arc<TLBX1Params>,
    title: &str,
    description: &str,
    project_dir: &PathBuf,
) -> Result<(), Box<dyn std::error::Error>> {
    fs::create_dir_all(project_dir)?;
    let samples_dir = project_dir.join("samples");
    fs::create_dir_all(&samples_dir)?;

    let mut track_file_names = Vec::new();

    for (i, track) in tracks.iter().enumerate() {
        let track_idx = i + 1;
        let mut track_data = TrackData {
            engine_type: track.engine_type.load(Ordering::Relaxed),
            params: HashMap::new(),
            sequence: Vec::new(),
            sample_path: None,
        };

        capture_track_params(track, &mut track_data.params);

        if track_data.engine_type == 2 {
            let grid = track.animate_sequencer_grid.clone();
            for j in 0..160 {
                track_data.sequence.push(grid[j].load(Ordering::Relaxed));
            }
        } else if track_data.engine_type == 3 {
            let grid = track.kick_sequencer_grid.clone();
            for j in 0..SYNDRM_STEPS {
                track_data.sequence.push(grid[j].load(Ordering::Relaxed));
            }
            let snare_grid = track.snare_sequencer_grid.clone();
            for j in 0..SYNDRM_STEPS {
                track_data.sequence.push(snare_grid[j].load(Ordering::Relaxed));
            }
        } else if track_data.engine_type == 5 {
            let grid = track.fmmi_sequencer_grid.clone();
            for j in 0..FMMI_STEPS {
                track_data.sequence.push(grid[j].load(Ordering::Relaxed));
            }
        } else if track_data.engine_type == 6 {
            let grid = track.monomi_sequencer_grid.clone();
            for j in 0..MONOMI_STEPS {
                track_data.sequence.push(grid[j].load(Ordering::Relaxed));
            }
        }

        if let Some(path) = track.sample_path.lock().as_ref() {
            if let Some(file_name) = path.file_name() {
                let dest_path = samples_dir.join(file_name);
                if path.exists() {
                    fs::copy(path, &dest_path)?;
                    track_data.sample_path = Some(format!("samples/{}", file_name.to_string_lossy()));
                }
            }
        }

        let track_file_name = format!("{}.trk", track_idx);
        let track_path = project_dir.join(&track_file_name);
        let track_json = serde_json::to_string_pretty(&track_data)?;
        fs::write(track_path, track_json)?;
        track_file_names.push(track_file_name);
    }

    let project_data = ProjectData {
        title: title.to_string(),
        description: description.to_string(),
        bpm: global_tempo,
        master_gain: params.gain.value(),
        master_filter: params.master_filter.value(),
        master_comp: params.master_comp.value(),
        tracks: track_file_names,
    };

    let project_file_name = format!("{}.tlbx", title);
    let project_path = project_dir.join(project_file_name);
    let project_json = serde_json::to_string_pretty(&project_data)?;
    fs::write(project_path, project_json)?;

    Ok(())
}

fn load_project(
    tracks: &Arc<[Track; NUM_TRACKS]>,
    global_tempo: &Arc<AtomicU32>,
    _params: &Arc<TLBX1Params>,
    pending_project_params: &Arc<Mutex<Option<PendingProjectParams>>>,
    path: &PathBuf,
) -> Result<(), Box<dyn std::error::Error>> {
    let project_dir = path.parent().ok_or("Invalid project path")?;
    let json = fs::read_to_string(path)?;
    let project: ProjectData = serde_json::from_str(&json)?;

    global_tempo.store(project.bpm.to_bits(), Ordering::Relaxed);
    *pending_project_params.lock() = Some(PendingProjectParams {
        gain: project.master_gain,
        master_filter: project.master_filter,
        master_comp: project.master_comp,
    });

    for (track_idx, track_file_name) in project.tracks.iter().enumerate() {
        if track_idx >= NUM_TRACKS {
            break;
        }
        let track = &tracks[track_idx];
        let track_path = project_dir.join(track_file_name);
        if !track_path.exists() {
            continue;
        }
        let track_json = fs::read_to_string(track_path)?;
        let track_data: TrackData = serde_json::from_str(&track_json)?;

        track.engine_type.store(track_data.engine_type, Ordering::Relaxed);
        apply_track_params(track, &track_data.params);

        if track_data.engine_type == 2 && track_data.sequence.len() == 160 {
            let grid = track.animate_sequencer_grid.clone();
            for j in 0..160 {
                grid[j].store(track_data.sequence[j], Ordering::Relaxed);
            }
        } else if track_data.engine_type == 3 && track_data.sequence.len() == SYNDRM_STEPS * 2 {
            let grid = track.kick_sequencer_grid.clone();
            for j in 0..SYNDRM_STEPS {
                grid[j].store(track_data.sequence[j], Ordering::Relaxed);
            }
            let snare_grid = track.snare_sequencer_grid.clone();
            for j in 0..SYNDRM_STEPS {
                snare_grid[j].store(track_data.sequence[j + SYNDRM_STEPS], Ordering::Relaxed);
            }
        } else if track_data.engine_type == 3 && track_data.sequence.len() == 32 {
            let grid = track.kick_sequencer_grid.clone();
            for j in 0..16 {
                grid[j].store(track_data.sequence[j], Ordering::Relaxed);
            }
            let snare_grid = track.snare_sequencer_grid.clone();
            for j in 0..16 {
                snare_grid[j].store(track_data.sequence[j + 16], Ordering::Relaxed);
            }
        } else if track_data.engine_type == 3 && track_data.sequence.len() == 16 {
            let grid = track.kick_sequencer_grid.clone();
            for j in 0..16 {
                grid[j].store(track_data.sequence[j], Ordering::Relaxed);
            }
        } else if track_data.engine_type == 5 && track_data.sequence.len() == FMMI_STEPS {
            let grid = track.fmmi_sequencer_grid.clone();
            for j in 0..FMMI_STEPS {
                grid[j].store(track_data.sequence[j], Ordering::Relaxed);
            }
        } else if track_data.engine_type == 6 && track_data.sequence.len() == MONOMI_STEPS {
            let grid = track.monomi_sequencer_grid.clone();
            for j in 0..MONOMI_STEPS {
                grid[j].store(track_data.sequence[j], Ordering::Relaxed);
            }
        }

        track.is_playing.store(false, Ordering::Relaxed);
        track.is_recording.store(false, Ordering::Relaxed);
        track.play_pos.store(0.0f32.to_bits(), Ordering::Relaxed);

        let mut samples = track.samples.lock();
        let mut summary = track.waveform_summary.lock();
        let mut sample_path = track.sample_path.lock();
        
        if let Some(rel_path) = &track_data.sample_path {
            let abs_path = project_dir.join(rel_path);
            match load_audio_file(&abs_path) {
                Ok((new_samples, sample_rate)) => {
                    *samples = new_samples;
                    *sample_path = Some(abs_path);
                    track.sample_rate.store(sample_rate, Ordering::Relaxed);
                    if !samples.is_empty() {
                        calculate_waveform_summary(&samples[0], &mut summary);
                    }
                }
                Err(err) => {
                    nih_log!("Failed to load sample for track {}: {:?}", track_idx, err);
                    *samples = vec![vec![]; 2];
                    *summary = vec![0.0; WAVEFORM_SUMMARY_SIZE];
                    *sample_path = None;
                    track.sample_rate.store(44_100, Ordering::Relaxed);
                }
            }
        } else {
            *samples = vec![vec![]; 2];
            *summary = vec![0.0; WAVEFORM_SUMMARY_SIZE];
            *sample_path = None;
            track.sample_rate.store(44_100, Ordering::Relaxed);
        }
    }
    Ok(())
}

fn export_project_as_zip(
    tracks: &Arc<[Track; NUM_TRACKS]>,
    global_tempo: f32,
    params: &Arc<TLBX1Params>,
    title: &str,
    description: &str,
    zip_path: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    let file = fs::File::create(zip_path)?;
    let mut zip = zip::ZipWriter::new(file);
    let options = zip::write::SimpleFileOptions::default()
        .compression_method(zip::CompressionMethod::Deflated)
        .unix_permissions(0o755);

    let mut track_file_names = Vec::new();
    for i in 1..=NUM_TRACKS {
        track_file_names.push(format!("{}.trk", i));
    }

    let project_data = ProjectData {
        title: title.to_string(),
        description: description.to_string(),
        bpm: global_tempo,
        master_gain: params.gain.value(),
        master_filter: params.master_filter.value(),
        master_comp: params.master_comp.value(),
        tracks: track_file_names,
    };

    let project_json = serde_json::to_string_pretty(&project_data)?;
    zip.start_file(format!("{}.tlbx", title), options)?;
    zip.write_all(project_json.as_bytes())?;

    for (i, track) in tracks.iter().enumerate() {
        let mut track_data = TrackData {
            engine_type: track.engine_type.load(Ordering::Relaxed),
            params: HashMap::new(),
            sequence: Vec::new(),
            sample_path: None,
        };

        capture_track_params(track, &mut track_data.params);

        if track_data.engine_type == 2 {
            let grid = track.animate_sequencer_grid.clone();
            for j in 0..160 {
                track_data.sequence.push(grid[j].load(Ordering::Relaxed));
            }
        } else if track_data.engine_type == 3 {
            let grid = track.kick_sequencer_grid.clone();
            for j in 0..SYNDRM_STEPS {
                track_data.sequence.push(grid[j].load(Ordering::Relaxed));
            }
            let snare_grid = track.snare_sequencer_grid.clone();
            for j in 0..SYNDRM_STEPS {
                track_data.sequence.push(snare_grid[j].load(Ordering::Relaxed));
            }
        } else if track_data.engine_type == 5 {
            let grid = track.fmmi_sequencer_grid.clone();
            for j in 0..FMMI_STEPS {
                track_data.sequence.push(grid[j].load(Ordering::Relaxed));
            }
        } else if track_data.engine_type == 6 {
            let grid = track.monomi_sequencer_grid.clone();
            for j in 0..MONOMI_STEPS {
                track_data.sequence.push(grid[j].load(Ordering::Relaxed));
            }
        }

        if let Some(path) = track.sample_path.lock().as_ref() {
            if let Some(file_name) = path.file_name() {
                let rel_sample_path = format!("samples/{}", file_name.to_string_lossy());
                track_data.sample_path = Some(rel_sample_path.clone());

                if path.exists() {
                    zip.start_file(rel_sample_path, options)?;
                    let sample_bytes = fs::read(path)?;
                    zip.write_all(&sample_bytes)?;
                }
            }
        }

        let track_json = serde_json::to_string_pretty(&track_data)?;
        zip.start_file(format!("{}.trk", i + 1), options)?;
        zip.write_all(track_json.as_bytes())?;
    }

    zip.finish()?;
    Ok(())
}

fn refresh_browser_impl(
    ui: &TLBX1UI,
    current_path: &Path,
    current_folder_content_model: &VecModel<BrowserEntry>,
) {
    let mut entries = Vec::new();

    if let Some(parent) = current_path.parent() {
        if current_path != Path::new(".") && current_path.as_os_str() != "" {
            entries.push(BrowserEntry {
                name: "..".into(),
                is_dir: true,
                path: parent.to_string_lossy().to_string().into(),
            });
        }
    }

    if let Ok(dir_entries) = std::fs::read_dir(current_path) {
        let mut folders = Vec::new();
        let mut files = Vec::new();

        for entry in dir_entries.flatten() {
            let entry_path = entry.path();
            let name = entry.file_name().to_string_lossy().to_string().into();
            let is_dir = entry_path.is_dir();

            if is_dir {
                folders.push(BrowserEntry {
                    name,
                    is_dir,
                    path: entry_path.to_string_lossy().to_string().into(),
                });
            } else {
                let ext = entry_path.extension().and_then(|e| e.to_str()).unwrap_or("");
                if matches!(ext, "tlbx" | "wav" | "mp3" | "json" | "trk") {
                    files.push(BrowserEntry {
                        name,
                        is_dir,
                        path: entry_path.to_string_lossy().to_string().into(),
                    });
                }
            }
        }

        folders.sort_by(|a, b| a.name.to_lowercase().cmp(&b.name.to_lowercase()));
        files.sort_by(|a, b| a.name.to_lowercase().cmp(&b.name.to_lowercase()));

        entries.extend(folders);
        entries.extend(files);
    }

    current_folder_content_model.set_vec(entries);
    ui.set_current_path(current_path.to_string_lossy().to_string().into());
}

struct SlintEditor {
    params: Arc<TLBX1Params>,
    tracks: Arc<[Track; NUM_TRACKS]>,
    master_meters: Arc<MasterMeters>,
    visualizer: Arc<VisualizerState>,
    global_tempo: Arc<AtomicU32>,
    follow_host_tempo: Arc<AtomicBool>,
    metronome_enabled: Arc<AtomicBool>,
    metronome_count_in_ticks: Arc<AtomicU32>,
    metronome_count_in_playback: Arc<AtomicBool>,
    metronome_count_in_record: Arc<AtomicBool>,
    async_executor: AsyncExecutor<TLBX1>,
    pending_project_params: Arc<Mutex<Option<PendingProjectParams>>>,
    animate_library: Arc<AnimateLibrary>,
}

impl Editor for SlintEditor {
    fn spawn(
        &self,
        parent: ParentWindowHandle,
        context: Arc<dyn GuiContext>,
    ) -> Box<dyn std::any::Any + Send> {
        let params = self.params.clone();
        let tracks = self.tracks.clone();
        let master_meters = self.master_meters.clone();
        let visualizer = self.visualizer.clone();
        let global_tempo = self.global_tempo.clone();
        let follow_host_tempo = self.follow_host_tempo.clone();
        let metronome_enabled = self.metronome_enabled.clone();
        let metronome_count_in_ticks = self.metronome_count_in_ticks.clone();
        let metronome_count_in_playback = self.metronome_count_in_playback.clone();
        let metronome_count_in_record = self.metronome_count_in_record.clone();
        let async_executor = self.async_executor.clone();
        let pending_project_params = self.pending_project_params.clone();
        let animate_library = self.animate_library.clone();

        let initial_size = default_window_size();
        let window_handle = baseview::Window::open_parented(
            &ParentWindowHandleAdapter(parent),
            WindowOpenOptions {
                title: "TLBX-1".to_string(),
                size: initial_size,
                scale: WindowScalePolicy::SystemScaleFactor,
                gl_config: None,
            },
            move |window| {
                SlintWindow::new(
                    window,
                    initial_size,
                    context,
                    params,
                    tracks,
                    master_meters,
                    visualizer,
                    global_tempo,
                    follow_host_tempo,
                    metronome_enabled,
                    metronome_count_in_ticks,
                    metronome_count_in_playback,
                    metronome_count_in_record,
                    async_executor,
                    pending_project_params,
                    animate_library,
                )
            },
        );

        Box::new(SlintEditorHandle { window: window_handle })
    }

    fn size(&self) -> (u32, u32) {
        let size = default_window_size();
        (size.width as u32, size.height as u32)
    }

    fn set_scale_factor(&self, _factor: f32) -> bool {
        false
    }

    fn param_values_changed(&self) {}

    fn param_value_changed(&self, _id: &str, _normalized_value: f32) {}

    fn param_modulation_changed(&self, _id: &str, _modulation_offset: f32) {}
}

struct SlintEditorHandle {
    window: WindowHandle,
}

unsafe impl Send for SlintEditorHandle {}

impl Drop for SlintEditorHandle {
    fn drop(&mut self) {
        self.window.close();
    }
}

struct SlintWindow {
    gui_context: Arc<dyn GuiContext>,
    params: Arc<TLBX1Params>,
    tracks: Arc<[Track; NUM_TRACKS]>,
    master_meters: Arc<MasterMeters>,
    visualizer: Arc<VisualizerState>,
    global_tempo: Arc<AtomicU32>,
    _follow_host_tempo: Arc<AtomicBool>,
    metronome_enabled: Arc<AtomicBool>,
    metronome_count_in_ticks: Arc<AtomicU32>,
    metronome_count_in_playback: Arc<AtomicBool>,
    metronome_count_in_record: Arc<AtomicBool>,
    async_executor: AsyncExecutor<TLBX1>,
    pending_project_params: Arc<Mutex<Option<PendingProjectParams>>>,
    slint_window: std::rc::Rc<MinimalSoftwareWindow>,
    ui: Box<TLBX1UI>,
    waveform_model: std::rc::Rc<VecModel<f32>>,
    oscilloscope_model: std::rc::Rc<VecModel<f32>>,
    spectrum_model: std::rc::Rc<VecModel<f32>>,
    vectorscope_x_model: std::rc::Rc<VecModel<f32>>,
    vectorscope_y_model: std::rc::Rc<VecModel<f32>>,
    video_frame_cache: Vec<Option<(u32, usize, Image)>>,
    sample_dialog_rx: std::sync::mpsc::Receiver<SampleDialogAction>,
    project_dialog_rx: std::sync::mpsc::Receiver<ProjectDialogAction>,
    sb_surface: softbuffer::Surface<SoftbufferWindowHandleAdapter, SoftbufferWindowHandleAdapter>,
    _sb_context: softbuffer::Context<SoftbufferWindowHandleAdapter>,
    physical_width: u32,
    physical_height: u32,
    scale_factor: f32,
    pixel_buffer: Vec<PremultipliedRgbaColor>,
    last_cursor: LogicalPosition,
    _library_folders: Arc<Mutex<Vec<PathBuf>>>,
    current_path: Arc<Mutex<PathBuf>>,
    _library_folders_model: std::rc::Rc<VecModel<SharedString>>,
    current_folder_content_model: std::rc::Rc<VecModel<BrowserEntry>>,
    _animate_library: Arc<AnimateLibrary>,
    last_modul8_engine_type: Option<u32>,
    last_modul8_track_idx: Option<usize>,
}

impl SlintWindow {
    fn new(
        window: &mut BaseWindow,
        initial_size: baseview::Size,
        gui_context: Arc<dyn GuiContext>,
        params: Arc<TLBX1Params>,
        tracks: Arc<[Track; NUM_TRACKS]>,
        master_meters: Arc<MasterMeters>,
        visualizer: Arc<VisualizerState>,
        global_tempo: Arc<AtomicU32>,
        follow_host_tempo: Arc<AtomicBool>,
        metronome_enabled: Arc<AtomicBool>,
        metronome_count_in_ticks: Arc<AtomicU32>,
        metronome_count_in_playback: Arc<AtomicBool>,
        metronome_count_in_record: Arc<AtomicBool>,
        async_executor: AsyncExecutor<TLBX1>,
        pending_project_params: Arc<Mutex<Option<PendingProjectParams>>>,
        animate_library: Arc<AnimateLibrary>,
    ) -> Self {
        ensure_slint_platform();
        let (slint_window, ui) = create_slint_ui();
        let waveform_model =
            std::rc::Rc::new(VecModel::from(vec![0.0; WAVEFORM_SUMMARY_SIZE]));
        let oscilloscope_model =
            std::rc::Rc::new(VecModel::from(vec![0.0; OSCILLOSCOPE_SAMPLES]));
        let spectrum_model = std::rc::Rc::new(VecModel::from(vec![0.0; SPECTRUM_BINS]));
        let vectorscope_x_model =
            std::rc::Rc::new(VecModel::from(vec![0.0; VECTORSCOPE_POINTS]));
        let vectorscope_y_model =
            std::rc::Rc::new(VecModel::from(vec![0.0; VECTORSCOPE_POINTS]));
        let video_frame_cache = vec![None; NUM_TRACKS];
        ui.set_waveform(ModelRc::from(waveform_model.clone()));
        ui.set_oscilloscope(ModelRc::from(oscilloscope_model.clone()));
        ui.set_spectrum(ModelRc::from(spectrum_model.clone()));
        ui.set_vectorscope_x(ModelRc::from(vectorscope_x_model.clone()));
        ui.set_vectorscope_y(ModelRc::from(vectorscope_y_model.clone()));
        let (sample_dialog_tx, sample_dialog_rx) = mpsc::channel();
        let (project_dialog_tx, project_dialog_rx) = mpsc::channel();

        let mut scale_factor = 1.0_f32;
        #[cfg(target_os = "windows")]
        {
            use windows_sys::Win32::UI::WindowsAndMessaging::{ShowWindow, SW_MAXIMIZE};
            use windows_sys::Win32::UI::HiDpi::GetDpiForWindow;
            if let RawWindowHandle::Win32(handle) = window.raw_window_handle() {
                unsafe {
                    let dpi = GetDpiForWindow(handle.hwnd as _) as f32;
                    if dpi > 0.0 {
                        scale_factor = dpi / 96.0;
                    }
                    ShowWindow(handle.hwnd as _, SW_MAXIMIZE);
                }
            }
        }

        let logical_width = initial_size.width as f32;
        let logical_height = initial_size.height as f32;
        let physical_width = (logical_width * scale_factor).round() as u32;
        let physical_height = (logical_height * scale_factor).round() as u32;

        follow_host_tempo.store(
            gui_context.plugin_api() != PluginApi::Standalone,
            Ordering::Relaxed,
        );

        let target = baseview_window_to_surface_target(window);
        let sb_context =
            softbuffer::Context::new(target.clone()).expect("Failed to create softbuffer context");
        let mut sb_surface = softbuffer::Surface::new(&sb_context, target)
            .expect("Failed to create softbuffer surface");
        sb_surface
            .resize(
                std::num::NonZeroU32::new(physical_width).unwrap(),
                std::num::NonZeroU32::new(physical_height).unwrap(),
            )
            .unwrap();

        slint_window.dispatch_event(WindowEvent::ScaleFactorChanged { scale_factor });
        slint_window.set_size(slint::WindowSize::Physical(PhysicalSize::new(physical_width, physical_height)));

        let output_devices = available_output_devices();
        let input_devices = available_input_devices();
        let sample_rates = vec![44100, 48000, 88200, 96000];
        let buffer_sizes = vec![256, 512, 1024, 2048, 4096];

        let _is_software = true;
        #[cfg(any(feature = "renderer-opengl", feature = "renderer-vulkan"))]
        let _is_software = false;

        ui.set_is_software_renderer(_is_software);

        let library_folders = Arc::new(Mutex::new(Vec::new()));
        let current_path = Arc::new(Mutex::new(PathBuf::from(".")));
        let library_folders_model = std::rc::Rc::new(VecModel::default());
        let current_folder_content_model = std::rc::Rc::new(VecModel::default());

        initialize_ui(
            &ui,
            &gui_context,
            &params,
            &tracks,
            &global_tempo,
            &follow_host_tempo,
            &metronome_enabled,
            &metronome_count_in_ticks,
            &metronome_count_in_playback,
            &metronome_count_in_record,
            &async_executor,
            &output_devices,
            &input_devices,
            &sample_rates,
            &buffer_sizes,
            sample_dialog_tx,
            project_dialog_tx,
            &library_folders,
            &current_path,
            &library_folders_model,
            &current_folder_content_model,
            &animate_library,
        );

        ui.set_library_folders(ModelRc::from(library_folders_model.clone()));
        ui.set_current_folder_content(ModelRc::from(current_folder_content_model.clone()));

        ui.show().unwrap();

        // Mark window as active
        slint_window.dispatch_event(WindowEvent::WindowActiveChanged(true));

        Self {
            gui_context,
            params,
            tracks,
            master_meters,
            visualizer,
            global_tempo,
            _follow_host_tempo: follow_host_tempo,
            metronome_enabled,
            metronome_count_in_ticks,
            metronome_count_in_playback,
            metronome_count_in_record,
            async_executor,
            pending_project_params,
            slint_window,
            ui,
            waveform_model,
            oscilloscope_model,
            spectrum_model,
            vectorscope_x_model,
            vectorscope_y_model,
            video_frame_cache,
            sample_dialog_rx,
            project_dialog_rx,
            sb_surface,
            _sb_context: sb_context,
            physical_width,
            physical_height,
            scale_factor,
            pixel_buffer: vec![PremultipliedRgbaColor::default(); (physical_width * physical_height) as usize],
            last_cursor: LogicalPosition::new(0.0, 0.0),
            _library_folders: library_folders,
            current_path,
            _library_folders_model: library_folders_model,
            current_folder_content_model,
            _animate_library: animate_library,
            last_modul8_engine_type: None,
            last_modul8_track_idx: None,
        }
    }

    fn dispatch_slint_event(&self, event: WindowEvent) {
        self.slint_window.dispatch_event(event);
    }

    #[allow(dead_code)]
    fn refresh_browser(&self) {
        refresh_browser_impl(
            &self.ui,
            &self.current_path.lock(),
            &self.current_folder_content_model,
        );
    }

    fn update_ui_state(&mut self) {
        let track_idx = self
            .params
            .selected_track
            .value()
            .saturating_sub(1) as usize;
        let track_idx = track_idx.min(NUM_TRACKS - 1);

        let is_playing = self
            .tracks
            .iter()
            .any(|track| track.is_playing.load(Ordering::Relaxed));
        let is_recording = self.tracks[track_idx].is_recording.load(Ordering::Relaxed);
        let gain = self.params.gain.unmodulated_normalized_value();
        let master_filter = self.params.master_filter.unmodulated_normalized_value();
        let master_comp = self.params.master_comp.unmodulated_normalized_value();
        let track_level =
            f32::from_bits(self.tracks[track_idx].level.load(Ordering::Relaxed));
        let meter_left =
            f32::from_bits(self.master_meters.left.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let meter_right =
            f32::from_bits(self.master_meters.right.load(Ordering::Relaxed)).clamp(0.0, 1.0);
        let track_meter_left =
            f32::from_bits(self.tracks[track_idx].meter_left.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let track_meter_right =
            f32::from_bits(self.tracks[track_idx].meter_right.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let track_muted = self.tracks[track_idx].is_muted.load(Ordering::Relaxed);
        let tape_speed =
            f32::from_bits(self.tracks[track_idx].tape_speed.load(Ordering::Relaxed));
        let tape_tempo =
            f32::from_bits(self.global_tempo.load(Ordering::Relaxed));
        let metronome_enabled =
            self.metronome_enabled.load(Ordering::Relaxed);
        let metronome_count_in_ticks =
            self.metronome_count_in_ticks.load(Ordering::Relaxed);
        let metronome_count_in_playback =
            self.metronome_count_in_playback.load(Ordering::Relaxed);
        let metronome_count_in_record =
            self.metronome_count_in_record.load(Ordering::Relaxed);
        let tape_rate_mode =
            self.tracks[track_idx].tape_rate_mode.load(Ordering::Relaxed);
        let tape_rotate =
            f32::from_bits(self.tracks[track_idx].tape_rotate.load(Ordering::Relaxed));
        let tape_glide =
            f32::from_bits(self.tracks[track_idx].tape_glide.load(Ordering::Relaxed));
        let tape_sos =
            f32::from_bits(self.tracks[track_idx].tape_sos.load(Ordering::Relaxed));
        let tape_reverse =
            self.tracks[track_idx].tape_reverse.load(Ordering::Relaxed);
        let tape_freeze =
            self.tracks[track_idx].tape_freeze.load(Ordering::Relaxed);
        let tape_keylock =
            self.tracks[track_idx].tape_keylock.load(Ordering::Relaxed);
        let tape_monitor =
            self.tracks[track_idx].tape_monitor.load(Ordering::Relaxed);
        let tape_overdub =
            self.tracks[track_idx].tape_overdub.load(Ordering::Relaxed);
        let mosaic_pitch =
            f32::from_bits(self.tracks[track_idx].mosaic_pitch.load(Ordering::Relaxed));
        let mosaic_rate =
            f32::from_bits(self.tracks[track_idx].mosaic_rate.load(Ordering::Relaxed));
        let mosaic_size =
            f32::from_bits(self.tracks[track_idx].mosaic_size.load(Ordering::Relaxed));
        let mosaic_contour =
            f32::from_bits(self.tracks[track_idx].mosaic_contour.load(Ordering::Relaxed));
        let mosaic_warp =
            f32::from_bits(self.tracks[track_idx].mosaic_warp.load(Ordering::Relaxed));
        let mosaic_spray =
            f32::from_bits(self.tracks[track_idx].mosaic_spray.load(Ordering::Relaxed));
        let mosaic_pattern =
            f32::from_bits(self.tracks[track_idx].mosaic_pattern.load(Ordering::Relaxed));
        let mosaic_wet =
            f32::from_bits(self.tracks[track_idx].mosaic_wet.load(Ordering::Relaxed));
        let mosaic_post_gain =
            f32::from_bits(self.tracks[track_idx].mosaic_post_gain.load(Ordering::Relaxed));
        let mosaic_spatial =
            f32::from_bits(self.tracks[track_idx].mosaic_spatial.load(Ordering::Relaxed));
        let mosaic_detune =
            f32::from_bits(self.tracks[track_idx].mosaic_detune.load(Ordering::Relaxed));
        let mosaic_rand_rate =
            f32::from_bits(self.tracks[track_idx].mosaic_rand_rate.load(Ordering::Relaxed));
        let mosaic_rand_size =
            f32::from_bits(self.tracks[track_idx].mosaic_rand_size.load(Ordering::Relaxed));
        let mosaic_sos =
            f32::from_bits(self.tracks[track_idx].mosaic_sos.load(Ordering::Relaxed));
        let mosaic_enabled = self.tracks[track_idx].mosaic_enabled.load(Ordering::Relaxed);
        let mosaic_loop_lock = self.tracks[track_idx].mosaic_loop_lock.load(Ordering::Relaxed);
        let mosaic_grain_markers = if mosaic_enabled {
            let mut markers = Vec::new();
            for marker in &self.tracks[track_idx].mosaic_grain_markers {
                let value = f32::from_bits(marker.load(Ordering::Relaxed));
                if value >= 0.0 {
                    markers.push(value.clamp(0.0, 1.0));
                }
            }
            let track_sample_rate =
                self.tracks[track_idx].sample_rate.load(Ordering::Relaxed) as usize;
            let mosaic_len =
                (track_sample_rate * MOSAIC_BUFFER_SECONDS).min(MOSAIC_BUFFER_SAMPLES);
            if mosaic_len > 0 {
                let grain_start =
                    self.tracks[track_idx].mosaic_last_grain_start.load(Ordering::Relaxed)
                        as usize;
                let grain_len =
                    self.tracks[track_idx].mosaic_last_grain_len.load(Ordering::Relaxed) as usize;
                let start_pos = (grain_start % mosaic_len) as f32 / mosaic_len as f32;
                let end_pos =
                    ((grain_start + grain_len.min(mosaic_len)) % mosaic_len) as f32 / mosaic_len as f32;
                markers.push(start_pos.clamp(0.0, 1.0));
                markers.push(end_pos.clamp(0.0, 1.0));
            }
            markers
        } else {
            Vec::new()
        };
        let ring_cutoff =
            f32::from_bits(self.tracks[track_idx].ring_cutoff.load(Ordering::Relaxed));
        let ring_resonance =
            f32::from_bits(self.tracks[track_idx].ring_resonance.load(Ordering::Relaxed));
        let ring_decay =
            f32::from_bits(self.tracks[track_idx].ring_decay.load(Ordering::Relaxed));
        let ring_pitch =
            f32::from_bits(self.tracks[track_idx].ring_pitch.load(Ordering::Relaxed));
        let ring_tone =
            f32::from_bits(self.tracks[track_idx].ring_tone.load(Ordering::Relaxed));
        let ring_tilt =
            f32::from_bits(self.tracks[track_idx].ring_tilt.load(Ordering::Relaxed));
        let ring_slope =
            f32::from_bits(self.tracks[track_idx].ring_slope.load(Ordering::Relaxed));
        let ring_wet =
            f32::from_bits(self.tracks[track_idx].ring_wet.load(Ordering::Relaxed));
        let ring_detune =
            f32::from_bits(self.tracks[track_idx].ring_detune.load(Ordering::Relaxed));
        let ring_waves =
            f32::from_bits(self.tracks[track_idx].ring_waves.load(Ordering::Relaxed));
        let ring_waves_rate =
            f32::from_bits(self.tracks[track_idx].ring_waves_rate.load(Ordering::Relaxed));
        let ring_waves_rate_mode =
            self.tracks[track_idx].ring_waves_rate_mode.load(Ordering::Relaxed);
        let ring_noise =
            f32::from_bits(self.tracks[track_idx].ring_noise.load(Ordering::Relaxed));
        let ring_noise_rate =
            f32::from_bits(self.tracks[track_idx].ring_noise_rate.load(Ordering::Relaxed));
        let ring_noise_rate_mode =
            self.tracks[track_idx].ring_noise_rate_mode.load(Ordering::Relaxed);
        let ring_scale =
            self.tracks[track_idx].ring_scale.load(Ordering::Relaxed);
        let ring_pre_post = self.tracks[track_idx].ring_pre_post.load(Ordering::Relaxed);
        let texture_enabled = self.tracks[track_idx].texture_enabled.load(Ordering::Relaxed);
        let texture_gate = self.tracks[track_idx].texture_gate.load(Ordering::Relaxed);
        let texture_drive =
            f32::from_bits(self.tracks[track_idx].texture_drive.load(Ordering::Relaxed));
        let texture_compress =
            f32::from_bits(self.tracks[track_idx].texture_compress.load(Ordering::Relaxed));
        let texture_crush =
            f32::from_bits(self.tracks[track_idx].texture_crush.load(Ordering::Relaxed));
        let texture_tilt =
            f32::from_bits(self.tracks[track_idx].texture_tilt.load(Ordering::Relaxed));
        let texture_noise =
            f32::from_bits(self.tracks[track_idx].texture_noise.load(Ordering::Relaxed));
        let texture_noise_decay =
            f32::from_bits(self.tracks[track_idx].texture_noise_decay.load(Ordering::Relaxed));
        let texture_noise_color =
            f32::from_bits(self.tracks[track_idx].texture_noise_color.load(Ordering::Relaxed));
        let texture_wet =
            f32::from_bits(self.tracks[track_idx].texture_wet.load(Ordering::Relaxed));
        let texture_post_gain =
            f32::from_bits(self.tracks[track_idx].texture_post_gain.load(Ordering::Relaxed));
        let reflect_enabled = self.tracks[track_idx].reflect_enabled.load(Ordering::Relaxed);
        let reflect_freeze = self.tracks[track_idx].reflect_freeze.load(Ordering::Relaxed);
        let reflect_delay =
            f32::from_bits(self.tracks[track_idx].reflect_delay.load(Ordering::Relaxed));
        let reflect_time =
            f32::from_bits(self.tracks[track_idx].reflect_time.load(Ordering::Relaxed));
        let reflect_time_mode =
            self.tracks[track_idx].reflect_time_mode.load(Ordering::Relaxed);
        let reflect_reverb =
            f32::from_bits(self.tracks[track_idx].reflect_reverb.load(Ordering::Relaxed));
        let reflect_size =
            f32::from_bits(self.tracks[track_idx].reflect_size.load(Ordering::Relaxed));
        let reflect_feedback =
            f32::from_bits(self.tracks[track_idx].reflect_feedback.load(Ordering::Relaxed));
        let reflect_spread =
            f32::from_bits(self.tracks[track_idx].reflect_spread.load(Ordering::Relaxed));
        let reflect_damp =
            f32::from_bits(self.tracks[track_idx].reflect_damp.load(Ordering::Relaxed));
        let reflect_decay =
            f32::from_bits(self.tracks[track_idx].reflect_decay.load(Ordering::Relaxed));
        let reflect_post_gain =
            f32::from_bits(self.tracks[track_idx].reflect_post_gain.load(Ordering::Relaxed));
        let loop_start =
            f32::from_bits(self.tracks[track_idx].loop_start.load(Ordering::Relaxed));
        let trigger_start =
            f32::from_bits(self.tracks[track_idx].trigger_start.load(Ordering::Relaxed));
        let loop_length =
            f32::from_bits(self.tracks[track_idx].loop_length.load(Ordering::Relaxed));
        let loop_xfade =
            f32::from_bits(self.tracks[track_idx].loop_xfade.load(Ordering::Relaxed));
        let loop_enabled =
            self.tracks[track_idx].loop_enabled.load(Ordering::Relaxed);
        let loop_mode = self.tracks[track_idx].loop_mode.load(Ordering::Relaxed);
        let ring_enabled = self.tracks[track_idx].ring_enabled.load(Ordering::Relaxed);
        let ring_decay_mode = self.tracks[track_idx].ring_decay_mode.load(Ordering::Relaxed);
        let g8_enabled = self.tracks[track_idx].g8_enabled.load(Ordering::Relaxed);
        let g8_rate_index = self.tracks[track_idx].g8_rate_index.load(Ordering::Relaxed);
        let g8_steps: Vec<f32> = (0..G8_STEPS)
            .map(|i| f32::from_bits(self.tracks[track_idx].g8_steps[i].load(Ordering::Relaxed)))
            .collect();
        let modul8_enabled = self.tracks[track_idx].modul8_enabled.load(Ordering::Relaxed);
        let modul8_wave: Vec<i32> = (0..MODUL8_LFOS)
            .map(|i| self.tracks[track_idx].modul8_wave[i].load(Ordering::Relaxed) as i32)
            .collect();
        let modul8_rate: Vec<f32> = (0..MODUL8_LFOS)
            .map(|i| f32::from_bits(self.tracks[track_idx].modul8_rate[i].load(Ordering::Relaxed)))
            .collect();
        let modul8_sync: Vec<bool> = (0..MODUL8_LFOS)
            .map(|i| self.tracks[track_idx].modul8_sync[i].load(Ordering::Relaxed))
            .collect();
        let modul8_division: Vec<i32> = (0..MODUL8_LFOS)
            .map(|i| self.tracks[track_idx].modul8_division[i].load(Ordering::Relaxed) as i32)
            .collect();
        let modul8_amount: Vec<f32> = (0..MODUL8_LFOS)
            .map(|i| f32::from_bits(self.tracks[track_idx].modul8_amount[i].load(Ordering::Relaxed)))
            .collect();
        let modul8_bias: Vec<f32> = (0..MODUL8_LFOS)
            .map(|i| f32::from_bits(self.tracks[track_idx].modul8_bias[i].load(Ordering::Relaxed)))
            .collect();
        let active_engine_type = self.tracks[track_idx].engine_type.load(Ordering::Relaxed);
        let modul8_target_len = modul8_target_ids_for_engine(active_engine_type).len() as i32;
        let modul8_target: Vec<i32> = (0..MODUL8_LFOS)
            .map(|i| {
                let v = self.tracks[track_idx].modul8_target[i].load(Ordering::Relaxed) as i32;
                if modul8_target_len > 0 {
                    v.clamp(0, modul8_target_len - 1)
                } else {
                    0
                }
            })
            .collect();
        let engine_loaded = active_engine_type != 0;

        let animate_slot_types = [
            self.tracks[track_idx].animate_slot_types[0].load(Ordering::Relaxed),
            self.tracks[track_idx].animate_slot_types[1].load(Ordering::Relaxed),
            self.tracks[track_idx].animate_slot_types[2].load(Ordering::Relaxed),
            self.tracks[track_idx].animate_slot_types[3].load(Ordering::Relaxed),
        ];
        let animate_slot_wavetables = [
            self.tracks[track_idx].animate_slot_wavetables[0].load(Ordering::Relaxed),
            self.tracks[track_idx].animate_slot_wavetables[1].load(Ordering::Relaxed),
            self.tracks[track_idx].animate_slot_wavetables[2].load(Ordering::Relaxed),
            self.tracks[track_idx].animate_slot_wavetables[3].load(Ordering::Relaxed),
        ];
        let animate_slot_samples = [
            self.tracks[track_idx].animate_slot_samples[0].load(Ordering::Relaxed),
            self.tracks[track_idx].animate_slot_samples[1].load(Ordering::Relaxed),
            self.tracks[track_idx].animate_slot_samples[2].load(Ordering::Relaxed),
            self.tracks[track_idx].animate_slot_samples[3].load(Ordering::Relaxed),
        ];
        let animate_slot_coarse = [
            f32::from_bits(self.tracks[track_idx].animate_slot_coarse[0].load(Ordering::Relaxed)),
            f32::from_bits(self.tracks[track_idx].animate_slot_coarse[1].load(Ordering::Relaxed)),
            f32::from_bits(self.tracks[track_idx].animate_slot_coarse[2].load(Ordering::Relaxed)),
            f32::from_bits(self.tracks[track_idx].animate_slot_coarse[3].load(Ordering::Relaxed)),
        ];
        let animate_slot_fine = [
            f32::from_bits(self.tracks[track_idx].animate_slot_fine[0].load(Ordering::Relaxed)),
            f32::from_bits(self.tracks[track_idx].animate_slot_fine[1].load(Ordering::Relaxed)),
            f32::from_bits(self.tracks[track_idx].animate_slot_fine[2].load(Ordering::Relaxed)),
            f32::from_bits(self.tracks[track_idx].animate_slot_fine[3].load(Ordering::Relaxed)),
        ];
        let animate_slot_level = [
            f32::from_bits(self.tracks[track_idx].animate_slot_level[0].load(Ordering::Relaxed)),
            f32::from_bits(self.tracks[track_idx].animate_slot_level[1].load(Ordering::Relaxed)),
            f32::from_bits(self.tracks[track_idx].animate_slot_level[2].load(Ordering::Relaxed)),
            f32::from_bits(self.tracks[track_idx].animate_slot_level[3].load(Ordering::Relaxed)),
        ];
        let animate_slot_pan = [
            f32::from_bits(self.tracks[track_idx].animate_slot_pan[0].load(Ordering::Relaxed)),
            f32::from_bits(self.tracks[track_idx].animate_slot_pan[1].load(Ordering::Relaxed)),
            f32::from_bits(self.tracks[track_idx].animate_slot_pan[2].load(Ordering::Relaxed)),
            f32::from_bits(self.tracks[track_idx].animate_slot_pan[3].load(Ordering::Relaxed)),
        ];
        let animate_slot_wt_lfo_amount = [
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_wt_lfo_amount[0]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_wt_lfo_amount[1]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_wt_lfo_amount[2]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_wt_lfo_amount[3]
                    .load(Ordering::Relaxed),
            ),
        ];
        let animate_slot_wt_lfo_shape = [
            self.tracks[track_idx]
                .animate_slot_wt_lfo_shape[0]
                .load(Ordering::Relaxed),
            self.tracks[track_idx]
                .animate_slot_wt_lfo_shape[1]
                .load(Ordering::Relaxed),
            self.tracks[track_idx]
                .animate_slot_wt_lfo_shape[2]
                .load(Ordering::Relaxed),
            self.tracks[track_idx]
                .animate_slot_wt_lfo_shape[3]
                .load(Ordering::Relaxed),
        ];
        let animate_slot_wt_lfo_rate = [
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_wt_lfo_rate[0]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_wt_lfo_rate[1]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_wt_lfo_rate[2]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_wt_lfo_rate[3]
                    .load(Ordering::Relaxed),
            ),
        ];
        let animate_slot_wt_lfo_sync = [
            self.tracks[track_idx]
                .animate_slot_wt_lfo_sync[0]
                .load(Ordering::Relaxed),
            self.tracks[track_idx]
                .animate_slot_wt_lfo_sync[1]
                .load(Ordering::Relaxed),
            self.tracks[track_idx]
                .animate_slot_wt_lfo_sync[2]
                .load(Ordering::Relaxed),
            self.tracks[track_idx]
                .animate_slot_wt_lfo_sync[3]
                .load(Ordering::Relaxed),
        ];
        let animate_slot_wt_lfo_division = [
            self.tracks[track_idx]
                .animate_slot_wt_lfo_division[0]
                .load(Ordering::Relaxed),
            self.tracks[track_idx]
                .animate_slot_wt_lfo_division[1]
                .load(Ordering::Relaxed),
            self.tracks[track_idx]
                .animate_slot_wt_lfo_division[2]
                .load(Ordering::Relaxed),
            self.tracks[track_idx]
                .animate_slot_wt_lfo_division[3]
                .load(Ordering::Relaxed),
        ];
        let animate_slot_sample_start = [
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_sample_start[0]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_sample_start[1]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_sample_start[2]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_sample_start[3]
                    .load(Ordering::Relaxed),
            ),
        ];
        let animate_slot_loop_start = [
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_loop_start[0]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_loop_start[1]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_loop_start[2]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_loop_start[3]
                    .load(Ordering::Relaxed),
            ),
        ];
        let animate_slot_loop_end = [
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_loop_end[0]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_loop_end[1]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_loop_end[2]
                    .load(Ordering::Relaxed),
            ),
            f32::from_bits(
                self.tracks[track_idx]
                    .animate_slot_loop_end[3]
                    .load(Ordering::Relaxed),
            ),
        ];
        let animate_slot_a_filter_type =
            self.tracks[track_idx].animate_slot_filter_type[0].load(Ordering::Relaxed);
        let animate_slot_a_filter_cutoff = f32::from_bits(
            self.tracks[track_idx]
                .animate_slot_filter_cutoff[0]
                .load(Ordering::Relaxed),
        );
        let animate_slot_a_filter_resonance = f32::from_bits(
            self.tracks[track_idx]
                .animate_slot_filter_resonance[0]
                .load(Ordering::Relaxed),
        );
        let animate_slot_a_attack =
            f32::from_bits(self.tracks[track_idx].animate_slot_a_attack.load(Ordering::Relaxed));
        let animate_slot_a_decay =
            f32::from_bits(self.tracks[track_idx].animate_slot_a_decay.load(Ordering::Relaxed));
        let animate_slot_a_sustain =
            f32::from_bits(self.tracks[track_idx].animate_slot_a_sustain.load(Ordering::Relaxed));
        let animate_slot_a_release =
            f32::from_bits(self.tracks[track_idx].animate_slot_a_release.load(Ordering::Relaxed));
        let animate_vector_x =
            f32::from_bits(self.tracks[track_idx].animate_vector_x.load(Ordering::Relaxed));
        let animate_vector_y =
            f32::from_bits(self.tracks[track_idx].animate_vector_y.load(Ordering::Relaxed));
        let animate_lfo_x_waveform =
            self.tracks[track_idx].animate_lfo_x_waveform.load(Ordering::Relaxed);
        let animate_lfo_x_sync =
            self.tracks[track_idx].animate_lfo_x_sync.load(Ordering::Relaxed);
        let animate_lfo_x_division =
            self.tracks[track_idx].animate_lfo_x_division.load(Ordering::Relaxed);
        let animate_lfo_x_rate =
            f32::from_bits(self.tracks[track_idx].animate_lfo_x_rate.load(Ordering::Relaxed));
        let animate_lfo_x_amount =
            f32::from_bits(self.tracks[track_idx].animate_lfo_x_amount.load(Ordering::Relaxed));
        let animate_lfo_y_waveform =
            self.tracks[track_idx].animate_lfo_y_waveform.load(Ordering::Relaxed);
        let animate_lfo_y_sync =
            self.tracks[track_idx].animate_lfo_y_sync.load(Ordering::Relaxed);
        let animate_lfo_y_division =
            self.tracks[track_idx].animate_lfo_y_division.load(Ordering::Relaxed);
        let animate_lfo_y_rate =
            f32::from_bits(self.tracks[track_idx].animate_lfo_y_rate.load(Ordering::Relaxed));
        let animate_lfo_y_amount =
            f32::from_bits(self.tracks[track_idx].animate_lfo_y_amount.load(Ordering::Relaxed));
        let animate_sequencer_current_step =
            self.tracks[track_idx].animate_sequencer_step.load(Ordering::Relaxed);

        let mut animate_sequencer_grid = Vec::with_capacity(160);
        for i in 0..160 {
            animate_sequencer_grid
                .push(self.tracks[track_idx].animate_sequencer_grid[i].load(Ordering::Relaxed));
        }

        let mut kick_pitch =
            f32::from_bits(self.tracks[track_idx].kick_pitch.load(Ordering::Relaxed));
        let mut kick_decay =
            f32::from_bits(self.tracks[track_idx].kick_decay.load(Ordering::Relaxed));
        let mut kick_attack =
            f32::from_bits(self.tracks[track_idx].kick_attack.load(Ordering::Relaxed));
        let kick_pitch_env_amount =
            f32::from_bits(self.tracks[track_idx].kick_pitch_env_amount.load(Ordering::Relaxed));
        let mut kick_drive =
            f32::from_bits(self.tracks[track_idx].kick_drive.load(Ordering::Relaxed));
        let mut kick_level =
            f32::from_bits(self.tracks[track_idx].kick_level.load(Ordering::Relaxed));
        let mut kick_filter_type =
            self.tracks[track_idx].kick_filter_type.load(Ordering::Relaxed);
        let mut kick_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].kick_filter_cutoff.load(Ordering::Relaxed));
        let mut kick_filter_resonance =
            f32::from_bits(self.tracks[track_idx].kick_filter_resonance.load(Ordering::Relaxed));
        let kick_filter_pre_drive =
            self.tracks[track_idx].kick_filter_pre_drive.load(Ordering::Relaxed);
        let kick_cut_group = self.tracks[track_idx].kick_cut_group.load(Ordering::Relaxed) as f32;
        let kick_cut_by = self.tracks[track_idx].kick_cut_by.load(Ordering::Relaxed) as f32;
        let kick_prob = f32::from_bits(self.tracks[track_idx].kick_prob.load(Ordering::Relaxed))
            .clamp(0.0, 1.0);
        let kick_lane_enabled = self.tracks[track_idx].kick_lane_enabled.load(Ordering::Relaxed);
        let kick_sequencer_current_step =
            self.tracks[track_idx].kick_sequencer_step.load(Ordering::Relaxed);
        let mut kick_sequencer_grid = Vec::with_capacity(SYNDRM_STEPS);
        for i in 0..SYNDRM_STEPS {
            kick_sequencer_grid
                .push(self.tracks[track_idx].kick_sequencer_grid[i].load(Ordering::Relaxed));
        }
        let snare_tone =
            f32::from_bits(self.tracks[track_idx].snare_tone.load(Ordering::Relaxed));
        let snare_decay =
            f32::from_bits(self.tracks[track_idx].snare_decay.load(Ordering::Relaxed));
        let snare_snappy =
            f32::from_bits(self.tracks[track_idx].snare_snappy.load(Ordering::Relaxed));
        let snare_attack =
            f32::from_bits(self.tracks[track_idx].snare_attack.load(Ordering::Relaxed));
        let snare_drive =
            f32::from_bits(self.tracks[track_idx].snare_drive.load(Ordering::Relaxed));
        let snare_level =
            f32::from_bits(self.tracks[track_idx].snare_level.load(Ordering::Relaxed));
        let snare_filter_type =
            self.tracks[track_idx].snare_filter_type.load(Ordering::Relaxed);
        let snare_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].snare_filter_cutoff.load(Ordering::Relaxed));
        let snare_filter_resonance =
            f32::from_bits(self.tracks[track_idx].snare_filter_resonance.load(Ordering::Relaxed));
        let snare_filter_pre_drive =
            self.tracks[track_idx].snare_filter_pre_drive.load(Ordering::Relaxed);
        let snare_cut_group = self.tracks[track_idx].snare_cut_group.load(Ordering::Relaxed) as f32;
        let snare_cut_by = self.tracks[track_idx].snare_cut_by.load(Ordering::Relaxed) as f32;
        let snare_prob = f32::from_bits(self.tracks[track_idx].snare_prob.load(Ordering::Relaxed))
            .clamp(0.0, 1.0);
        let snare_lane_enabled = self.tracks[track_idx].snare_lane_enabled.load(Ordering::Relaxed);
        let snare_sequencer_current_step =
            self.tracks[track_idx].snare_sequencer_step.load(Ordering::Relaxed);
        let mut snare_sequencer_grid = Vec::with_capacity(SYNDRM_STEPS);
        for i in 0..SYNDRM_STEPS {
            snare_sequencer_grid
                .push(self.tracks[track_idx].snare_sequencer_grid[i].load(Ordering::Relaxed));
        }
        let clap_pitch =
            f32::from_bits(self.tracks[track_idx].clap_pitch.load(Ordering::Relaxed));
        let clap_decay =
            f32::from_bits(self.tracks[track_idx].clap_decay.load(Ordering::Relaxed));
        let clap_tone =
            f32::from_bits(self.tracks[track_idx].clap_tone.load(Ordering::Relaxed));
        let clap_drive =
            f32::from_bits(self.tracks[track_idx].clap_drive.load(Ordering::Relaxed));
        let clap_level =
            f32::from_bits(self.tracks[track_idx].clap_level.load(Ordering::Relaxed));
        let clap_filter_type =
            self.tracks[track_idx].clap_filter_type.load(Ordering::Relaxed);
        let clap_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].clap_filter_cutoff.load(Ordering::Relaxed));
        let clap_filter_resonance =
            f32::from_bits(self.tracks[track_idx].clap_filter_resonance.load(Ordering::Relaxed));
        let clap_filter_pre_drive =
            self.tracks[track_idx].clap_filter_pre_drive.load(Ordering::Relaxed);
        let clap_cut_group = self.tracks[track_idx].clap_cut_group.load(Ordering::Relaxed) as f32;
        let clap_cut_by = self.tracks[track_idx].clap_cut_by.load(Ordering::Relaxed) as f32;
        let clap_prob = f32::from_bits(self.tracks[track_idx].clap_prob.load(Ordering::Relaxed))
            .clamp(0.0, 1.0);
        let clap_lane_enabled = self.tracks[track_idx].clap_lane_enabled.load(Ordering::Relaxed);
        let clap_sequencer_current_step =
            self.tracks[track_idx].clap_sequencer_step.load(Ordering::Relaxed);
        let mut clap_sequencer_grid = Vec::with_capacity(SYNDRM_STEPS);
        for i in 0..SYNDRM_STEPS {
            clap_sequencer_grid
                .push(self.tracks[track_idx].clap_sequencer_grid[i].load(Ordering::Relaxed));
        }
        let mut hat_pitch = f32::from_bits(self.tracks[track_idx].hat_pitch.load(Ordering::Relaxed));
        let mut hat_decay = f32::from_bits(self.tracks[track_idx].hat_decay.load(Ordering::Relaxed));
        let mut hat_tone = f32::from_bits(self.tracks[track_idx].hat_tone.load(Ordering::Relaxed));
        let mut hat_drive = f32::from_bits(self.tracks[track_idx].hat_drive.load(Ordering::Relaxed));
        let mut hat_level = f32::from_bits(self.tracks[track_idx].hat_level.load(Ordering::Relaxed));
        let mut hat_filter_type = self.tracks[track_idx].hat_filter_type.load(Ordering::Relaxed);
        let mut hat_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].hat_filter_cutoff.load(Ordering::Relaxed));
        let mut hat_filter_resonance =
            f32::from_bits(self.tracks[track_idx].hat_filter_resonance.load(Ordering::Relaxed));
        let hat_filter_pre_drive =
            self.tracks[track_idx].hat_filter_pre_drive.load(Ordering::Relaxed);
        let hat_cut_group = self.tracks[track_idx].hat_cut_group.load(Ordering::Relaxed) as f32;
        let hat_cut_by = self.tracks[track_idx].hat_cut_by.load(Ordering::Relaxed) as f32;
        let hat_prob = f32::from_bits(self.tracks[track_idx].hat_prob.load(Ordering::Relaxed))
            .clamp(0.0, 1.0);
        let hat_lane_enabled = self.tracks[track_idx].hat_lane_enabled.load(Ordering::Relaxed);
        let hat_sequencer_current_step =
            self.tracks[track_idx].hat_sequencer_step.load(Ordering::Relaxed);
        let mut hat_sequencer_grid = Vec::with_capacity(SYNDRM_STEPS);
        for i in 0..SYNDRM_STEPS {
            hat_sequencer_grid
                .push(self.tracks[track_idx].hat_sequencer_grid[i].load(Ordering::Relaxed));
        }
        let perc1_pitch = f32::from_bits(self.tracks[track_idx].perc1_pitch.load(Ordering::Relaxed));
        let perc1_decay = f32::from_bits(self.tracks[track_idx].perc1_decay.load(Ordering::Relaxed));
        let perc1_tone = f32::from_bits(self.tracks[track_idx].perc1_tone.load(Ordering::Relaxed));
        let perc1_drive = f32::from_bits(self.tracks[track_idx].perc1_drive.load(Ordering::Relaxed));
        let perc1_level = f32::from_bits(self.tracks[track_idx].perc1_level.load(Ordering::Relaxed));
        let perc1_filter_type = self.tracks[track_idx].perc1_filter_type.load(Ordering::Relaxed);
        let perc1_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].perc1_filter_cutoff.load(Ordering::Relaxed));
        let perc1_filter_resonance =
            f32::from_bits(self.tracks[track_idx].perc1_filter_resonance.load(Ordering::Relaxed));
        let perc1_filter_pre_drive =
            self.tracks[track_idx].perc1_filter_pre_drive.load(Ordering::Relaxed);
        let perc1_cut_group = self.tracks[track_idx].perc1_cut_group.load(Ordering::Relaxed) as f32;
        let perc1_cut_by = self.tracks[track_idx].perc1_cut_by.load(Ordering::Relaxed) as f32;
        let perc1_prob = f32::from_bits(self.tracks[track_idx].perc1_prob.load(Ordering::Relaxed))
            .clamp(0.0, 1.0);
        let perc1_lane_enabled = self.tracks[track_idx].perc1_lane_enabled.load(Ordering::Relaxed);
        let perc1_sequencer_current_step =
            self.tracks[track_idx].perc1_sequencer_step.load(Ordering::Relaxed);
        let mut perc1_sequencer_grid = Vec::with_capacity(SYNDRM_STEPS);
        for i in 0..SYNDRM_STEPS {
            perc1_sequencer_grid
                .push(self.tracks[track_idx].perc1_sequencer_grid[i].load(Ordering::Relaxed));
        }
        let perc2_pitch = f32::from_bits(self.tracks[track_idx].perc2_pitch.load(Ordering::Relaxed));
        let perc2_decay = f32::from_bits(self.tracks[track_idx].perc2_decay.load(Ordering::Relaxed));
        let perc2_tone = f32::from_bits(self.tracks[track_idx].perc2_tone.load(Ordering::Relaxed));
        let perc2_drive = f32::from_bits(self.tracks[track_idx].perc2_drive.load(Ordering::Relaxed));
        let perc2_level = f32::from_bits(self.tracks[track_idx].perc2_level.load(Ordering::Relaxed));
        let perc2_filter_type = self.tracks[track_idx].perc2_filter_type.load(Ordering::Relaxed);
        let perc2_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].perc2_filter_cutoff.load(Ordering::Relaxed));
        let perc2_filter_resonance =
            f32::from_bits(self.tracks[track_idx].perc2_filter_resonance.load(Ordering::Relaxed));
        let perc2_filter_pre_drive =
            self.tracks[track_idx].perc2_filter_pre_drive.load(Ordering::Relaxed);
        let perc2_cut_group = self.tracks[track_idx].perc2_cut_group.load(Ordering::Relaxed) as f32;
        let perc2_cut_by = self.tracks[track_idx].perc2_cut_by.load(Ordering::Relaxed) as f32;
        let perc2_prob = f32::from_bits(self.tracks[track_idx].perc2_prob.load(Ordering::Relaxed))
            .clamp(0.0, 1.0);
        let perc2_lane_enabled = self.tracks[track_idx].perc2_lane_enabled.load(Ordering::Relaxed);
        let perc2_sequencer_current_step =
            self.tracks[track_idx].perc2_sequencer_step.load(Ordering::Relaxed);
        let mut perc2_sequencer_grid = Vec::with_capacity(SYNDRM_STEPS);
        for i in 0..SYNDRM_STEPS {
            perc2_sequencer_grid
                .push(self.tracks[track_idx].perc2_sequencer_grid[i].load(Ordering::Relaxed));
        }
        let mut crash_pitch =
            f32::from_bits(self.tracks[track_idx].crash_pitch.load(Ordering::Relaxed));
        let mut crash_decay =
            f32::from_bits(self.tracks[track_idx].crash_decay.load(Ordering::Relaxed));
        let mut crash_tone =
            f32::from_bits(self.tracks[track_idx].crash_tone.load(Ordering::Relaxed));
        let mut crash_drive =
            f32::from_bits(self.tracks[track_idx].crash_drive.load(Ordering::Relaxed));
        let mut crash_level =
            f32::from_bits(self.tracks[track_idx].crash_level.load(Ordering::Relaxed));
        let mut crash_filter_type =
            self.tracks[track_idx].crash_filter_type.load(Ordering::Relaxed);
        let mut crash_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].crash_filter_cutoff.load(Ordering::Relaxed));
        let mut crash_filter_resonance =
            f32::from_bits(self.tracks[track_idx].crash_filter_resonance.load(Ordering::Relaxed));
        let crash_filter_pre_drive =
            self.tracks[track_idx].crash_filter_pre_drive.load(Ordering::Relaxed);
        let crash_cut_group = self.tracks[track_idx].crash_cut_group.load(Ordering::Relaxed) as f32;
        let crash_cut_by = self.tracks[track_idx].crash_cut_by.load(Ordering::Relaxed) as f32;
        let crash_prob = f32::from_bits(self.tracks[track_idx].crash_prob.load(Ordering::Relaxed))
            .clamp(0.0, 1.0);
        let crash_lane_enabled = self.tracks[track_idx].crash_lane_enabled.load(Ordering::Relaxed);
        let crash_sequencer_current_step =
            self.tracks[track_idx].crash_sequencer_step.load(Ordering::Relaxed);
        let mut crash_sequencer_grid = Vec::with_capacity(SYNDRM_STEPS);
        for i in 0..SYNDRM_STEPS {
            crash_sequencer_grid
                .push(self.tracks[track_idx].crash_sequencer_grid[i].load(Ordering::Relaxed));
        }
        let syndrm_step_hold = self.tracks[track_idx].syndrm_step_hold.load(Ordering::Relaxed);
        if syndrm_step_hold && kick_sequencer_current_step >= 0 {
            let step_idx = kick_sequencer_current_step as usize;
            if step_idx < SYNDRM_STEPS {
                if self.tracks[track_idx].kick_step_override_enabled[step_idx]
                    .load(Ordering::Relaxed)
                {
                    kick_pitch = f32::from_bits(
                        self.tracks[track_idx].kick_step_pitch[step_idx].load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    kick_decay = f32::from_bits(
                        self.tracks[track_idx].kick_step_decay[step_idx].load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    kick_attack = f32::from_bits(
                        self.tracks[track_idx].kick_step_attack[step_idx].load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    kick_drive = f32::from_bits(
                        self.tracks[track_idx].kick_step_drive[step_idx].load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    kick_level = f32::from_bits(
                        self.tracks[track_idx].kick_step_level[step_idx].load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    kick_filter_type =
                        self.tracks[track_idx].kick_step_filter_type[step_idx].load(Ordering::Relaxed);
                    kick_filter_cutoff = f32::from_bits(
                        self.tracks[track_idx]
                            .kick_step_filter_cutoff[step_idx]
                            .load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    kick_filter_resonance = f32::from_bits(
                        self.tracks[track_idx]
                            .kick_step_filter_resonance[step_idx]
                            .load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                }

                if self.tracks[track_idx].hat_step_override_enabled[step_idx].load(Ordering::Relaxed)
                {
                    hat_pitch = f32::from_bits(
                        self.tracks[track_idx].hat_step_pitch[step_idx].load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    hat_decay = f32::from_bits(
                        self.tracks[track_idx].hat_step_decay[step_idx].load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    hat_tone = f32::from_bits(
                        self.tracks[track_idx].hat_step_tone[step_idx].load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    hat_drive = f32::from_bits(
                        self.tracks[track_idx].hat_step_drive[step_idx].load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    hat_level = f32::from_bits(
                        self.tracks[track_idx].hat_step_level[step_idx].load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    hat_filter_type =
                        self.tracks[track_idx].hat_step_filter_type[step_idx].load(Ordering::Relaxed);
                    hat_filter_cutoff = f32::from_bits(
                        self.tracks[track_idx]
                            .hat_step_filter_cutoff[step_idx]
                            .load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    hat_filter_resonance = f32::from_bits(
                        self.tracks[track_idx]
                            .hat_step_filter_resonance[step_idx]
                            .load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                }

                if self.tracks[track_idx].crash_step_override_enabled[step_idx]
                    .load(Ordering::Relaxed)
                {
                    crash_pitch = f32::from_bits(
                        self.tracks[track_idx]
                            .crash_step_pitch[step_idx]
                            .load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    crash_decay = f32::from_bits(
                        self.tracks[track_idx]
                            .crash_step_decay[step_idx]
                            .load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    crash_tone = f32::from_bits(
                        self.tracks[track_idx]
                            .crash_step_tone[step_idx]
                            .load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    crash_drive = f32::from_bits(
                        self.tracks[track_idx]
                            .crash_step_drive[step_idx]
                            .load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    crash_level = f32::from_bits(
                        self.tracks[track_idx]
                            .crash_step_level[step_idx]
                            .load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    crash_filter_type = self.tracks[track_idx]
                        .crash_step_filter_type[step_idx]
                        .load(Ordering::Relaxed);
                    crash_filter_cutoff = f32::from_bits(
                        self.tracks[track_idx]
                            .crash_step_filter_cutoff[step_idx]
                            .load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                    crash_filter_resonance = f32::from_bits(
                        self.tracks[track_idx]
                            .crash_step_filter_resonance[step_idx]
                            .load(Ordering::Relaxed),
                    )
                    .clamp(0.0, 1.0);
                }
            }
        }
        let mut samp_labels = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_paths = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_pitch = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_attack = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_decay = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_drive = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_level = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_filter_type = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_filter_cutoff = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_filter_resonance = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_filter_pre_drive = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_cut_group = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_cut_by = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_prob = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_lane_enabled = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_sequencer_current_step = Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS);
        let mut samp_sequencer_grid =
            Vec::with_capacity(SYNDRM_SAMPLE_CHANNELS * SYNDRM_STEPS);
        for samp_idx in 0..SYNDRM_SAMPLE_CHANNELS {
            samp_labels.push(SharedString::from(format!("Samp {}", samp_idx + 1)));
            let path_label = if let Some(guard) = self.tracks[track_idx].samp_sample_path[samp_idx].try_lock() {
                if let Some(path) = guard.as_ref() {
                    let label = Path::new(path)
                        .file_name()
                        .map(|name| name.to_string_lossy().to_string())
                        .unwrap_or_else(|| path.clone());
                    SharedString::from(truncate_label(
                        &label,
                        SYNDRM_SAMPLE_LABEL_MAX_CHARS,
                        SYNDRM_SAMPLE_LABEL_ELLIPSES,
                    ))
                } else {
                    SharedString::from("")
                }
            } else {
                SharedString::from("")
            };
            samp_paths.push(path_label);
            samp_pitch.push(f32::from_bits(
                self.tracks[track_idx].samp_pitch[samp_idx].load(Ordering::Relaxed),
            ));
            samp_attack.push(f32::from_bits(
                self.tracks[track_idx].samp_attack[samp_idx].load(Ordering::Relaxed),
            ));
            samp_decay.push(f32::from_bits(
                self.tracks[track_idx].samp_decay[samp_idx].load(Ordering::Relaxed),
            ));
            samp_drive.push(f32::from_bits(
                self.tracks[track_idx].samp_drive[samp_idx].load(Ordering::Relaxed),
            ));
            samp_level.push(f32::from_bits(
                self.tracks[track_idx].samp_level[samp_idx].load(Ordering::Relaxed),
            ));
            samp_filter_type.push(
                self.tracks[track_idx].samp_filter_type[samp_idx].load(Ordering::Relaxed) as i32,
            );
            samp_filter_cutoff.push(f32::from_bits(
                self.tracks[track_idx].samp_filter_cutoff[samp_idx].load(Ordering::Relaxed),
            ));
            samp_filter_resonance.push(f32::from_bits(
                self.tracks[track_idx].samp_filter_resonance[samp_idx].load(Ordering::Relaxed),
            ));
            samp_filter_pre_drive.push(
                self.tracks[track_idx].samp_filter_pre_drive[samp_idx].load(Ordering::Relaxed),
            );
            samp_cut_group.push(self.tracks[track_idx].samp_cut_group[samp_idx].load(Ordering::Relaxed) as f32);
            samp_cut_by.push(self.tracks[track_idx].samp_cut_by[samp_idx].load(Ordering::Relaxed) as f32);
            samp_prob.push(
                f32::from_bits(self.tracks[track_idx].samp_prob[samp_idx].load(Ordering::Relaxed))
                    .clamp(0.0, 1.0),
            );
            samp_lane_enabled.push(
                self.tracks[track_idx].samp_lane_enabled[samp_idx].load(Ordering::Relaxed),
            );
            samp_sequencer_current_step.push(
                self.tracks[track_idx].samp_sequencer_step[samp_idx].load(Ordering::Relaxed),
            );
            for step in 0..SYNDRM_STEPS {
                samp_sequencer_grid.push(
                    self.tracks[track_idx].samp_sequencer_grid[samp_idx][step]
                        .load(Ordering::Relaxed),
                );
            }
        }
        let syndrm_page = self.tracks[track_idx].syndrm_page.load(Ordering::Relaxed) as i32;
        let syndrm_edit_lane = self.tracks[track_idx].syndrm_edit_lane.load(Ordering::Relaxed) as i32;
        let syndrm_edit_step = self.tracks[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as i32;
        let syndrm_randomize_amount =
            f32::from_bits(self.tracks[track_idx].syndrm_randomize_amount.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let edit_step = syndrm_edit_step.clamp(0, (SYNDRM_STEPS - 1) as i32) as usize;
        let syndrm_step_override = if syndrm_edit_lane == 0 {
            self.tracks[track_idx].kick_step_override_enabled[edit_step].load(Ordering::Relaxed)
        } else if syndrm_edit_lane == 1 {
            self.tracks[track_idx].snare_step_override_enabled[edit_step].load(Ordering::Relaxed)
        } else if syndrm_edit_lane == 2 {
            self.tracks[track_idx].clap_step_override_enabled[edit_step].load(Ordering::Relaxed)
        } else if syndrm_edit_lane == 3 {
            self.tracks[track_idx].hat_step_override_enabled[edit_step].load(Ordering::Relaxed)
        } else if syndrm_edit_lane == 4 {
            self.tracks[track_idx].perc1_step_override_enabled[edit_step].load(Ordering::Relaxed)
        } else if syndrm_edit_lane == 5 {
            self.tracks[track_idx].perc2_step_override_enabled[edit_step].load(Ordering::Relaxed)
        } else if syndrm_edit_lane == 6 {
            self.tracks[track_idx].crash_step_override_enabled[edit_step].load(Ordering::Relaxed)
        } else if syndrm_edit_lane >= 7 {
            let samp_idx = (syndrm_edit_lane - 7) as usize;
            if samp_idx < SYNDRM_SAMPLE_CHANNELS {
                self.tracks[track_idx].samp_step_override_enabled[samp_idx][edit_step]
                    .load(Ordering::Relaxed)
            } else {
                false
            }
        } else {
            false
        };
        let syndrm_step_kick_pitch =
            f32::from_bits(self.tracks[track_idx].kick_step_pitch[edit_step].load(Ordering::Relaxed));
        let syndrm_step_kick_decay =
            f32::from_bits(self.tracks[track_idx].kick_step_decay[edit_step].load(Ordering::Relaxed));
        let syndrm_step_kick_attack =
            f32::from_bits(self.tracks[track_idx].kick_step_attack[edit_step].load(Ordering::Relaxed));
        let syndrm_step_kick_drive =
            f32::from_bits(self.tracks[track_idx].kick_step_drive[edit_step].load(Ordering::Relaxed));
        let syndrm_step_kick_level =
            f32::from_bits(self.tracks[track_idx].kick_step_level[edit_step].load(Ordering::Relaxed));
        let syndrm_step_kick_filter_type =
            self.tracks[track_idx].kick_step_filter_type[edit_step].load(Ordering::Relaxed);
        let syndrm_step_kick_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].kick_step_filter_cutoff[edit_step].load(Ordering::Relaxed));
        let syndrm_step_kick_filter_resonance =
            f32::from_bits(self.tracks[track_idx].kick_step_filter_resonance[edit_step].load(Ordering::Relaxed));
        let syndrm_step_kick_retrig =
            self.tracks[track_idx].kick_step_retrig_enabled[edit_step].load(Ordering::Relaxed);
        let syndrm_step_kick_retrig_division =
            self.tracks[track_idx].kick_step_retrig_division[edit_step].load(Ordering::Relaxed);
        let syndrm_step_snare_tone =
            f32::from_bits(self.tracks[track_idx].snare_step_tone[edit_step].load(Ordering::Relaxed));
        let syndrm_step_snare_decay =
            f32::from_bits(self.tracks[track_idx].snare_step_decay[edit_step].load(Ordering::Relaxed));
        let syndrm_step_snare_snappy =
            f32::from_bits(self.tracks[track_idx].snare_step_snappy[edit_step].load(Ordering::Relaxed));
        let syndrm_step_snare_attack =
            f32::from_bits(self.tracks[track_idx].snare_step_attack[edit_step].load(Ordering::Relaxed));
        let syndrm_step_snare_drive =
            f32::from_bits(self.tracks[track_idx].snare_step_drive[edit_step].load(Ordering::Relaxed));
        let syndrm_step_snare_level =
            f32::from_bits(self.tracks[track_idx].snare_step_level[edit_step].load(Ordering::Relaxed));
        let syndrm_step_snare_filter_type =
            self.tracks[track_idx].snare_step_filter_type[edit_step].load(Ordering::Relaxed);
        let syndrm_step_snare_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].snare_step_filter_cutoff[edit_step].load(Ordering::Relaxed));
        let syndrm_step_snare_filter_resonance =
            f32::from_bits(self.tracks[track_idx].snare_step_filter_resonance[edit_step].load(Ordering::Relaxed));
        let syndrm_step_snare_retrig =
            self.tracks[track_idx].snare_step_retrig_enabled[edit_step].load(Ordering::Relaxed);
        let syndrm_step_snare_retrig_division =
            self.tracks[track_idx].snare_step_retrig_division[edit_step].load(Ordering::Relaxed);
        let syndrm_step_clap_pitch =
            f32::from_bits(self.tracks[track_idx].clap_step_pitch[edit_step].load(Ordering::Relaxed));
        let syndrm_step_clap_decay =
            f32::from_bits(self.tracks[track_idx].clap_step_decay[edit_step].load(Ordering::Relaxed));
        let syndrm_step_clap_tone =
            f32::from_bits(self.tracks[track_idx].clap_step_tone[edit_step].load(Ordering::Relaxed));
        let syndrm_step_clap_drive =
            f32::from_bits(self.tracks[track_idx].clap_step_drive[edit_step].load(Ordering::Relaxed));
        let syndrm_step_clap_level =
            f32::from_bits(self.tracks[track_idx].clap_step_level[edit_step].load(Ordering::Relaxed));
        let syndrm_step_clap_filter_type =
            self.tracks[track_idx].clap_step_filter_type[edit_step].load(Ordering::Relaxed);
        let syndrm_step_clap_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].clap_step_filter_cutoff[edit_step].load(Ordering::Relaxed));
        let syndrm_step_clap_filter_resonance =
            f32::from_bits(self.tracks[track_idx].clap_step_filter_resonance[edit_step].load(Ordering::Relaxed));
        let syndrm_step_clap_retrig =
            self.tracks[track_idx].clap_step_retrig_enabled[edit_step].load(Ordering::Relaxed);
        let syndrm_step_clap_retrig_division =
            self.tracks[track_idx].clap_step_retrig_division[edit_step].load(Ordering::Relaxed);
        let syndrm_step_hat_pitch =
            f32::from_bits(self.tracks[track_idx].hat_step_pitch[edit_step].load(Ordering::Relaxed));
        let syndrm_step_hat_decay =
            f32::from_bits(self.tracks[track_idx].hat_step_decay[edit_step].load(Ordering::Relaxed));
        let syndrm_step_hat_tone =
            f32::from_bits(self.tracks[track_idx].hat_step_tone[edit_step].load(Ordering::Relaxed));
        let syndrm_step_hat_drive =
            f32::from_bits(self.tracks[track_idx].hat_step_drive[edit_step].load(Ordering::Relaxed));
        let syndrm_step_hat_level =
            f32::from_bits(self.tracks[track_idx].hat_step_level[edit_step].load(Ordering::Relaxed));
        let syndrm_step_hat_filter_type =
            self.tracks[track_idx].hat_step_filter_type[edit_step].load(Ordering::Relaxed);
        let syndrm_step_hat_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].hat_step_filter_cutoff[edit_step].load(Ordering::Relaxed));
        let syndrm_step_hat_filter_resonance =
            f32::from_bits(self.tracks[track_idx].hat_step_filter_resonance[edit_step].load(Ordering::Relaxed));
        let syndrm_step_hat_retrig =
            self.tracks[track_idx].hat_step_retrig_enabled[edit_step].load(Ordering::Relaxed);
        let syndrm_step_hat_retrig_division =
            self.tracks[track_idx].hat_step_retrig_division[edit_step].load(Ordering::Relaxed);
        let syndrm_step_perc1_pitch =
            f32::from_bits(self.tracks[track_idx].perc1_step_pitch[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc1_decay =
            f32::from_bits(self.tracks[track_idx].perc1_step_decay[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc1_tone =
            f32::from_bits(self.tracks[track_idx].perc1_step_tone[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc1_drive =
            f32::from_bits(self.tracks[track_idx].perc1_step_drive[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc1_level =
            f32::from_bits(self.tracks[track_idx].perc1_step_level[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc1_filter_type =
            self.tracks[track_idx].perc1_step_filter_type[edit_step].load(Ordering::Relaxed);
        let syndrm_step_perc1_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].perc1_step_filter_cutoff[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc1_filter_resonance =
            f32::from_bits(self.tracks[track_idx].perc1_step_filter_resonance[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc1_retrig =
            self.tracks[track_idx].perc1_step_retrig_enabled[edit_step].load(Ordering::Relaxed);
        let syndrm_step_perc1_retrig_division =
            self.tracks[track_idx].perc1_step_retrig_division[edit_step].load(Ordering::Relaxed);
        let syndrm_step_perc2_pitch =
            f32::from_bits(self.tracks[track_idx].perc2_step_pitch[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc2_decay =
            f32::from_bits(self.tracks[track_idx].perc2_step_decay[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc2_tone =
            f32::from_bits(self.tracks[track_idx].perc2_step_tone[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc2_drive =
            f32::from_bits(self.tracks[track_idx].perc2_step_drive[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc2_level =
            f32::from_bits(self.tracks[track_idx].perc2_step_level[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc2_filter_type =
            self.tracks[track_idx].perc2_step_filter_type[edit_step].load(Ordering::Relaxed);
        let syndrm_step_perc2_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].perc2_step_filter_cutoff[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc2_filter_resonance =
            f32::from_bits(self.tracks[track_idx].perc2_step_filter_resonance[edit_step].load(Ordering::Relaxed));
        let syndrm_step_perc2_retrig =
            self.tracks[track_idx].perc2_step_retrig_enabled[edit_step].load(Ordering::Relaxed);
        let syndrm_step_perc2_retrig_division =
            self.tracks[track_idx].perc2_step_retrig_division[edit_step].load(Ordering::Relaxed);
        let syndrm_step_crash_pitch =
            f32::from_bits(self.tracks[track_idx].crash_step_pitch[edit_step].load(Ordering::Relaxed));
        let syndrm_step_crash_decay =
            f32::from_bits(self.tracks[track_idx].crash_step_decay[edit_step].load(Ordering::Relaxed));
        let syndrm_step_crash_tone =
            f32::from_bits(self.tracks[track_idx].crash_step_tone[edit_step].load(Ordering::Relaxed));
        let syndrm_step_crash_drive =
            f32::from_bits(self.tracks[track_idx].crash_step_drive[edit_step].load(Ordering::Relaxed));
        let syndrm_step_crash_level =
            f32::from_bits(self.tracks[track_idx].crash_step_level[edit_step].load(Ordering::Relaxed));
        let syndrm_step_crash_filter_type =
            self.tracks[track_idx].crash_step_filter_type[edit_step].load(Ordering::Relaxed);
        let syndrm_step_crash_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].crash_step_filter_cutoff[edit_step].load(Ordering::Relaxed));
        let syndrm_step_crash_filter_resonance =
            f32::from_bits(self.tracks[track_idx].crash_step_filter_resonance[edit_step].load(Ordering::Relaxed));
        let syndrm_step_crash_retrig =
            self.tracks[track_idx].crash_step_retrig_enabled[edit_step].load(Ordering::Relaxed);
        let syndrm_step_crash_retrig_division =
            self.tracks[track_idx].crash_step_retrig_division[edit_step].load(Ordering::Relaxed);
        let mut syndrm_step_samp_pitch = 0.5;
        let mut syndrm_step_samp_attack = 0.0;
        let mut syndrm_step_samp_decay = 0.5;
        let mut syndrm_step_samp_drive = 0.0;
        let mut syndrm_step_samp_level = 0.8;
        let mut syndrm_step_samp_filter_type = 0;
        let mut syndrm_step_samp_filter_cutoff = 0.7;
        let mut syndrm_step_samp_filter_resonance = 0.2;
        let mut syndrm_step_samp_retrig = false;
        let mut syndrm_step_samp_retrig_division = 2;
        if syndrm_edit_lane >= 7 {
            let samp_idx = (syndrm_edit_lane - 7) as usize;
            if samp_idx < SYNDRM_SAMPLE_CHANNELS {
                syndrm_step_samp_pitch = f32::from_bits(
                    self.tracks[track_idx].samp_step_pitch[samp_idx][edit_step]
                        .load(Ordering::Relaxed),
                );
                syndrm_step_samp_attack = f32::from_bits(
                    self.tracks[track_idx].samp_step_attack[samp_idx][edit_step]
                        .load(Ordering::Relaxed),
                );
                syndrm_step_samp_decay = f32::from_bits(
                    self.tracks[track_idx].samp_step_decay[samp_idx][edit_step]
                        .load(Ordering::Relaxed),
                );
                syndrm_step_samp_drive = f32::from_bits(
                    self.tracks[track_idx].samp_step_drive[samp_idx][edit_step]
                        .load(Ordering::Relaxed),
                );
                syndrm_step_samp_level = f32::from_bits(
                    self.tracks[track_idx].samp_step_level[samp_idx][edit_step]
                        .load(Ordering::Relaxed),
                );
                syndrm_step_samp_filter_type = self.tracks[track_idx].samp_step_filter_type[samp_idx]
                    [edit_step]
                    .load(Ordering::Relaxed) as i32;
                syndrm_step_samp_filter_cutoff = f32::from_bits(
                    self.tracks[track_idx].samp_step_filter_cutoff[samp_idx][edit_step]
                        .load(Ordering::Relaxed),
                );
                syndrm_step_samp_filter_resonance = f32::from_bits(
                    self.tracks[track_idx].samp_step_filter_resonance[samp_idx][edit_step]
                        .load(Ordering::Relaxed),
                );
                syndrm_step_samp_retrig = self.tracks[track_idx].samp_step_retrig_enabled[samp_idx]
                    [edit_step]
                    .load(Ordering::Relaxed);
                syndrm_step_samp_retrig_division = self.tracks[track_idx]
                    .samp_step_retrig_division[samp_idx][edit_step]
                    .load(Ordering::Relaxed);
            }
        }
        let syndrm_step_kick_retrig_division_index =
            if syndrm_step_kick_retrig_division <= 2 { 0 } else { 1 };
        let syndrm_step_snare_retrig_division_index =
            if syndrm_step_snare_retrig_division <= 2 { 0 } else { 1 };
        let syndrm_step_clap_retrig_division_index =
            if syndrm_step_clap_retrig_division <= 2 { 0 } else { 1 };
        let syndrm_step_hat_retrig_division_index =
            if syndrm_step_hat_retrig_division <= 2 { 0 } else { 1 };
        let syndrm_step_perc1_retrig_division_index =
            if syndrm_step_perc1_retrig_division <= 2 { 0 } else { 1 };
        let syndrm_step_perc2_retrig_division_index =
            if syndrm_step_perc2_retrig_division <= 2 { 0 } else { 1 };
        let syndrm_step_crash_retrig_division_index =
            if syndrm_step_crash_retrig_division <= 2 { 0 } else { 1 };
        let syndrm_step_samp_retrig_division_index =
            if syndrm_step_samp_retrig_division <= 2 { 0 } else { 1 };

        let fmmi_car_wave = self.tracks[track_idx].fmmi_car_wave.load(Ordering::Relaxed) as i32;
        let fmmi_car_freq =
            f32::from_bits(self.tracks[track_idx].fmmi_car_freq.load(Ordering::Relaxed));
        let fmmi_car_detune =
            f32::from_bits(self.tracks[track_idx].fmmi_car_detune.load(Ordering::Relaxed));
        let fmmi_mod_wave = self.tracks[track_idx].fmmi_mod_wave.load(Ordering::Relaxed) as i32;
        let fmmi_mod_mode = self.tracks[track_idx].fmmi_mod_mode.load(Ordering::Relaxed) as i32;
        let fmmi_mod_value =
            f32::from_bits(self.tracks[track_idx].fmmi_mod_value.load(Ordering::Relaxed));
        let fmmi_mod_detune =
            f32::from_bits(self.tracks[track_idx].fmmi_mod_detune.load(Ordering::Relaxed));
        let fmmi_index =
            f32::from_bits(self.tracks[track_idx].fmmi_index.load(Ordering::Relaxed));
        let fmmi_feedback =
            f32::from_bits(self.tracks[track_idx].fmmi_feedback.load(Ordering::Relaxed));
        let fmmi_drive =
            f32::from_bits(self.tracks[track_idx].fmmi_drive.load(Ordering::Relaxed));
        let fmmi_out_level =
            f32::from_bits(self.tracks[track_idx].fmmi_out_level.load(Ordering::Relaxed));
        let fmmi_amp_attack =
            f32::from_bits(self.tracks[track_idx].fmmi_amp_attack.load(Ordering::Relaxed));
        let fmmi_amp_decay =
            f32::from_bits(self.tracks[track_idx].fmmi_amp_decay.load(Ordering::Relaxed));
        let fmmi_amp_sustain =
            f32::from_bits(self.tracks[track_idx].fmmi_amp_sustain.load(Ordering::Relaxed));
        let fmmi_amp_release =
            f32::from_bits(self.tracks[track_idx].fmmi_amp_release.load(Ordering::Relaxed));
        let fmmi_prob = (f32::from_bits(self.tracks[track_idx].fmmi_prob.load(Ordering::Relaxed))
            .clamp(0.0, 1.0))
            * 100.0;
        let fmmi_poly_enabled =
            self.tracks[track_idx].fmmi_poly_enabled.load(Ordering::Relaxed);
        let fmmi_sequencer_current_step =
            self.tracks[track_idx].fmmi_sequencer_step.load(Ordering::Relaxed);
        let mut fmmi_sequencer_grid = Vec::with_capacity(FMMI_STEPS);
        let mut fmmi_step_note_labels: Vec<SharedString> = Vec::with_capacity(FMMI_STEPS);
        for i in 0..FMMI_STEPS {
            fmmi_sequencer_grid
                .push(self.tracks[track_idx].fmmi_sequencer_grid[i].load(Ordering::Relaxed));
            let note = self.tracks[track_idx].fmmi_step_note[i].load(Ordering::Relaxed);
            let label = fmmi_midi_to_label(note).unwrap_or_default();
            fmmi_step_note_labels.push(SharedString::from(label));
        }
        let fmmi_page = self.tracks[track_idx].fmmi_page.load(Ordering::Relaxed) as i32;
        let fmmi_edit_step =
            self.tracks[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as i32;
        let fmmi_edit_idx = fmmi_edit_step.clamp(0, (FMMI_STEPS - 1) as i32) as usize;
        let fmmi_step_note = self.tracks[track_idx].fmmi_step_note[fmmi_edit_idx]
            .load(Ordering::Relaxed);
        let fmmi_step_note_index = if fmmi_step_note >= FMMI_NOTE_BASE
            && fmmi_step_note <= FMMI_NOTE_MAX
        {
            (fmmi_step_note - FMMI_NOTE_BASE + 1) as i32
        } else {
            0
        };
        let fmmi_step_car_wave = {
            let wave = self.tracks[track_idx].fmmi_step_car_wave[fmmi_edit_idx]
                .load(Ordering::Relaxed);
            if (0..=3).contains(&wave) { wave + 1 } else { 0 }
        };
        let fmmi_step_mod_wave = {
            let wave = self.tracks[track_idx].fmmi_step_mod_wave[fmmi_edit_idx]
                .load(Ordering::Relaxed);
            if (0..=3).contains(&wave) { wave + 1 } else { 0 }
        };
        let fmmi_step_mod_mode = {
            let mode = self.tracks[track_idx].fmmi_step_mod_mode[fmmi_edit_idx]
                .load(Ordering::Relaxed);
            if (0..=1).contains(&mode) { mode + 1 } else { 0 }
        };
        let fmmi_step_car_freq = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_car_freq[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { fmmi_car_freq }
        };
        let fmmi_step_car_detune = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_car_detune[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { fmmi_car_detune }
        };
        let fmmi_step_mod_value = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_mod_value[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { fmmi_mod_value }
        };
        let fmmi_step_mod_detune = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_mod_detune[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { fmmi_mod_detune }
        };
        let fmmi_step_index = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_index[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { fmmi_index }
        };
        let fmmi_step_feedback = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_feedback[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { fmmi_feedback }
        };
        let fmmi_step_drive = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_drive[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { fmmi_drive }
        };
        let fmmi_step_out_level = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_out_level[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { fmmi_out_level }
        };
        let fmmi_step_amp_attack = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_amp_attack[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { fmmi_amp_attack }
        };
        let fmmi_step_amp_decay = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_amp_decay[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { fmmi_amp_decay }
        };
        let fmmi_step_amp_sustain = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_amp_sustain[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { fmmi_amp_sustain }
        };
        let fmmi_step_amp_release = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_amp_release[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { fmmi_amp_release }
        };
        let tempo_raw = f32::from_bits(self.global_tempo.load(Ordering::Relaxed));
        let tempo = if tempo_raw.is_finite() {
            tempo_raw.clamp(20.0, 240.0)
        } else {
            120.0
        };
        let master_sr = self.tracks[track_idx]
            .sample_rate
            .load(Ordering::Relaxed)
            .max(1) as f32;
        let mut samples_per_step = (master_sr * 60.0) / (tempo * 4.0);
        if !samples_per_step.is_finite() || samples_per_step <= 0.0 {
            samples_per_step = (master_sr * 60.0) / (120.0 * 4.0);
        }
        let default_gate_ms = (samples_per_step / master_sr) * 1000.0;
        let fmmi_step_gate_length = {
            let v = f32::from_bits(
                self.tracks[track_idx].fmmi_step_gate_length[fmmi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { default_gate_ms }
        };
        let fmmi_rand_note_enabled =
            self.tracks[track_idx].fmmi_rand_note_enabled.load(Ordering::Relaxed);
        let fmmi_rand_car_wave_enabled =
            self.tracks[track_idx].fmmi_rand_car_wave_enabled.load(Ordering::Relaxed);
        let fmmi_rand_mod_wave_enabled =
            self.tracks[track_idx].fmmi_rand_mod_wave_enabled.load(Ordering::Relaxed);
        let fmmi_rand_mod_mode_enabled =
            self.tracks[track_idx].fmmi_rand_mod_mode_enabled.load(Ordering::Relaxed);
        let fmmi_rand_car_freq_enabled =
            self.tracks[track_idx].fmmi_rand_car_freq_enabled.load(Ordering::Relaxed);
        let fmmi_rand_car_detune_enabled =
            self.tracks[track_idx].fmmi_rand_car_detune_enabled.load(Ordering::Relaxed);
        let fmmi_rand_mod_value_enabled =
            self.tracks[track_idx].fmmi_rand_mod_value_enabled.load(Ordering::Relaxed);
        let fmmi_rand_mod_detune_enabled =
            self.tracks[track_idx].fmmi_rand_mod_detune_enabled.load(Ordering::Relaxed);
        let fmmi_rand_index_enabled =
            self.tracks[track_idx].fmmi_rand_index_enabled.load(Ordering::Relaxed);
        let fmmi_rand_feedback_enabled =
            self.tracks[track_idx].fmmi_rand_feedback_enabled.load(Ordering::Relaxed);
        let fmmi_rand_drive_enabled =
            self.tracks[track_idx].fmmi_rand_drive_enabled.load(Ordering::Relaxed);
        let fmmi_rand_out_level_enabled =
            self.tracks[track_idx].fmmi_rand_out_level_enabled.load(Ordering::Relaxed);
        let fmmi_rand_amp_attack_enabled =
            self.tracks[track_idx].fmmi_rand_amp_attack_enabled.load(Ordering::Relaxed);
        let fmmi_rand_amp_decay_enabled =
            self.tracks[track_idx].fmmi_rand_amp_decay_enabled.load(Ordering::Relaxed);
        let fmmi_rand_amp_sustain_enabled =
            self.tracks[track_idx].fmmi_rand_amp_sustain_enabled.load(Ordering::Relaxed);
        let fmmi_rand_amp_release_enabled =
            self.tracks[track_idx].fmmi_rand_amp_release_enabled.load(Ordering::Relaxed);
        let fmmi_rand_gate_length_enabled =
            self.tracks[track_idx].fmmi_rand_gate_length_enabled.load(Ordering::Relaxed);
        let fmmi_randomize_amount =
            f32::from_bits(self.tracks[track_idx].fmmi_randomize_amount.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let fmmi_randomize_steps_amount = f32::from_bits(
            self.tracks[track_idx]
                .fmmi_randomize_steps_amount
                .load(Ordering::Relaxed),
        )
        .clamp(0.0, 1.0);
        let fmmi_scale_index =
            self.tracks[track_idx].fmmi_scale_index.load(Ordering::Relaxed) as usize;
        let fmmi_scales = fmmi_scales();
        let fmmi_scale_index = if fmmi_scale_index < fmmi_scales.len() {
            fmmi_scale_index
        } else {
            0
        };
        let fmmi_scale_mask = fmmi_scale_mask(&fmmi_scales[fmmi_scale_index].notes);

        let monomi_osc_wave: Vec<i32> = (0..3)
            .map(|i| self.tracks[track_idx].monomi_osc_wave[i].load(Ordering::Relaxed) as i32)
            .collect();
        let monomi_osc_octave: Vec<i32> = (0..3)
            .map(|i| self.tracks[track_idx].monomi_osc_octave[i].load(Ordering::Relaxed) as i32)
            .collect();
        let monomi_osc_detune: Vec<f32> = (0..3)
            .map(|i| f32::from_bits(self.tracks[track_idx].monomi_osc_detune[i].load(Ordering::Relaxed)))
            .collect();
        let monomi_osc_mix: Vec<f32> = (0..3)
            .map(|i| f32::from_bits(self.tracks[track_idx].monomi_osc_mix[i].load(Ordering::Relaxed)))
            .collect();
        let monomi_osc_pwm: Vec<f32> = (0..3)
            .map(|i| f32::from_bits(self.tracks[track_idx].monomi_osc_pwm[i].load(Ordering::Relaxed)))
            .collect();

        let monomi_cutoff =
            f32::from_bits(self.tracks[track_idx].monomi_cutoff.load(Ordering::Relaxed));
        let monomi_filter_mode =
            self.tracks[track_idx].monomi_filter_mode.load(Ordering::Relaxed) as i32;
        let monomi_resonance_max = if monomi_filter_mode == 0 { 1.0 } else { 8.0 };
        let monomi_resonance =
            f32::from_bits(self.tracks[track_idx].monomi_resonance.load(Ordering::Relaxed))
                .clamp(0.0, monomi_resonance_max);
        let monomi_filter_morph =
            f32::from_bits(self.tracks[track_idx].monomi_filter_morph.load(Ordering::Relaxed));
        let monomi_volume =
            f32::from_bits(self.tracks[track_idx].monomi_volume.load(Ordering::Relaxed));
        let monomi_amp_attack =
            f32::from_bits(self.tracks[track_idx].monomi_amp_attack.load(Ordering::Relaxed));
        let monomi_amp_decay =
            f32::from_bits(self.tracks[track_idx].monomi_amp_decay.load(Ordering::Relaxed));
        let monomi_amp_sustain =
            f32::from_bits(self.tracks[track_idx].monomi_amp_sustain.load(Ordering::Relaxed));
        let monomi_amp_release =
            f32::from_bits(self.tracks[track_idx].monomi_amp_release.load(Ordering::Relaxed));
        let monomi_filter_attack =
            f32::from_bits(self.tracks[track_idx].monomi_filter_attack.load(Ordering::Relaxed));
        let monomi_filter_decay =
            f32::from_bits(self.tracks[track_idx].monomi_filter_decay.load(Ordering::Relaxed));
        let monomi_filter_sustain =
            f32::from_bits(self.tracks[track_idx].monomi_filter_sustain.load(Ordering::Relaxed));
        let monomi_filter_release =
            f32::from_bits(self.tracks[track_idx].monomi_filter_release.load(Ordering::Relaxed));
        let monomi_filter_intensity =
            f32::from_bits(self.tracks[track_idx].monomi_filter_intensity.load(Ordering::Relaxed));
        let monomi_filter_polarity =
            f32::from_bits(self.tracks[track_idx].monomi_filter_polarity.load(Ordering::Relaxed));
        let monomi_filter_saturation =
            f32::from_bits(self.tracks[track_idx].monomi_filter_saturation.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let monomi_filter_sat_env =
            f32::from_bits(self.tracks[track_idx].monomi_filter_sat_env.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let monomi_filter_sat_pre =
            self.tracks[track_idx].monomi_filter_sat_pre.load(Ordering::Relaxed);
        let monomi_mix_comp_mode =
            self.tracks[track_idx].monomi_mix_comp_mode.load(Ordering::Relaxed) as i32;
        let monomi_glide =
            f32::from_bits(self.tracks[track_idx].monomi_glide.load(Ordering::Relaxed));
        let monomi_prob =
            f32::from_bits(self.tracks[track_idx].monomi_prob.load(Ordering::Relaxed)).clamp(0.0, 1.0) * 100.0;

        let monomi_lfo_shape: Vec<i32> = (0..3)
            .map(|i| self.tracks[track_idx].monomi_lfo_shape[i].load(Ordering::Relaxed) as i32)
            .collect();
        let monomi_lfo_target: Vec<i32> = (0..3)
            .map(|i| self.tracks[track_idx].monomi_lfo_target[i].load(Ordering::Relaxed) as i32)
            .collect();
        let monomi_lfo_amount: Vec<f32> = (0..3)
            .map(|i| f32::from_bits(self.tracks[track_idx].monomi_lfo_amount[i].load(Ordering::Relaxed)))
            .collect();
        let monomi_lfo_rate: Vec<f32> = (0..3)
            .map(|i| f32::from_bits(self.tracks[track_idx].monomi_lfo_rate[i].load(Ordering::Relaxed)))
            .collect();
        let monomi_lfo_sync: Vec<bool> = (0..3)
            .map(|i| self.tracks[track_idx].monomi_lfo_sync[i].load(Ordering::Relaxed))
            .collect();
        let monomi_lfo_steps: Vec<i32> = (0..3)
            .map(|i| self.tracks[track_idx].monomi_lfo_steps[i].load(Ordering::Relaxed) as i32)
            .collect();

        let monomi_sequencer_current_step =
            self.tracks[track_idx].monomi_sequencer_step.load(Ordering::Relaxed);
        let mut monomi_sequencer_grid = Vec::with_capacity(MONOMI_STEPS);
        let mut monomi_step_note_labels: Vec<SharedString> = Vec::with_capacity(MONOMI_STEPS);
        for i in 0..MONOMI_STEPS {
            monomi_sequencer_grid
                .push(self.tracks[track_idx].monomi_sequencer_grid[i].load(Ordering::Relaxed));
            let note = self.tracks[track_idx].monomi_step_note[i].load(Ordering::Relaxed);
            let label = fmmi_midi_to_label(note).unwrap_or_default();
            monomi_step_note_labels.push(SharedString::from(label));
        }
        let monomi_page = self.tracks[track_idx].monomi_page.load(Ordering::Relaxed) as i32;
        let monomi_edit_step =
            self.tracks[track_idx].monomi_edit_step.load(Ordering::Relaxed) as i32;
        let monomi_edit_idx = monomi_edit_step.clamp(0, (MONOMI_STEPS - 1) as i32) as usize;
        let monomi_step_note = self.tracks[track_idx].monomi_step_note[monomi_edit_idx]
            .load(Ordering::Relaxed);
        let monomi_step_note_index = if monomi_step_note >= MONOMI_NOTE_BASE
            && monomi_step_note <= MONOMI_NOTE_MAX
        {
            (monomi_step_note - MONOMI_NOTE_BASE + 1) as i32
        } else {
            0
        };
        let monomi_step_cutoff = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_cutoff[monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_cutoff }
        };
        let monomi_step_resonance = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_resonance[monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 {
                v.clamp(0.0, monomi_resonance_max)
            } else {
                monomi_resonance
            }
        };
        let monomi_step_env_attack = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_env_attack[monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_amp_attack }
        };
        let monomi_step_env_decay = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_env_decay[monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_amp_decay }
        };
        let monomi_step_env_sustain = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_env_sustain[monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_amp_sustain }
        };
        let monomi_step_env_release = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_env_release[monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_amp_release }
        };
        let monomi_step_gate = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_gate[monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { 1.0 }
        };
        let monomi_step_filter_morph = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_filter_morph[monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_filter_morph }
        };
        let monomi_step_glide = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_glide[monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_glide }
        };
        let monomi_step_osc1_mix = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_osc_mix[0][monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_osc_mix[0] }
        };
        let monomi_step_osc2_mix = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_osc_mix[1][monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_osc_mix[1] }
        };
        let monomi_step_osc3_mix = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_osc_mix[2][monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_osc_mix[2] }
        };
        let monomi_step_osc1_detune = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_osc_detune[0][monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_osc_detune[0] }
        };
        let monomi_step_osc2_detune = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_osc_detune[1][monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_osc_detune[1] }
        };
        let monomi_step_osc3_detune = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_osc_detune[2][monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_osc_detune[2] }
        };
        let monomi_step_osc1_pwm = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_osc_pwm[0][monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_osc_pwm[0] }
        };
        let monomi_step_osc2_pwm = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_osc_pwm[1][monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_osc_pwm[1] }
        };
        let monomi_step_osc3_pwm = {
            let v = f32::from_bits(
                self.tracks[track_idx].monomi_step_osc_pwm[2][monomi_edit_idx]
                    .load(Ordering::Relaxed),
            );
            if v >= 0.0 { v } else { monomi_osc_pwm[2] }
        };
        let monomi_rand_cutoff =
            self.tracks[track_idx].monomi_rand_cutoff.load(Ordering::Relaxed);
        let monomi_rand_resonance =
            self.tracks[track_idx].monomi_rand_resonance.load(Ordering::Relaxed);
        let monomi_rand_env_attack =
            self.tracks[track_idx].monomi_rand_env_attack.load(Ordering::Relaxed);
        let monomi_rand_env_decay =
            self.tracks[track_idx].monomi_rand_env_decay.load(Ordering::Relaxed);
        let monomi_rand_env_sustain =
            self.tracks[track_idx].monomi_rand_env_sustain.load(Ordering::Relaxed);
        let monomi_rand_env_release =
            self.tracks[track_idx].monomi_rand_env_release.load(Ordering::Relaxed);
        let monomi_rand_gate =
            self.tracks[track_idx].monomi_rand_gate.load(Ordering::Relaxed);
        let monomi_rand_filter_morph =
            self.tracks[track_idx].monomi_rand_filter_morph.load(Ordering::Relaxed);
        let monomi_rand_glide =
            self.tracks[track_idx].monomi_rand_glide.load(Ordering::Relaxed);
        let monomi_rand_osc1_mix =
            self.tracks[track_idx].monomi_rand_osc_mix[0].load(Ordering::Relaxed);
        let monomi_rand_osc2_mix =
            self.tracks[track_idx].monomi_rand_osc_mix[1].load(Ordering::Relaxed);
        let monomi_rand_osc3_mix =
            self.tracks[track_idx].monomi_rand_osc_mix[2].load(Ordering::Relaxed);
        let monomi_rand_osc1_detune =
            self.tracks[track_idx].monomi_rand_osc_detune[0].load(Ordering::Relaxed);
        let monomi_rand_osc2_detune =
            self.tracks[track_idx].monomi_rand_osc_detune[1].load(Ordering::Relaxed);
        let monomi_rand_osc3_detune =
            self.tracks[track_idx].monomi_rand_osc_detune[2].load(Ordering::Relaxed);
        let monomi_rand_osc1_pwm =
            self.tracks[track_idx].monomi_rand_osc_pwm[0].load(Ordering::Relaxed);
        let monomi_rand_osc2_pwm =
            self.tracks[track_idx].monomi_rand_osc_pwm[1].load(Ordering::Relaxed);
        let monomi_rand_osc3_pwm =
            self.tracks[track_idx].monomi_rand_osc_pwm[2].load(Ordering::Relaxed);
        let monomi_randomize_amount =
            f32::from_bits(self.tracks[track_idx].monomi_randomize_amount.load(Ordering::Relaxed))
                .clamp(0.0, 1.0);
        let monomi_scale_index =
            self.tracks[track_idx].monomi_scale_index.load(Ordering::Relaxed) as usize;
        let monomi_scale_index = if monomi_scale_index < fmmi_scales.len() {
            monomi_scale_index
        } else {
            0
        };
        let monomi_scale_mask = monomi_scale_mask(&fmmi_scales[monomi_scale_index].notes);

        let void_base_freq = f32::from_bits(self.tracks[track_idx].void_base_freq.load(Ordering::Relaxed));
        let void_chaos_depth = f32::from_bits(self.tracks[track_idx].void_chaos_depth.load(Ordering::Relaxed));
        let void_entropy = f32::from_bits(self.tracks[track_idx].void_entropy.load(Ordering::Relaxed));
        let void_feedback = f32::from_bits(self.tracks[track_idx].void_feedback.load(Ordering::Relaxed));
        let void_diffusion = f32::from_bits(self.tracks[track_idx].void_diffusion.load(Ordering::Relaxed));
        let void_mod_rate = f32::from_bits(self.tracks[track_idx].void_mod_rate.load(Ordering::Relaxed));
        let void_level = f32::from_bits(self.tracks[track_idx].void_level.load(Ordering::Relaxed));
        let void_pan = f32::from_bits(self.tracks[track_idx].void_pan.load(Ordering::Relaxed));
        let void_width = f32::from_bits(self.tracks[track_idx].void_width.load(Ordering::Relaxed));
        let void_close_decay =
            f32::from_bits(self.tracks[track_idx].void_close_decay.load(Ordering::Relaxed));
        let void_filter_cutoff =
            f32::from_bits(self.tracks[track_idx].void_filter_cutoff.load(Ordering::Relaxed));
        let void_filter_resonance =
            f32::from_bits(self.tracks[track_idx].void_filter_resonance.load(Ordering::Relaxed));
        let void_drive = f32::from_bits(self.tracks[track_idx].void_drive.load(Ordering::Relaxed));
        let void_filter_pre_drive =
            self.tracks[track_idx].void_filter_pre_drive.load(Ordering::Relaxed);
        let void_enabled = self.tracks[track_idx].void_enabled.load(Ordering::Relaxed);

        let play_pos = f32::from_bits(self.tracks[track_idx].play_pos.load(Ordering::Relaxed));
        let total_samples = if let Some(samples) = self.tracks[track_idx].samples.try_lock() {
            samples.get(0).map(|ch| ch.len()).unwrap_or(0)
        } else {
            0
        };
        let sample_rate = self.tracks[track_idx].sample_rate.load(Ordering::Relaxed).max(1);
        let duration_secs = total_samples as f32 / sample_rate as f32;
        let playhead_index = if total_samples > 0 {
            ((play_pos / total_samples as f32) * WAVEFORM_SUMMARY_SIZE as f32) as i32
        } else {
            0
        };

        let waveform = if let Some(summary) = self.tracks[track_idx].waveform_summary.try_lock() {
            summary.clone()
        } else {
            vec![0.0; WAVEFORM_SUMMARY_SIZE]
        };

        let mut tape_video_enabled = self.tracks[track_idx].video_enabled.load(Ordering::Relaxed);
        let mut tape_video_frame = Image::default();
        let mut tape_video_duration = duration_secs;
        if tape_video_enabled {
            if let Some(cache_guard) = self.tracks[track_idx].video_cache.try_lock() {
                if let Some(cache) = cache_guard.as_ref() {
                    if cache.frames.is_empty() || cache.width == 0 || cache.height == 0 {
                        tape_video_enabled = false;
                    } else {
                        if let Some(last_frame) = cache.frames.last() {
                            tape_video_duration = last_frame.timestamp.max(0.0);
                        }
                        let fps = f32::from_bits(
                            self.tracks[track_idx].video_fps.load(Ordering::Relaxed),
                        )
                        .max(1.0);
                        let time_secs = if sample_rate > 0 {
                            (play_pos / sample_rate as f32).max(0.0)
                        } else {
                            0.0
                        };
                        let mut frame_idx = (time_secs * fps).floor() as usize;
                        if frame_idx >= cache.frames.len() {
                            frame_idx = cache.frames.len().saturating_sub(1);
                        }

                        let cache_id =
                            self.tracks[track_idx].video_cache_id.load(Ordering::Relaxed);
                        let mut used_cache = false;
                        if let Some((cached_id, cached_idx, cached_image)) =
                            &self.video_frame_cache[track_idx]
                        {
                            if *cached_id == cache_id && *cached_idx == frame_idx {
                                tape_video_frame = cached_image.clone();
                                used_cache = true;
                            }
                        }

                        if !used_cache {
                            let frame = &cache.frames[frame_idx];
                            let image = image_from_rgba(cache.width, cache.height, &frame.data);
                            tape_video_frame = image.clone();
                            self.video_frame_cache[track_idx] =
                                Some((cache_id, frame_idx, image));
                        }
                    }
                } else {
                    tape_video_enabled = false;
                }
            } else {
                tape_video_enabled = false;
            }
        }

        let oscilloscope = if let Some(scope) = self.visualizer.oscilloscope.try_lock() {
            scope
                .iter()
                .map(|value| {
                    if value.is_finite() {
                        value.clamp(-1.0, 1.0)
                    } else {
                        0.0
                    }
                })
                .collect()
        } else {
            vec![0.0; OSCILLOSCOPE_SAMPLES]
        };
        let spectrum = if let Some(spec) = self.visualizer.spectrum.try_lock() {
            spec.iter()
                .map(|value| if value.is_finite() { value.max(0.0) } else { 0.0 })
                .collect()
        } else {
            vec![0.0; SPECTRUM_BINS]
        };
        let vectorscope_x = if let Some(points) = self.visualizer.vectorscope_x.try_lock() {
            points
                .iter()
                .map(|value| {
                    if value.is_finite() {
                        value.clamp(-1.0, 1.0)
                    } else {
                        0.0
                    }
                })
                .collect()
        } else {
            vec![0.0; VECTORSCOPE_POINTS]
        };
        let vectorscope_y = if let Some(points) = self.visualizer.vectorscope_y.try_lock() {
            points
                .iter()
                .map(|value| {
                    if value.is_finite() {
                        value.clamp(-1.0, 1.0)
                    } else {
                        0.0
                    }
                })
                .collect()
        } else {
            vec![0.0; VECTORSCOPE_POINTS]
        };

        self.ui.set_selected_track((track_idx + 1) as i32);
        self.ui.set_is_playing(is_playing);
        self.ui.set_is_recording(is_recording);
        self.ui.set_gain(gain);
        self.ui.set_master_filter(master_filter);
        self.ui.set_master_comp(master_comp);
        self.ui.set_track_level(track_level);
        self.ui.set_track_muted(track_muted);
        self.ui.set_meter_left(meter_left);
        self.ui.set_meter_right(meter_right);
        self.ui.set_track_meter_left(track_meter_left);
        self.ui.set_track_meter_right(track_meter_right);
        self.ui.set_tape_video_enabled(tape_video_enabled);
        self.ui.set_tape_video_duration(tape_video_duration);
        self.ui.set_tape_video_frame(tape_video_frame);
        self.ui.set_tape_speed(tape_speed);
        self.ui.set_tape_tempo(tape_tempo);
        self.ui.set_tempo_label(SharedString::from(format!("{tape_tempo:.0} BPM")));
        self.ui.set_tape_rate_mode(tape_rate_mode as i32);
        self.ui.set_tape_rotate(tape_rotate);
        self.ui.set_tape_glide(tape_glide);
        self.ui.set_tape_sos(tape_sos);
        self.ui.set_tape_reverse(tape_reverse);
        self.ui.set_tape_freeze(tape_freeze);
        self.ui.set_tape_keylock(tape_keylock);
        self.ui.set_tape_monitor(tape_monitor);
        self.ui.set_tape_overdub(tape_overdub);
        self.ui.set_mosaic_pitch(mosaic_pitch);
        self.ui.set_mosaic_rate(mosaic_rate);
        self.ui.set_mosaic_size(mosaic_size);
        self.ui.set_mosaic_contour(mosaic_contour);
        self.ui.set_mosaic_warp(mosaic_warp);
        self.ui.set_mosaic_spray(mosaic_spray);
        self.ui.set_mosaic_pattern(mosaic_pattern);
        self.ui.set_mosaic_wet(mosaic_wet);
        self.ui.set_mosaic_post_gain(mosaic_post_gain);
        self.ui.set_mosaic_spatial(mosaic_spatial);
        self.ui.set_mosaic_detune(mosaic_detune);
        self.ui.set_mosaic_rand_rate(mosaic_rand_rate);
        self.ui.set_mosaic_rand_size(mosaic_rand_size);
        self.ui.set_mosaic_sos(mosaic_sos);
        self.ui.set_mosaic_grain_markers(ModelRc::from(std::rc::Rc::new(
            VecModel::from(mosaic_grain_markers),
        )));
        self.ui.set_ring_cutoff(ring_cutoff);
        self.ui.set_ring_resonance(ring_resonance);
        self.ui.set_ring_decay(ring_decay);
        self.ui.set_ring_pitch(ring_pitch);
        self.ui.set_ring_tone(ring_tone);
        self.ui.set_ring_tilt(ring_tilt);
        self.ui.set_ring_slope(ring_slope);
        self.ui.set_ring_wet(ring_wet);
        self.ui.set_ring_detune(ring_detune);
        self.ui.set_ring_waves(ring_waves);
        self.ui.set_ring_waves_rate(ring_waves_rate);
        self.ui.set_ring_waves_rate_mode(ring_waves_rate_mode as i32);
        self.ui.set_ring_noise(ring_noise);
        self.ui.set_ring_noise_rate(ring_noise_rate);
        self.ui.set_ring_noise_rate_mode(ring_noise_rate_mode as i32);
        self.ui.set_ring_scale(ring_scale as i32);
        self.ui.set_ring_pre_post(ring_pre_post);
        self.ui.set_texture_enabled(texture_enabled);
        self.ui.set_texture_gate(texture_gate);
        self.ui.set_texture_drive(texture_drive);
        self.ui.set_texture_compress(texture_compress);
        self.ui.set_texture_crush(texture_crush);
        self.ui.set_texture_tilt(texture_tilt);
        self.ui.set_texture_noise(texture_noise);
        self.ui.set_texture_noise_decay(texture_noise_decay);
        self.ui.set_texture_noise_color(texture_noise_color);
        self.ui.set_texture_wet(texture_wet);
        self.ui.set_texture_post_gain(texture_post_gain);
        self.ui.set_reflect_enabled(reflect_enabled);
        self.ui.set_reflect_freeze(reflect_freeze);
        self.ui.set_reflect_delay(reflect_delay);
        self.ui.set_reflect_time(reflect_time);
        self.ui.set_reflect_time_mode(reflect_time_mode as i32);
        self.ui.set_reflect_reverb(reflect_reverb);
        self.ui.set_reflect_size(reflect_size);
        self.ui.set_reflect_feedback(reflect_feedback);
        self.ui.set_reflect_spread(reflect_spread);
        self.ui.set_reflect_damp(reflect_damp);
        self.ui.set_reflect_decay(reflect_decay);
        self.ui.set_reflect_post_gain(reflect_post_gain);
        self.ui.set_loop_start(loop_start);
        self.ui.set_trigger_start(trigger_start);
        self.ui.set_loop_length(loop_length);
        self.ui.set_loop_xfade(loop_xfade);
        self.ui.set_loop_enabled(loop_enabled);
        self.ui.set_loop_mode(loop_mode as i32);
        self.ui.set_mosaic_enabled(mosaic_enabled);
        self.ui.set_mosaic_loop_lock(mosaic_loop_lock);
        self.ui.set_ring_enabled(ring_enabled);
        self.ui.set_ring_decay_mode(ring_decay_mode as i32);
        self.ui.set_g8_enabled(g8_enabled);
        self.ui.set_g8_rate_index(g8_rate_index as i32);
        self.ui
            .set_g8_steps(ModelRc::from(std::rc::Rc::new(VecModel::from(g8_steps))));
        self.ui.set_modul8_enabled(modul8_enabled);
        self.ui
            .set_modul8_wave(ModelRc::from(std::rc::Rc::new(VecModel::from(modul8_wave))));
        self.ui
            .set_modul8_rate(ModelRc::from(std::rc::Rc::new(VecModel::from(modul8_rate))));
        self.ui
            .set_modul8_sync(ModelRc::from(std::rc::Rc::new(VecModel::from(modul8_sync))));
        self.ui.set_modul8_division(ModelRc::from(std::rc::Rc::new(
            VecModel::from(modul8_division),
        )));
        self.ui
            .set_modul8_amount(ModelRc::from(std::rc::Rc::new(VecModel::from(modul8_amount))));
        self.ui
            .set_modul8_bias(ModelRc::from(std::rc::Rc::new(VecModel::from(modul8_bias))));
        self.ui
            .set_modul8_target(ModelRc::from(std::rc::Rc::new(VecModel::from(modul8_target))));
        self.ui.set_engine_loaded(engine_loaded);
        self.ui.set_active_engine_type(active_engine_type as i32);
        if self.last_modul8_engine_type != Some(active_engine_type)
            || self.last_modul8_track_idx != Some(track_idx)
        {
            self.ui.set_modul8_target_options(ModelRc::new(std::rc::Rc::new(
                VecModel::from(modul8_target_options_for_engine(active_engine_type)),
            )));
            self.last_modul8_engine_type = Some(active_engine_type);
            self.last_modul8_track_idx = Some(track_idx);
        }

        self.ui.set_animate_slot_a_type(animate_slot_types[0] as i32);
        self.ui.set_animate_slot_b_type(animate_slot_types[1] as i32);
        self.ui.set_animate_slot_c_type(animate_slot_types[2] as i32);
        self.ui.set_animate_slot_d_type(animate_slot_types[3] as i32);

        self.ui.set_animate_slot_a_wavetable(animate_slot_wavetables[0] as i32);
        self.ui.set_animate_slot_b_wavetable(animate_slot_wavetables[1] as i32);
        self.ui.set_animate_slot_c_wavetable(animate_slot_wavetables[2] as i32);
        self.ui.set_animate_slot_d_wavetable(animate_slot_wavetables[3] as i32);

        self.ui.set_animate_slot_a_sample(animate_slot_samples[0] as i32);
        self.ui.set_animate_slot_b_sample(animate_slot_samples[1] as i32);
        self.ui.set_animate_slot_c_sample(animate_slot_samples[2] as i32);
        self.ui.set_animate_slot_d_sample(animate_slot_samples[3] as i32);

        self.ui.set_animate_slot_a_coarse(animate_slot_coarse[0]);
        self.ui.set_animate_slot_a_fine(animate_slot_fine[0]);
        self.ui.set_animate_slot_a_level(animate_slot_level[0]);
        self.ui.set_animate_slot_a_pan(animate_slot_pan[0]);

        self.ui.set_animate_slot_b_coarse(animate_slot_coarse[1]);
        self.ui.set_animate_slot_b_fine(animate_slot_fine[1]);
        self.ui.set_animate_slot_b_level(animate_slot_level[1]);
        self.ui.set_animate_slot_b_pan(animate_slot_pan[1]);

        self.ui.set_animate_slot_c_coarse(animate_slot_coarse[2]);
        self.ui.set_animate_slot_c_fine(animate_slot_fine[2]);
        self.ui.set_animate_slot_c_level(animate_slot_level[2]);
        self.ui.set_animate_slot_c_pan(animate_slot_pan[2]);

        self.ui.set_animate_slot_d_coarse(animate_slot_coarse[3]);
        self.ui.set_animate_slot_d_fine(animate_slot_fine[3]);
        self.ui.set_animate_slot_d_level(animate_slot_level[3]);
        self.ui.set_animate_slot_d_pan(animate_slot_pan[3]);
        self.ui
            .set_animate_slot_a_wt_lfo_amount(animate_slot_wt_lfo_amount[0]);
        self.ui
            .set_animate_slot_a_wt_lfo_shape(animate_slot_wt_lfo_shape[0] as i32);
        self.ui
            .set_animate_slot_a_wt_lfo_rate(animate_slot_wt_lfo_rate[0]);
        self.ui
            .set_animate_slot_a_wt_lfo_sync(animate_slot_wt_lfo_sync[0]);
        self.ui
            .set_animate_slot_a_wt_lfo_division(animate_slot_wt_lfo_division[0] as i32);
        self.ui
            .set_animate_slot_b_wt_lfo_amount(animate_slot_wt_lfo_amount[1]);
        self.ui
            .set_animate_slot_b_wt_lfo_shape(animate_slot_wt_lfo_shape[1] as i32);
        self.ui
            .set_animate_slot_b_wt_lfo_rate(animate_slot_wt_lfo_rate[1]);
        self.ui
            .set_animate_slot_b_wt_lfo_sync(animate_slot_wt_lfo_sync[1]);
        self.ui
            .set_animate_slot_b_wt_lfo_division(animate_slot_wt_lfo_division[1] as i32);
        self.ui
            .set_animate_slot_c_wt_lfo_amount(animate_slot_wt_lfo_amount[2]);
        self.ui
            .set_animate_slot_c_wt_lfo_shape(animate_slot_wt_lfo_shape[2] as i32);
        self.ui
            .set_animate_slot_c_wt_lfo_rate(animate_slot_wt_lfo_rate[2]);
        self.ui
            .set_animate_slot_c_wt_lfo_sync(animate_slot_wt_lfo_sync[2]);
        self.ui
            .set_animate_slot_c_wt_lfo_division(animate_slot_wt_lfo_division[2] as i32);
        self.ui
            .set_animate_slot_d_wt_lfo_amount(animate_slot_wt_lfo_amount[3]);
        self.ui
            .set_animate_slot_d_wt_lfo_shape(animate_slot_wt_lfo_shape[3] as i32);
        self.ui
            .set_animate_slot_d_wt_lfo_rate(animate_slot_wt_lfo_rate[3]);
        self.ui
            .set_animate_slot_d_wt_lfo_sync(animate_slot_wt_lfo_sync[3]);
        self.ui
            .set_animate_slot_d_wt_lfo_division(animate_slot_wt_lfo_division[3] as i32);
        self.ui
            .set_animate_slot_a_sample_start(animate_slot_sample_start[0]);
        self.ui
            .set_animate_slot_a_loop_start(animate_slot_loop_start[0]);
        self.ui
            .set_animate_slot_a_loop_end(animate_slot_loop_end[0]);
        self.ui
            .set_animate_slot_b_sample_start(animate_slot_sample_start[1]);
        self.ui
            .set_animate_slot_b_loop_start(animate_slot_loop_start[1]);
        self.ui
            .set_animate_slot_b_loop_end(animate_slot_loop_end[1]);
        self.ui
            .set_animate_slot_c_sample_start(animate_slot_sample_start[2]);
        self.ui
            .set_animate_slot_c_loop_start(animate_slot_loop_start[2]);
        self.ui
            .set_animate_slot_c_loop_end(animate_slot_loop_end[2]);
        self.ui
            .set_animate_slot_d_sample_start(animate_slot_sample_start[3]);
        self.ui
            .set_animate_slot_d_loop_start(animate_slot_loop_start[3]);
        self.ui
            .set_animate_slot_d_loop_end(animate_slot_loop_end[3]);
        self.ui
            .set_animate_slot_a_filter_type(animate_slot_a_filter_type as i32);
        self.ui
            .set_animate_slot_a_filter_cutoff(animate_slot_a_filter_cutoff);
        self.ui
            .set_animate_slot_a_filter_resonance(animate_slot_a_filter_resonance);
        self.ui.set_animate_slot_a_attack(animate_slot_a_attack);
        self.ui.set_animate_slot_a_decay(animate_slot_a_decay);
        self.ui.set_animate_slot_a_sustain(animate_slot_a_sustain);
        self.ui.set_animate_slot_a_release(animate_slot_a_release);

        self.ui.set_animate_vector_x(animate_vector_x);
        self.ui.set_animate_vector_y(animate_vector_y);
        self.ui.set_animate_lfo_x_waveform(animate_lfo_x_waveform as i32);
        self.ui.set_animate_lfo_x_sync(animate_lfo_x_sync);
        self.ui
            .set_animate_lfo_x_division(animate_lfo_x_division as i32);
        self.ui.set_animate_lfo_x_rate(animate_lfo_x_rate);
        self.ui.set_animate_lfo_x_amount(animate_lfo_x_amount);
        self.ui.set_animate_lfo_y_waveform(animate_lfo_y_waveform as i32);
        self.ui.set_animate_lfo_y_sync(animate_lfo_y_sync);
        self.ui
            .set_animate_lfo_y_division(animate_lfo_y_division as i32);
        self.ui.set_animate_lfo_y_rate(animate_lfo_y_rate);
        self.ui.set_animate_lfo_y_amount(animate_lfo_y_amount);


        self.ui
            .set_animate_sequencer_current_step(animate_sequencer_current_step);
        self.ui
            .set_animate_sequencer_grid(ModelRc::from(std::rc::Rc::new(VecModel::from(
                animate_sequencer_grid,
            ))));

        self.ui.set_kick_pitch(kick_pitch);
        self.ui.set_kick_decay(kick_decay);
        self.ui.set_kick_attack(kick_attack);
        self.ui.set_kick_pitch_env_amount(kick_pitch_env_amount);
        self.ui.set_kick_drive(kick_drive);
        self.ui.set_kick_level(kick_level);
        self.ui.set_kick_filter_type(kick_filter_type as i32);
        self.ui.set_kick_filter_cutoff(kick_filter_cutoff);
        self.ui.set_kick_filter_resonance(kick_filter_resonance);
        self.ui.set_kick_filter_pre_drive(kick_filter_pre_drive);
        self.ui.set_kick_cut_group(kick_cut_group);
        self.ui.set_kick_cut_by(kick_cut_by);
        self.ui.set_kick_prob(kick_prob);
        self.ui.set_kick_lane_enabled(kick_lane_enabled);
        self.ui
            .set_kick_sequencer_current_step(kick_sequencer_current_step);
        self.ui
            .set_kick_sequencer_grid(ModelRc::from(std::rc::Rc::new(VecModel::from(
                kick_sequencer_grid,
            ))));
        self.ui.set_snare_tone(snare_tone);
        self.ui.set_snare_decay(snare_decay);
        self.ui.set_snare_snappy(snare_snappy);
        self.ui.set_snare_attack(snare_attack);
        self.ui.set_snare_drive(snare_drive);
        self.ui.set_snare_level(snare_level);
        self.ui.set_snare_filter_type(snare_filter_type as i32);
        self.ui.set_snare_filter_cutoff(snare_filter_cutoff);
        self.ui.set_snare_filter_resonance(snare_filter_resonance);
        self.ui.set_snare_filter_pre_drive(snare_filter_pre_drive);
        self.ui.set_snare_cut_group(snare_cut_group);
        self.ui.set_snare_cut_by(snare_cut_by);
        self.ui.set_snare_prob(snare_prob);
        self.ui.set_snare_lane_enabled(snare_lane_enabled);
        self.ui
            .set_snare_sequencer_current_step(snare_sequencer_current_step);
        self.ui
            .set_snare_sequencer_grid(ModelRc::from(std::rc::Rc::new(VecModel::from(
                snare_sequencer_grid,
            ))));
        self.ui.set_clap_pitch(clap_pitch);
        self.ui.set_clap_decay(clap_decay);
        self.ui.set_clap_tone(clap_tone);
        self.ui.set_clap_drive(clap_drive);
        self.ui.set_clap_level(clap_level);
        self.ui.set_clap_filter_type(clap_filter_type as i32);
        self.ui.set_clap_filter_cutoff(clap_filter_cutoff);
        self.ui.set_clap_filter_resonance(clap_filter_resonance);
        self.ui.set_clap_filter_pre_drive(clap_filter_pre_drive);
        self.ui.set_clap_cut_group(clap_cut_group);
        self.ui.set_clap_cut_by(clap_cut_by);
        self.ui.set_clap_prob(clap_prob);
        self.ui.set_clap_lane_enabled(clap_lane_enabled);
        self.ui
            .set_clap_sequencer_current_step(clap_sequencer_current_step);
        self.ui
            .set_clap_sequencer_grid(ModelRc::from(std::rc::Rc::new(VecModel::from(
                clap_sequencer_grid,
            ))));
        self.ui.set_hat_pitch(hat_pitch);
        self.ui.set_hat_decay(hat_decay);
        self.ui.set_hat_tone(hat_tone);
        self.ui.set_hat_drive(hat_drive);
        self.ui.set_hat_level(hat_level);
        self.ui.set_hat_filter_type(hat_filter_type as i32);
        self.ui.set_hat_filter_cutoff(hat_filter_cutoff);
        self.ui.set_hat_filter_resonance(hat_filter_resonance);
        self.ui.set_hat_filter_pre_drive(hat_filter_pre_drive);
        self.ui.set_hat_cut_group(hat_cut_group);
        self.ui.set_hat_cut_by(hat_cut_by);
        self.ui.set_hat_prob(hat_prob);
        self.ui.set_hat_lane_enabled(hat_lane_enabled);
        self.ui
            .set_hat_sequencer_current_step(hat_sequencer_current_step);
        self.ui
            .set_hat_sequencer_grid(ModelRc::from(std::rc::Rc::new(VecModel::from(
                hat_sequencer_grid,
            ))));
        self.ui.set_perc1_pitch(perc1_pitch);
        self.ui.set_perc1_decay(perc1_decay);
        self.ui.set_perc1_tone(perc1_tone);
        self.ui.set_perc1_drive(perc1_drive);
        self.ui.set_perc1_level(perc1_level);
        self.ui.set_perc1_filter_type(perc1_filter_type as i32);
        self.ui.set_perc1_filter_cutoff(perc1_filter_cutoff);
        self.ui.set_perc1_filter_resonance(perc1_filter_resonance);
        self.ui.set_perc1_filter_pre_drive(perc1_filter_pre_drive);
        self.ui.set_perc1_cut_group(perc1_cut_group);
        self.ui.set_perc1_cut_by(perc1_cut_by);
        self.ui.set_perc1_prob(perc1_prob);
        self.ui.set_perc1_lane_enabled(perc1_lane_enabled);
        self.ui
            .set_perc1_sequencer_current_step(perc1_sequencer_current_step);
        self.ui
            .set_perc1_sequencer_grid(ModelRc::from(std::rc::Rc::new(VecModel::from(
                perc1_sequencer_grid,
            ))));
        self.ui.set_perc2_pitch(perc2_pitch);
        self.ui.set_perc2_decay(perc2_decay);
        self.ui.set_perc2_tone(perc2_tone);
        self.ui.set_perc2_drive(perc2_drive);
        self.ui.set_perc2_level(perc2_level);
        self.ui.set_perc2_filter_type(perc2_filter_type as i32);
        self.ui.set_perc2_filter_cutoff(perc2_filter_cutoff);
        self.ui.set_perc2_filter_resonance(perc2_filter_resonance);
        self.ui.set_perc2_filter_pre_drive(perc2_filter_pre_drive);
        self.ui.set_perc2_cut_group(perc2_cut_group);
        self.ui.set_perc2_cut_by(perc2_cut_by);
        self.ui.set_perc2_prob(perc2_prob);
        self.ui.set_perc2_lane_enabled(perc2_lane_enabled);
        self.ui
            .set_perc2_sequencer_current_step(perc2_sequencer_current_step);
        self.ui
            .set_perc2_sequencer_grid(ModelRc::from(std::rc::Rc::new(VecModel::from(
                perc2_sequencer_grid,
            ))));
        self.ui.set_crash_pitch(crash_pitch);
        self.ui.set_crash_decay(crash_decay);
        self.ui.set_crash_tone(crash_tone);
        self.ui.set_crash_drive(crash_drive);
        self.ui.set_crash_level(crash_level);
        self.ui.set_crash_filter_type(crash_filter_type as i32);
        self.ui.set_crash_filter_cutoff(crash_filter_cutoff);
        self.ui.set_crash_filter_resonance(crash_filter_resonance);
        self.ui.set_crash_filter_pre_drive(crash_filter_pre_drive);
        self.ui.set_crash_cut_group(crash_cut_group);
        self.ui.set_crash_cut_by(crash_cut_by);
        self.ui.set_crash_prob(crash_prob);
        self.ui.set_crash_lane_enabled(crash_lane_enabled);
        self.ui
            .set_crash_sequencer_current_step(crash_sequencer_current_step);
        self.ui
            .set_crash_sequencer_grid(ModelRc::from(std::rc::Rc::new(VecModel::from(
                crash_sequencer_grid,
            ))));
        self.ui
            .set_samp_labels(ModelRc::from(std::rc::Rc::new(VecModel::from(samp_labels))));
        self.ui
            .set_samp_paths(ModelRc::from(std::rc::Rc::new(VecModel::from(samp_paths))));
        self.ui
            .set_samp_pitch(ModelRc::from(std::rc::Rc::new(VecModel::from(samp_pitch))));
        self.ui
            .set_samp_attack(ModelRc::from(std::rc::Rc::new(VecModel::from(samp_attack))));
        self.ui
            .set_samp_decay(ModelRc::from(std::rc::Rc::new(VecModel::from(samp_decay))));
        self.ui
            .set_samp_drive(ModelRc::from(std::rc::Rc::new(VecModel::from(samp_drive))));
        self.ui
            .set_samp_level(ModelRc::from(std::rc::Rc::new(VecModel::from(samp_level))));
        self.ui
            .set_samp_filter_type(ModelRc::from(std::rc::Rc::new(VecModel::from(
                samp_filter_type,
            ))));
        self.ui
            .set_samp_filter_cutoff(ModelRc::from(std::rc::Rc::new(VecModel::from(
                samp_filter_cutoff,
            ))));
        self.ui
            .set_samp_filter_resonance(ModelRc::from(std::rc::Rc::new(VecModel::from(
                samp_filter_resonance,
            ))));
        self.ui
            .set_samp_filter_pre_drive(ModelRc::from(std::rc::Rc::new(VecModel::from(
                samp_filter_pre_drive,
            ))));
        self.ui
            .set_samp_cut_group(ModelRc::from(std::rc::Rc::new(VecModel::from(
                samp_cut_group,
            ))));
        self.ui
            .set_samp_cut_by(ModelRc::from(std::rc::Rc::new(VecModel::from(
                samp_cut_by,
            ))));
        self.ui
            .set_samp_prob(ModelRc::from(std::rc::Rc::new(VecModel::from(
                samp_prob,
            ))));
        self.ui
            .set_samp_lane_enabled(ModelRc::from(std::rc::Rc::new(VecModel::from(
                samp_lane_enabled,
            ))));
        self.ui
            .set_samp_sequencer_current_step(ModelRc::from(std::rc::Rc::new(VecModel::from(
                samp_sequencer_current_step,
            ))));
        self.ui
            .set_samp_sequencer_grid(ModelRc::from(std::rc::Rc::new(VecModel::from(
                samp_sequencer_grid,
            ))));
        self.ui.set_syndrm_page(syndrm_page);
        self.ui.set_syndrm_edit_lane(syndrm_edit_lane);
        self.ui.set_syndrm_edit_step(syndrm_edit_step);
        self.ui.set_syndrm_step_hold(syndrm_step_hold);
        self.ui.set_syndrm_randomize_amount(syndrm_randomize_amount);
        self.ui.set_syndrm_step_override(syndrm_step_override);
        self.ui.set_syndrm_step_kick_pitch(syndrm_step_kick_pitch);
        self.ui.set_syndrm_step_kick_decay(syndrm_step_kick_decay);
        self.ui.set_syndrm_step_kick_attack(syndrm_step_kick_attack);
        self.ui.set_syndrm_step_kick_drive(syndrm_step_kick_drive);
        self.ui.set_syndrm_step_kick_level(syndrm_step_kick_level);
        self.ui.set_syndrm_step_kick_filter_type(syndrm_step_kick_filter_type as i32);
        self.ui
            .set_syndrm_step_kick_filter_cutoff(syndrm_step_kick_filter_cutoff);
        self.ui
            .set_syndrm_step_kick_filter_resonance(syndrm_step_kick_filter_resonance);
        self.ui.set_syndrm_step_kick_retrig(syndrm_step_kick_retrig);
        self.ui
            .set_syndrm_step_kick_retrig_division(syndrm_step_kick_retrig_division_index);
        self.ui.set_syndrm_step_snare_tone(syndrm_step_snare_tone);
        self.ui.set_syndrm_step_snare_decay(syndrm_step_snare_decay);
        self.ui.set_syndrm_step_snare_snappy(syndrm_step_snare_snappy);
        self.ui.set_syndrm_step_snare_attack(syndrm_step_snare_attack);
        self.ui.set_syndrm_step_snare_drive(syndrm_step_snare_drive);
        self.ui.set_syndrm_step_snare_level(syndrm_step_snare_level);
        self.ui
            .set_syndrm_step_snare_filter_type(syndrm_step_snare_filter_type as i32);
        self.ui
            .set_syndrm_step_snare_filter_cutoff(syndrm_step_snare_filter_cutoff);
        self.ui
            .set_syndrm_step_snare_filter_resonance(syndrm_step_snare_filter_resonance);
        self.ui.set_syndrm_step_snare_retrig(syndrm_step_snare_retrig);
        self.ui
            .set_syndrm_step_snare_retrig_division(syndrm_step_snare_retrig_division_index);
        self.ui.set_syndrm_step_clap_pitch(syndrm_step_clap_pitch);
        self.ui.set_syndrm_step_clap_decay(syndrm_step_clap_decay);
        self.ui.set_syndrm_step_clap_tone(syndrm_step_clap_tone);
        self.ui.set_syndrm_step_clap_drive(syndrm_step_clap_drive);
        self.ui.set_syndrm_step_clap_level(syndrm_step_clap_level);
        self.ui
            .set_syndrm_step_clap_filter_type(syndrm_step_clap_filter_type as i32);
        self.ui
            .set_syndrm_step_clap_filter_cutoff(syndrm_step_clap_filter_cutoff);
        self.ui
            .set_syndrm_step_clap_filter_resonance(syndrm_step_clap_filter_resonance);
        self.ui.set_syndrm_step_clap_retrig(syndrm_step_clap_retrig);
        self.ui
            .set_syndrm_step_clap_retrig_division(syndrm_step_clap_retrig_division_index);
        self.ui.set_syndrm_step_hat_pitch(syndrm_step_hat_pitch);
        self.ui.set_syndrm_step_hat_decay(syndrm_step_hat_decay);
        self.ui.set_syndrm_step_hat_tone(syndrm_step_hat_tone);
        self.ui.set_syndrm_step_hat_drive(syndrm_step_hat_drive);
        self.ui.set_syndrm_step_hat_level(syndrm_step_hat_level);
        self.ui
            .set_syndrm_step_hat_filter_type(syndrm_step_hat_filter_type as i32);
        self.ui
            .set_syndrm_step_hat_filter_cutoff(syndrm_step_hat_filter_cutoff);
        self.ui
            .set_syndrm_step_hat_filter_resonance(syndrm_step_hat_filter_resonance);
        self.ui.set_syndrm_step_hat_retrig(syndrm_step_hat_retrig);
        self.ui
            .set_syndrm_step_hat_retrig_division(syndrm_step_hat_retrig_division_index);
        self.ui.set_syndrm_step_perc1_pitch(syndrm_step_perc1_pitch);
        self.ui.set_syndrm_step_perc1_decay(syndrm_step_perc1_decay);
        self.ui.set_syndrm_step_perc1_tone(syndrm_step_perc1_tone);
        self.ui.set_syndrm_step_perc1_drive(syndrm_step_perc1_drive);
        self.ui.set_syndrm_step_perc1_level(syndrm_step_perc1_level);
        self.ui
            .set_syndrm_step_perc1_filter_type(syndrm_step_perc1_filter_type as i32);
        self.ui
            .set_syndrm_step_perc1_filter_cutoff(syndrm_step_perc1_filter_cutoff);
        self.ui
            .set_syndrm_step_perc1_filter_resonance(syndrm_step_perc1_filter_resonance);
        self.ui.set_syndrm_step_perc1_retrig(syndrm_step_perc1_retrig);
        self.ui
            .set_syndrm_step_perc1_retrig_division(syndrm_step_perc1_retrig_division_index);
        self.ui.set_syndrm_step_perc2_pitch(syndrm_step_perc2_pitch);
        self.ui.set_syndrm_step_perc2_decay(syndrm_step_perc2_decay);
        self.ui.set_syndrm_step_perc2_tone(syndrm_step_perc2_tone);
        self.ui.set_syndrm_step_perc2_drive(syndrm_step_perc2_drive);
        self.ui.set_syndrm_step_perc2_level(syndrm_step_perc2_level);
        self.ui
            .set_syndrm_step_perc2_filter_type(syndrm_step_perc2_filter_type as i32);
        self.ui
            .set_syndrm_step_perc2_filter_cutoff(syndrm_step_perc2_filter_cutoff);
        self.ui
            .set_syndrm_step_perc2_filter_resonance(syndrm_step_perc2_filter_resonance);
        self.ui.set_syndrm_step_perc2_retrig(syndrm_step_perc2_retrig);
        self.ui
            .set_syndrm_step_perc2_retrig_division(syndrm_step_perc2_retrig_division_index);
        self.ui.set_syndrm_step_crash_pitch(syndrm_step_crash_pitch);
        self.ui.set_syndrm_step_crash_decay(syndrm_step_crash_decay);
        self.ui.set_syndrm_step_crash_tone(syndrm_step_crash_tone);
        self.ui.set_syndrm_step_crash_drive(syndrm_step_crash_drive);
        self.ui.set_syndrm_step_crash_level(syndrm_step_crash_level);
        self.ui
            .set_syndrm_step_crash_filter_type(syndrm_step_crash_filter_type as i32);
        self.ui
            .set_syndrm_step_crash_filter_cutoff(syndrm_step_crash_filter_cutoff);
        self.ui
            .set_syndrm_step_crash_filter_resonance(syndrm_step_crash_filter_resonance);
        self.ui.set_syndrm_step_crash_retrig(syndrm_step_crash_retrig);
        self.ui
            .set_syndrm_step_crash_retrig_division(syndrm_step_crash_retrig_division_index);
        self.ui.set_syndrm_step_samp_pitch(syndrm_step_samp_pitch);
        self.ui.set_syndrm_step_samp_attack(syndrm_step_samp_attack);
        self.ui.set_syndrm_step_samp_decay(syndrm_step_samp_decay);
        self.ui.set_syndrm_step_samp_drive(syndrm_step_samp_drive);
        self.ui.set_syndrm_step_samp_level(syndrm_step_samp_level);
        self.ui.set_syndrm_step_samp_filter_type(syndrm_step_samp_filter_type as i32);
        self.ui
            .set_syndrm_step_samp_filter_cutoff(syndrm_step_samp_filter_cutoff);
        self.ui
            .set_syndrm_step_samp_filter_resonance(syndrm_step_samp_filter_resonance);
        self.ui.set_syndrm_step_samp_retrig(syndrm_step_samp_retrig);
        self.ui
            .set_syndrm_step_samp_retrig_division(syndrm_step_samp_retrig_division_index);

        self.ui.set_fmmi_car_wave(fmmi_car_wave);
        self.ui.set_fmmi_car_freq(fmmi_car_freq);
        self.ui.set_fmmi_car_detune(fmmi_car_detune);
        self.ui.set_fmmi_mod_wave(fmmi_mod_wave);
        self.ui.set_fmmi_mod_mode(fmmi_mod_mode);
        self.ui.set_fmmi_mod_value(fmmi_mod_value);
        self.ui.set_fmmi_mod_detune(fmmi_mod_detune);
        self.ui.set_fmmi_index(fmmi_index);
        self.ui.set_fmmi_feedback(fmmi_feedback);
        self.ui.set_fmmi_drive(fmmi_drive);
        self.ui.set_fmmi_out_level(fmmi_out_level);
        self.ui.set_fmmi_amp_attack(fmmi_amp_attack);
        self.ui.set_fmmi_amp_decay(fmmi_amp_decay);
        self.ui.set_fmmi_amp_sustain(fmmi_amp_sustain);
        self.ui.set_fmmi_amp_release(fmmi_amp_release);
        self.ui.set_fmmi_prob(fmmi_prob);
        self.ui.set_fmmi_poly_enabled(fmmi_poly_enabled);
        self.ui
            .set_fmmi_sequencer_current_step(fmmi_sequencer_current_step);
        self.ui
            .set_fmmi_sequencer_grid(ModelRc::from(std::rc::Rc::new(VecModel::from(
                fmmi_sequencer_grid,
            ))));
        self.ui
            .set_fmmi_step_note_labels(ModelRc::from(std::rc::Rc::new(VecModel::from(
                fmmi_step_note_labels,
            ))));
        self.ui.set_fmmi_page(fmmi_page);
        self.ui.set_fmmi_edit_step(fmmi_edit_step);
        self.ui.set_fmmi_step_note_index(fmmi_step_note_index);
        self.ui.set_fmmi_step_car_wave(fmmi_step_car_wave);
        self.ui.set_fmmi_step_mod_wave(fmmi_step_mod_wave);
        self.ui.set_fmmi_step_mod_mode(fmmi_step_mod_mode);
        self.ui.set_fmmi_step_car_freq(fmmi_step_car_freq);
        self.ui.set_fmmi_step_car_detune(fmmi_step_car_detune);
        self.ui.set_fmmi_step_mod_value(fmmi_step_mod_value);
        self.ui.set_fmmi_step_mod_detune(fmmi_step_mod_detune);
        self.ui.set_fmmi_step_index(fmmi_step_index);
        self.ui.set_fmmi_step_feedback(fmmi_step_feedback);
        self.ui.set_fmmi_step_drive(fmmi_step_drive);
        self.ui.set_fmmi_step_out_level(fmmi_step_out_level);
        self.ui.set_fmmi_step_amp_attack(fmmi_step_amp_attack);
        self.ui.set_fmmi_step_amp_decay(fmmi_step_amp_decay);
        self.ui.set_fmmi_step_amp_sustain(fmmi_step_amp_sustain);
        self.ui.set_fmmi_step_amp_release(fmmi_step_amp_release);
        self.ui.set_fmmi_step_gate_length(fmmi_step_gate_length);
        self.ui.set_fmmi_rand_note_enabled(fmmi_rand_note_enabled);
        self.ui
            .set_fmmi_rand_car_wave_enabled(fmmi_rand_car_wave_enabled);
        self.ui
            .set_fmmi_rand_mod_wave_enabled(fmmi_rand_mod_wave_enabled);
        self.ui
            .set_fmmi_rand_mod_mode_enabled(fmmi_rand_mod_mode_enabled);
        self.ui
            .set_fmmi_rand_car_freq_enabled(fmmi_rand_car_freq_enabled);
        self.ui
            .set_fmmi_rand_car_detune_enabled(fmmi_rand_car_detune_enabled);
        self.ui
            .set_fmmi_rand_mod_value_enabled(fmmi_rand_mod_value_enabled);
        self.ui
            .set_fmmi_rand_mod_detune_enabled(fmmi_rand_mod_detune_enabled);
        self.ui.set_fmmi_rand_index_enabled(fmmi_rand_index_enabled);
        self.ui
            .set_fmmi_rand_feedback_enabled(fmmi_rand_feedback_enabled);
        self.ui.set_fmmi_rand_drive_enabled(fmmi_rand_drive_enabled);
        self.ui
            .set_fmmi_rand_out_level_enabled(fmmi_rand_out_level_enabled);
        self.ui
            .set_fmmi_rand_amp_attack_enabled(fmmi_rand_amp_attack_enabled);
        self.ui
            .set_fmmi_rand_amp_decay_enabled(fmmi_rand_amp_decay_enabled);
        self.ui
            .set_fmmi_rand_amp_sustain_enabled(fmmi_rand_amp_sustain_enabled);
        self.ui
            .set_fmmi_rand_amp_release_enabled(fmmi_rand_amp_release_enabled);
        self.ui
            .set_fmmi_rand_gate_length_enabled(fmmi_rand_gate_length_enabled);
        self.ui.set_fmmi_randomize_amount(fmmi_randomize_amount);
        self.ui
            .set_fmmi_randomize_steps_amount(fmmi_randomize_steps_amount);
        self.ui.set_fmmi_scale_index(fmmi_scale_index as i32);
        self.ui.set_fmmi_scale_mask(fmmi_scale_mask);

        self.ui
            .set_monomi_osc_wave(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_osc_wave,
            ))));
        self.ui
            .set_monomi_osc_octave(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_osc_octave,
            ))));
        self.ui
            .set_monomi_osc_detune(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_osc_detune,
            ))));
        self.ui
            .set_monomi_osc_mix(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_osc_mix,
            ))));
        self.ui
            .set_monomi_osc_pwm(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_osc_pwm,
            ))));
        self.ui.set_monomi_cutoff(monomi_cutoff);
        self.ui.set_monomi_resonance(monomi_resonance);
        self.ui.set_monomi_filter_morph(monomi_filter_morph);
        self.ui.set_monomi_filter_mode(monomi_filter_mode);
        self.ui.set_monomi_volume(monomi_volume.clamp(0.0, 1.0));
        self.ui.set_monomi_amp_attack(monomi_amp_attack);
        self.ui.set_monomi_amp_decay(monomi_amp_decay);
        self.ui.set_monomi_amp_sustain(monomi_amp_sustain);
        self.ui.set_monomi_amp_release(monomi_amp_release);
        self.ui.set_monomi_filter_attack(monomi_filter_attack);
        self.ui.set_monomi_filter_decay(monomi_filter_decay);
        self.ui.set_monomi_filter_sustain(monomi_filter_sustain);
        self.ui.set_monomi_filter_release(monomi_filter_release);
        self.ui.set_monomi_filter_intensity(monomi_filter_intensity);
        self.ui.set_monomi_filter_polarity(monomi_filter_polarity);
        self.ui.set_monomi_filter_saturation(monomi_filter_saturation);
        self.ui.set_monomi_filter_sat_env(monomi_filter_sat_env);
        self.ui.set_monomi_filter_sat_pre(monomi_filter_sat_pre);
        self.ui.set_monomi_mix_comp_mode(monomi_mix_comp_mode);
        self.ui.set_monomi_glide(monomi_glide);
        self.ui.set_monomi_prob(monomi_prob);
        self.ui
            .set_monomi_lfo_shape(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_lfo_shape,
            ))));
        self.ui
            .set_monomi_lfo_target(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_lfo_target,
            ))));
        self.ui
            .set_monomi_lfo_amount(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_lfo_amount,
            ))));
        self.ui
            .set_monomi_lfo_rate(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_lfo_rate,
            ))));
        self.ui
            .set_monomi_lfo_sync(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_lfo_sync,
            ))));
        self.ui
            .set_monomi_lfo_steps(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_lfo_steps,
            ))));
        self.ui
            .set_monomi_sequencer_current_step(monomi_sequencer_current_step);
        self.ui
            .set_monomi_sequencer_grid(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_sequencer_grid,
            ))));
        self.ui
            .set_monomi_step_note_labels(ModelRc::from(std::rc::Rc::new(VecModel::from(
                monomi_step_note_labels,
            ))));
        self.ui.set_monomi_page(monomi_page);
        self.ui.set_monomi_edit_step(monomi_edit_step);
        self.ui.set_monomi_step_note_index(monomi_step_note_index);
        self.ui.set_monomi_step_cutoff(monomi_step_cutoff);
        self.ui.set_monomi_step_resonance(monomi_step_resonance);
        self.ui.set_monomi_step_env_attack(monomi_step_env_attack);
        self.ui.set_monomi_step_env_decay(monomi_step_env_decay);
        self.ui.set_monomi_step_env_sustain(monomi_step_env_sustain);
        self.ui.set_monomi_step_env_release(monomi_step_env_release);
        self.ui.set_monomi_step_gate(monomi_step_gate);
        self.ui.set_monomi_step_filter_morph(monomi_step_filter_morph);
        self.ui.set_monomi_step_glide(monomi_step_glide);
        self.ui.set_monomi_step_osc1_mix(monomi_step_osc1_mix);
        self.ui.set_monomi_step_osc2_mix(monomi_step_osc2_mix);
        self.ui.set_monomi_step_osc3_mix(monomi_step_osc3_mix);
        self.ui.set_monomi_step_osc1_detune(monomi_step_osc1_detune);
        self.ui.set_monomi_step_osc2_detune(monomi_step_osc2_detune);
        self.ui.set_monomi_step_osc3_detune(monomi_step_osc3_detune);
        self.ui.set_monomi_step_osc1_pwm(monomi_step_osc1_pwm);
        self.ui.set_monomi_step_osc2_pwm(monomi_step_osc2_pwm);
        self.ui.set_monomi_step_osc3_pwm(monomi_step_osc3_pwm);
        self.ui.set_monomi_rand_cutoff(monomi_rand_cutoff);
        self.ui.set_monomi_rand_resonance(monomi_rand_resonance);
        self.ui.set_monomi_rand_env_attack(monomi_rand_env_attack);
        self.ui.set_monomi_rand_env_decay(monomi_rand_env_decay);
        self.ui.set_monomi_rand_env_sustain(monomi_rand_env_sustain);
        self.ui.set_monomi_rand_env_release(monomi_rand_env_release);
        self.ui.set_monomi_rand_gate(monomi_rand_gate);
        self.ui.set_monomi_rand_filter_morph(monomi_rand_filter_morph);
        self.ui.set_monomi_rand_glide(monomi_rand_glide);
        self.ui.set_monomi_rand_osc1_mix(monomi_rand_osc1_mix);
        self.ui.set_monomi_rand_osc2_mix(monomi_rand_osc2_mix);
        self.ui.set_monomi_rand_osc3_mix(monomi_rand_osc3_mix);
        self.ui.set_monomi_rand_osc1_detune(monomi_rand_osc1_detune);
        self.ui.set_monomi_rand_osc2_detune(monomi_rand_osc2_detune);
        self.ui.set_monomi_rand_osc3_detune(monomi_rand_osc3_detune);
        self.ui.set_monomi_rand_osc1_pwm(monomi_rand_osc1_pwm);
        self.ui.set_monomi_rand_osc2_pwm(monomi_rand_osc2_pwm);
        self.ui.set_monomi_rand_osc3_pwm(monomi_rand_osc3_pwm);
        self.ui.set_monomi_randomize_amount(monomi_randomize_amount);
        self.ui.set_monomi_scale_index(monomi_scale_index as i32);
        self.ui.set_monomi_scale_mask(monomi_scale_mask);

        self.ui.set_void_base_freq(void_base_freq);
        self.ui.set_void_chaos_depth(void_chaos_depth);
        self.ui.set_void_entropy(void_entropy);
        self.ui.set_void_feedback(void_feedback);
        self.ui.set_void_diffusion(void_diffusion);
        self.ui.set_void_mod_rate(void_mod_rate);
        self.ui.set_void_level(void_level);
        self.ui.set_void_pan(void_pan);
        self.ui.set_void_width(void_width);
        self.ui.set_void_close_decay(void_close_decay);
        self.ui.set_void_filter_cutoff(void_filter_cutoff);
        self.ui.set_void_filter_resonance(void_filter_resonance);
        self.ui.set_void_drive(void_drive);
        self.ui.set_void_filter_pre_drive(void_filter_pre_drive);
        self.ui.set_void_enabled(void_enabled);

        self.ui.set_metronome_enabled(metronome_enabled);
        self.ui
            .set_metronome_count_in(metronome_count_in_ticks as f32);
        self.ui
            .set_metronome_count_in_label(SharedString::from(format!(
                "Count-in: {metronome_count_in_ticks} ticks"
            )));
        self.ui
            .set_metronome_count_playback(metronome_count_in_playback);
        self.ui
            .set_metronome_count_record(metronome_count_in_record);

        self.ui.set_playhead_index(playhead_index);
        self.waveform_model.set_vec(waveform);
        self.oscilloscope_model.set_vec(oscilloscope);
        self.spectrum_model.set_vec(spectrum);
        self.vectorscope_x_model.set_vec(vectorscope_x);
        self.vectorscope_y_model.set_vec(vectorscope_y);
        self.ui
            .set_waveform_time_labels(ModelRc::new(VecModel::from(build_time_labels(
                duration_secs,
            ))));
    }

    fn render(&mut self) {
        let required_len = (self.physical_width * self.physical_height) as usize;
        if self.pixel_buffer.len() != required_len {
            self.pixel_buffer = vec![PremultipliedRgbaColor::default(); required_len];
        }

        self.slint_window.draw_if_needed(|renderer| {
            renderer.render(&mut self.pixel_buffer, self.physical_width as usize);
        });

        let mut buffer = self.sb_surface.buffer_mut().unwrap();
        for (dst, src) in buffer.iter_mut().zip(self.pixel_buffer.iter()) {
            let value = (src.blue as u32)
                | ((src.green as u32) << 8)
                | ((src.red as u32) << 16)
                | ((src.alpha as u32) << 24);
            *dst = value;
        }
        buffer.present().unwrap();
    }

    fn resize(&mut self, window_info: baseview::WindowInfo) {
        self.scale_factor = window_info.scale() as f32;
        let _logical = window_info.logical_size();
        let physical = window_info.physical_size();

        self.physical_width = physical.width;
        self.physical_height = physical.height;

        self.slint_window.dispatch_event(WindowEvent::ScaleFactorChanged {
            scale_factor: self.scale_factor,
        });
        self.slint_window.set_size(PhysicalSize::new(
            self.physical_width,
            self.physical_height,
        ));

        let _ = self.sb_surface.resize(
            std::num::NonZeroU32::new(self.physical_width).unwrap(),
            std::num::NonZeroU32::new(self.physical_height).unwrap(),
        );
    }
}

impl BaseWindowHandler for SlintWindow {
    fn on_frame(&mut self, _window: &mut BaseWindow) {
        // Force focus on the first frame
        static FIRST_FRAME: AtomicBool = AtomicBool::new(true);
        if FIRST_FRAME.swap(false, Ordering::Relaxed) {
            #[cfg(target_os = "windows")]
            {
                if let RawWindowHandle::Win32(handle) = _window.raw_window_handle() {
                    unsafe {
                        use windows_sys::Win32::UI::WindowsAndMessaging::{SetForegroundWindow};
                        use windows_sys::Win32::UI::Input::KeyboardAndMouse::{SetFocus};
                        SetForegroundWindow(handle.hwnd as _);
                        SetFocus(handle.hwnd as _);
                    }
                }
            }

            self.dispatch_slint_event(WindowEvent::WindowActiveChanged(true));
        }
        if let Some(pending) = self.pending_project_params.lock().take() {
            let setter = ParamSetter::new(self.gui_context.as_ref());
            setter.begin_set_parameter(&self.params.gain);
            setter.set_parameter(&self.params.gain, pending.gain);
            setter.end_set_parameter(&self.params.gain);

            setter.begin_set_parameter(&self.params.master_filter);
            setter.set_parameter(&self.params.master_filter, pending.master_filter);
            setter.end_set_parameter(&self.params.master_filter);

            setter.begin_set_parameter(&self.params.master_comp);
            setter.set_parameter(&self.params.master_comp, pending.master_comp);
            setter.end_set_parameter(&self.params.master_comp);
        }
        while let Ok(action) = self.sample_dialog_rx.try_recv() {
            match action {
                SampleDialogAction::Load { track_idx, path } => {
                    if track_idx < NUM_TRACKS {
                        if let Some(path) = path {
                            self.async_executor
                                .execute_background(TLBX1Task::LoadSample(track_idx, path));
                        }
                    }
                }
                SampleDialogAction::Save { track_idx, path } => {
                    if track_idx < NUM_TRACKS {
                        if let Err(err) = save_track_sample(&self.tracks[track_idx], &path) {
                            nih_log!("Failed to save sample: {:?}", err);
                        } else {
                            nih_log!("Saved sample: {:?}", path);
                        }
                    }
                }
                SampleDialogAction::LoadSyndrmSample {
                    track_idx,
                    channel_idx,
                    path,
                } => {
                    if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
                        if let Some(path) = path {
                            self.async_executor.execute_background(
                                TLBX1Task::LoadSyndrmSample {
                                    track_idx,
                                    channel_idx,
                                    path,
                                },
                            );
                        }
                    }
                }
            }
        }
        while let Ok(action) = self.project_dialog_rx.try_recv() {
            match action {
                ProjectDialogAction::Save(path) => {
                    self.async_executor
                        .execute_background(TLBX1Task::SaveProject {
                            path,
                            title: "Project".into(),
                            description: "".into(),
                        });
                }
                ProjectDialogAction::Load(path) => {
                    self.async_executor
                        .execute_background(TLBX1Task::LoadProject(path));
                }
                ProjectDialogAction::SaveWithInfo {
                    path,
                    title,
                    description,
                } => {
                    self.async_executor
                        .execute_background(TLBX1Task::SaveProject {
                            path,
                            title,
                            description,
                        });
                }
                ProjectDialogAction::ExportZip {
                    path,
                    title,
                    description,
                } => {
                    self.async_executor
                        .execute_background(TLBX1Task::ExportProjectZip {
                            path,
                            title,
                            description,
                        });
                }
            }
        }
        platform::update_timers_and_animations();
        self.slint_window.request_redraw();
        self.render();
        self.update_ui_state();
        self.slint_window.request_redraw();
    }

    fn on_event(&mut self, _window: &mut BaseWindow, event: BaseEvent) -> BaseEventStatus {
        // Add at the very top - this WILL print even if logging is filtered
        match &event {
            BaseEvent::Keyboard(e) => {
                println!("========================================");
                println!("KEYBOARD EVENT RECEIVED!!!");
                println!("Key: {:?}", e.key);
                println!("State: {:?}", e.state);
                println!("Repeat: {}", e.repeat);
                println!("========================================");
                std::io::stdout().flush().unwrap();
            }
            _ => {}
        }
        match event {
            BaseEvent::Window(event) => match event {
                baseview::WindowEvent::Resized(info) => {
                    self.resize(info);
                    BaseEventStatus::Captured
                }
                baseview::WindowEvent::Focused => {
                    self.dispatch_slint_event(WindowEvent::WindowActiveChanged(true));
                    BaseEventStatus::Captured
                }
                baseview::WindowEvent::Unfocused => {
                    self.dispatch_slint_event(WindowEvent::WindowActiveChanged(false));
                    BaseEventStatus::Captured
                }
                baseview::WindowEvent::WillClose => {
                    self.dispatch_slint_event(WindowEvent::CloseRequested);
                    BaseEventStatus::Captured
                }
            },
            BaseEvent::Mouse(event) => {
                match event {
                    baseview::MouseEvent::CursorMoved { position, .. } => {
                        let cursor = LogicalPosition::new(position.x as f32, position.y as f32);
                        self.last_cursor = cursor;
                        self.dispatch_slint_event(WindowEvent::PointerMoved { position: cursor });
                    }
                    baseview::MouseEvent::ButtonPressed { button, .. } => {
                        self.dispatch_slint_event(WindowEvent::WindowActiveChanged(true));
                        if let Some(button) = map_mouse_button(button) {
                            self.dispatch_slint_event(WindowEvent::PointerPressed {
                                position: self.last_cursor,
                                button,
                            });
                        }
                    }
                    baseview::MouseEvent::ButtonReleased { button, .. } => {
                        if let Some(button) = map_mouse_button(button) {
                            self.dispatch_slint_event(WindowEvent::PointerReleased {
                                position: self.last_cursor,
                                button,
                            });
                        }
                    }
                    baseview::MouseEvent::WheelScrolled { delta, .. } => {
                        let (dx, dy) = match delta {
                            baseview::ScrollDelta::Lines { x, y } => (x * 32.0, y * 32.0),
                            baseview::ScrollDelta::Pixels { x, y } => (x, y),
                        };
                        self.dispatch_slint_event(WindowEvent::PointerScrolled {
                            position: self.last_cursor,
                            delta_x: dx,
                            delta_y: dy,
                        });
                    }
                    baseview::MouseEvent::CursorLeft => {
                        self.dispatch_slint_event(WindowEvent::PointerExited);
                    }
                    _ => {}
                }
                BaseEventStatus::Captured
            }
            BaseEvent::Keyboard(event) => {
                eprintln!("Keyboard event: {:?} state: {:?}", event.key, event.state); // Debug output
                if event.state == KeyState::Down && !event.repeat {
                    let is_escape = match &event.key {
                        Key::Escape => true,
                        Key::Character(c) if c == "\u{1b}" => true,
                        _ => false,
                    };

                    if is_escape {
                        if self.ui.get_show_settings() {
                            self.ui.set_show_settings(false);
                            return BaseEventStatus::Captured;
                        }
                        if self.ui.get_show_engine_confirm() {
                            self.ui.set_show_engine_confirm(false);
                            return BaseEventStatus::Captured;
                        }
                        if self.ui.get_show_browser() {
                            self.ui.set_show_browser(false);
                            return BaseEventStatus::Captured;
                        }
                    }
                }

                // **CRITICAL FIX**: Dispatch the event with text, not just key pressed/released
                if let Some(text) = key_to_slint_string(&event.key) {
                    let slint_event = match event.state {
                        KeyState::Down => {
                            WindowEvent::KeyPressed {
                                text: text.clone().into()
                            }
                        }
                        KeyState::Up => {
                            WindowEvent::KeyReleased {
                                text: text.into()
                            }
                        }
                    };
                    self.dispatch_slint_event(slint_event);
                }

                let slint_event = match event.state {
                    KeyState::Down => {
                        key_to_slint_string(&event.key).map(|text| WindowEvent::KeyPressed { text: text.into() })
                    }
                    KeyState::Up => {
                        key_to_slint_string(&event.key).map(|text| WindowEvent::KeyReleased { text: text.into() })
                    }
                };

                if let Some(se) = slint_event {
                    self.dispatch_slint_event(se);
                }

                if event.state == KeyState::Down && !event.repeat {
                    match event.key {
                        Key::Character(ref ch) if ch == " " => {
                            if self.gui_context.plugin_api() == PluginApi::Standalone
                                && !self.ui.get_show_browser()
                                && !self.ui.get_show_settings()
                                && !self.ui.get_show_engine_confirm()
                            {
                                self.ui.invoke_toggle_play();
                                return BaseEventStatus::Captured;
                            }
                        }
                        _ => {}
                    }
                }
                BaseEventStatus::Captured
            }
        }
    }
}

fn spawn_with_stack<F>(f: F)
where
    F: FnOnce() + Send + 'static,
{
    let _ = std::thread::Builder::new()
        .stack_size(32 * 1024 * 1024)
        .spawn(f);
}

fn initialize_ui(
    ui: &TLBX1UI,
    gui_context: &Arc<dyn GuiContext>,
    params: &Arc<TLBX1Params>,
    tracks: &Arc<[Track; NUM_TRACKS]>,
    global_tempo: &Arc<AtomicU32>,
    _follow_host_tempo: &Arc<AtomicBool>,
    metronome_enabled: &Arc<AtomicBool>,
    metronome_count_in_ticks: &Arc<AtomicU32>,
    metronome_count_in_playback: &Arc<AtomicBool>,
    metronome_count_in_record: &Arc<AtomicBool>,
    _async_executor: &AsyncExecutor<TLBX1>,
    output_devices: &[String],
    input_devices: &[String],
    sample_rates: &[u32],
    buffer_sizes: &[u32],
    sample_dialog_tx: std::sync::mpsc::Sender<SampleDialogAction>,
    project_dialog_tx: std::sync::mpsc::Sender<ProjectDialogAction>,
    library_folders: &Arc<Mutex<Vec<PathBuf>>>,
    current_path: &Arc<Mutex<PathBuf>>,
    _library_folders_model: &std::rc::Rc<VecModel<SharedString>>,
    current_folder_content_model: &std::rc::Rc<VecModel<BrowserEntry>>,
    animate_library: &Arc<AnimateLibrary>,
) {
    ui.set_output_devices(ModelRc::new(VecModel::from(
        output_devices
            .iter()
            .map(|device| SharedString::from(device.as_str()))
            .collect::<Vec<_>>(),
    )));
    ui.set_input_devices(ModelRc::new(VecModel::from(
        input_devices
            .iter()
            .map(|device| SharedString::from(device.as_str()))
            .collect::<Vec<_>>(),
    )));

    ui.set_sample_rates(ModelRc::new(VecModel::from(
        sample_rates
            .iter()
            .map(|rate| SharedString::from(rate.to_string()))
            .collect::<Vec<_>>(),
    )));

    ui.set_buffer_sizes(ModelRc::new(VecModel::from(
        buffer_sizes
            .iter()
            .map(|size| SharedString::from(size.to_string()))
            .collect::<Vec<_>>(),
    )));
    ui.set_loop_modes(ModelRc::new(VecModel::from(vec![
        SharedString::from("Forward"),
        SharedString::from("Ping-Pong"),
        SharedString::from("One-Shot"),
        SharedString::from("Reverse"),
        SharedString::from("Random Start"),
        SharedString::from("Jump To"),
    ])));
    ui.set_visualizer_modes(ModelRc::new(VecModel::from(vec![
        SharedString::from("Oscilloscope"),
        SharedString::from("Spectrum"),
        SharedString::from("Vectorscope"),
        SharedString::from("Off"),
    ])));
    ui.set_tape_rate_modes(ModelRc::new(VecModel::from(vec![
        SharedString::from("Free"),
        SharedString::from("Straight"),
        SharedString::from("Dotted"),
        SharedString::from("Triplet"),
    ])));
    ui.set_ring_decay_modes(ModelRc::new(VecModel::from(vec![
        SharedString::from("Sustain"),
        SharedString::from("Choke"),
    ])));
    ui.set_ring_rate_modes(ModelRc::new(VecModel::from(vec![
        SharedString::from("Free"),
        SharedString::from("Straight"),
        SharedString::from("Dotted"),
        SharedString::from("Triplet"),
    ])));
    ui.set_ring_scale_modes(ModelRc::new(VecModel::from(vec![
        SharedString::from("Chromatic"),
        SharedString::from("Major"),
        SharedString::from("Minor"),
    ])));
    let fmmi_scale_options: Vec<SharedString> = fmmi_scales()
        .iter()
        .map(|scale| SharedString::from(scale.name.clone()))
        .collect();
    ui.set_fmmi_scale_options(ModelRc::new(VecModel::from(fmmi_scale_options)));
    ui.set_syndrm_filter_types(ModelRc::new(VecModel::from(vec![
        SharedString::from("Moog LP"),
        SharedString::from("Lowpass"),
        SharedString::from("Highpass"),
        SharedString::from("Bandpass"),
    ])));
    ui.set_fmmi_waveforms(ModelRc::new(VecModel::from(vec![
        SharedString::from("Sine"),
        SharedString::from("Triangle"),
        SharedString::from("Saw"),
        SharedString::from("Square"),
    ])));
    let mut fmmi_note_options: Vec<SharedString> = Vec::new();
    fmmi_note_options.push(SharedString::from("Use global"));
    let note_names = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    for octave in 1..=6 {
        for name in note_names.iter() {
            fmmi_note_options.push(SharedString::from(format!("{}{}", name, octave)));
        }
    }
    ui.set_fmmi_note_options(ModelRc::new(VecModel::from(fmmi_note_options)));
    ui.set_fmmi_step_note_labels(ModelRc::new(VecModel::from(vec![
        SharedString::from("");
        FMMI_STEPS
    ])));
    let mut monomi_note_options: Vec<SharedString> = Vec::new();
    monomi_note_options.push(SharedString::from("Use scale"));
    for octave in 1..=6 {
        for name in note_names.iter() {
            monomi_note_options.push(SharedString::from(format!("{}{}", name, octave)));
        }
    }
    ui.set_monomi_note_options(ModelRc::new(VecModel::from(monomi_note_options)));
    ui.set_monomi_step_note_labels(ModelRc::new(VecModel::from(vec![
        SharedString::from("");
        MONOMI_STEPS
    ])));
    let monomi_scale_options: Vec<SharedString> = fmmi_scales()
        .iter()
        .map(|scale| SharedString::from(scale.name.clone()))
        .collect();
    ui.set_monomi_scale_options(ModelRc::new(VecModel::from(monomi_scale_options)));
    let monomi_lfo_targets: Vec<SharedString> = MONOMI_LFO_TARGETS
        .iter()
        .map(|label| SharedString::from(*label))
        .collect();
    ui.set_monomi_lfo_target_options(ModelRc::new(VecModel::from(monomi_lfo_targets)));
    ui.set_modul8_target_options(ModelRc::new(VecModel::from(modul8_target_options_for_engine(0))));
    ui.set_engine_types(ModelRc::new(VecModel::from(vec![
        SharedString::from("Tape-Deck"),
        SharedString::from("Animate"),
        SharedString::from("SynDRM"),
        SharedString::from("Void Seed"),
        SharedString::from("FMMI"),
        SharedString::from("MonoMI"),
    ])));
    ui.set_engine_index(0);
    ui.set_engine_confirm_text(SharedString::from(
        "Loading a new engine will clear unsaved data for this track. Continue?",
    ));

    ui.set_animate_slot_types(ModelRc::new(VecModel::from(vec![
        SharedString::from("Wavetable"),
        SharedString::from("Sample"),
    ])));

    ui.set_animate_filter_types(ModelRc::new(VecModel::from(vec![
        SharedString::from("Lowpass 24dB"),
        SharedString::from("Lowpass 12dB"),
        SharedString::from("Highpass"),
        SharedString::from("Bandpass"),
        SharedString::from("Moog"),
    ])));
    ui.set_animate_lfo_waveforms(ModelRc::new(VecModel::from(vec![
        SharedString::from("Sine"),
        SharedString::from("Triangle"),
        SharedString::from("Square"),
        SharedString::from("Saw"),
        SharedString::from("Sample & Hold"),
    ])));
    ui.set_animate_lfo_divisions(ModelRc::new(VecModel::from(vec![
        SharedString::from("1/16"),
        SharedString::from("1/8"),
        SharedString::from("1/4"),
        SharedString::from("1/3"),
        SharedString::from("1/2"),
        SharedString::from("1"),
        SharedString::from("2"),
        SharedString::from("4"),
    ])));

    // Scan for wavetables and samples
    let mut wavetables = Vec::new();
    if let Ok(entries) = std::fs::read_dir("src/library/factory/wavetables") {
        for entry in entries.flatten() {
            if entry.path().is_dir() {
                if let Ok(subentries) = std::fs::read_dir(entry.path()) {
                    for subentry in subentries.flatten() {
                        if subentry.path().extension().map_or(false, |ext| ext == "wav") {
                            let label = format!("{}/{}", 
                                entry.file_name().to_string_lossy(),
                                subentry.file_name().to_string_lossy());
                            wavetables.push(SharedString::from(label));
                        }
                    }
                }
            } else if entry.path().extension().map_or(false, |ext| ext == "wav") {
                wavetables.push(SharedString::from(entry.file_name().to_string_lossy().to_string()));
            }
        }
    }
    ui.set_animate_wavetables(ModelRc::new(VecModel::from(wavetables)));

    let mut samples = Vec::new();
    if let Ok(entries) = std::fs::read_dir("src/library/factory/samples") {
        for entry in entries.flatten() {
            if entry.path().is_dir() {
                if let Ok(subentries) = std::fs::read_dir(entry.path()) {
                    for subentry in subentries.flatten() {
                        if subentry.path().extension().map_or(false, |ext| ext == "wav" || ext == "mp3") {
                            let label = format!("{}/{}", 
                                entry.file_name().to_string_lossy(),
                                subentry.file_name().to_string_lossy());
                            samples.push(SharedString::from(label));
                        }
                    }
                }
            } else if entry.path().extension().map_or(false, |ext| ext == "wav" || ext == "mp3") {
                samples.push(SharedString::from(entry.file_name().to_string_lossy().to_string()));
            }
        }
    }
    ui.set_animate_samples(ModelRc::new(VecModel::from(samples)));

    let output_device_index = current_arg_value("--output-device")
        .and_then(|name| output_devices.iter().position(|device| device == &name))
        .unwrap_or(0);
    let input_device_index = current_arg_value("--input-device")
        .and_then(|name| input_devices.iter().position(|device| device == &name))
        .unwrap_or(0);
    let sample_rate_index = current_arg_value("--sample-rate")
        .and_then(|value| value.parse::<u32>().ok())
        .and_then(|rate| sample_rates.iter().position(|candidate| *candidate == rate))
        .unwrap_or(1);
    let buffer_size_index = current_arg_value("--period-size")
        .and_then(|value| value.parse::<u32>().ok())
        .and_then(|size| buffer_sizes.iter().position(|candidate| *candidate == size))
        .unwrap_or(3);

    ui.set_output_device_index(output_device_index as i32);
    ui.set_input_device_index(input_device_index as i32);
    ui.set_sample_rate_index(sample_rate_index as i32);
    ui.set_buffer_size_index(buffer_size_index as i32);

    let ui_weak = ui.as_weak();

    let ui_toggle = ui_weak.clone();
    ui.on_toggle_browser(move || {
        if let Some(ui) = ui_toggle.upgrade() {
            ui.set_show_browser(!ui.get_show_browser());
        }
    });

    let ui_add_folder = ui_weak.clone();
    let library_folders_add = library_folders.clone();
    ui.on_add_library_folder(move || {
        let ui_weak = ui_add_folder.clone();
        let library_folders = library_folders_add.clone();
        spawn_with_stack(move || {
            if let Some(path) = rfd::FileDialog::new().pick_folder() {
                slint::invoke_from_event_loop(move || {
                    if let Some(ui) = ui_weak.upgrade() {
                        let mut folders = library_folders.lock();
                        if !folders.contains(&path) {
                            folders.push(path);
                            let folder_strings: Vec<SharedString> = folders
                                .iter()
                                .map(|p| p.to_string_lossy().to_string().into())
                                .collect();
                            ui.set_library_folders(ModelRc::new(VecModel::from(folder_strings)));
                        }
                    }
                })
                .unwrap();
            }
        });
    });

    let ui_select_folder = ui_weak.clone();
    let library_folders_select = library_folders.clone();
    let current_path_select = current_path.clone();
    let current_folder_content_model_select = current_folder_content_model.clone();
    ui.on_select_library_folder(move |index| {
        let folders = library_folders_select.lock();
        if let Some(path) = folders.get(index as usize) {
            *current_path_select.lock() = path.to_path_buf();
            if let Some(ui) = ui_select_folder.upgrade() {
                refresh_browser_impl(&ui, path, &current_folder_content_model_select);
            }
        }
    });

    let ui_open_entry = ui_weak.clone();
    let current_path_open = current_path.clone();
    let current_folder_content_model_open = current_folder_content_model.clone();
    let project_dialog_tx_open = project_dialog_tx.clone();
    ui.on_open_browser_entry(move |entry| {
        let path = PathBuf::from(entry.path.as_str());
        if entry.is_dir {
            *current_path_open.lock() = path.clone();
            if let Some(ui) = ui_open_entry.upgrade() {
                refresh_browser_impl(&ui, &path, &current_folder_content_model_open);
            }
        } else {
            let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
            if ext == "tlbx" {
                let _ = project_dialog_tx_open.send(ProjectDialogAction::Load(path));
                if let Some(ui) = ui_open_entry.upgrade() {
                    ui.set_show_browser(false);
                }
            }
        }
    });

    let project_dialog_tx_save = project_dialog_tx.clone();
    ui.on_save_project_data(move |title, description| {
        let title = title.to_string();
        let description = description.to_string();
        let project_dialog_tx = project_dialog_tx_save.clone();
        spawn_with_stack(move || {
            if let Some(path) = rfd::FileDialog::new()
                .set_title("Select Project Folder")
                .pick_folder()
            {
                let _ = project_dialog_tx.send(ProjectDialogAction::SaveWithInfo {
                    path,
                    title,
                    description,
                });
            }
        });
    });

    let project_dialog_tx_export = project_dialog_tx.clone();
    ui.on_export_project_data(move |title, description| {
        let title = title.to_string();
        let description = description.to_string();
        let project_dialog_tx = project_dialog_tx_export.clone();
        spawn_with_stack(move || {
            if let Some(path) = rfd::FileDialog::new()
                .add_filter("Zip Archive", &["zip"])
                .save_file()
            {
                let _ = project_dialog_tx.send(ProjectDialogAction::ExportZip {
                    path,
                    title,
                    description,
                });
            }
        });
    });

    let pending_engine = Arc::new(Mutex::new(None::<PendingEngineLoad>));

    let gui_context_select = Arc::clone(gui_context);
    let params_select = Arc::clone(params);
    ui.on_select_track(move |track: i32| {
        let track = track.max(1) as usize;
        let setter = ParamSetter::new(gui_context_select.as_ref());
        let normalized = params_select.selected_track.preview_normalized(track as i32);
        setter.begin_set_parameter(&params_select.selected_track);
        setter.set_parameter_normalized(&params_select.selected_track, normalized);
        setter.end_set_parameter(&params_select.selected_track);
    });

    let tracks_engine = Arc::clone(tracks);
    let params_engine = Arc::clone(params);
    let ui_engine = ui_weak.clone();
    let pending_engine_load = Arc::clone(&pending_engine);
    ui.on_load_engine(move || {
            let track_idx = params_engine.selected_track.value().saturating_sub(1) as usize;
            if track_idx >= NUM_TRACKS {
                return;
            }
        let engine_index = if let Some(ui) = ui_engine.upgrade() {
            ui.get_engine_index()
        } else {
            0
        };
            let engine_type = match engine_index {
                0 => 1,
                1 => 2,
                2 => 3,
                3 => 4,
                4 => 5,
                5 => 6,
                _ => 0,
            };
            if engine_type == 0 {
                return;
            }
            let has_engine = tracks_engine[track_idx].engine_type.load(Ordering::Relaxed) != 0;
            if has_engine {
                if let Some(ui) = ui_engine.upgrade() {
                    ui.set_engine_confirm_text(SharedString::from(
                        "Loading a new engine will clear unsaved data for this track. Continue?",
                    ));
                    ui.set_show_engine_confirm(true);
                }
                *pending_engine_load.lock() = Some(PendingEngineLoad {
                    track_idx,
                    engine_type,
                });
            } else {
            reset_track_for_engine(&tracks_engine[track_idx], engine_type);
                if let Some(ui) = ui_engine.upgrade() {
                    ui.set_engine_loaded(true);
                }
            }
        });

    let gui_context_gain = Arc::clone(gui_context);
    let params_gain = Arc::clone(params);
    ui.on_gain_changed(move |value| {
        let setter = ParamSetter::new(gui_context_gain.as_ref());
        setter.begin_set_parameter(&params_gain.gain);
        setter.set_parameter_normalized(&params_gain.gain, value);
        setter.end_set_parameter(&params_gain.gain);
    });

    let gui_context_filter = Arc::clone(gui_context);
    let params_filter = Arc::clone(params);
    ui.on_master_filter_changed(move |value| {
        let setter = ParamSetter::new(gui_context_filter.as_ref());
        setter.begin_set_parameter(&params_filter.master_filter);
        setter.set_parameter_normalized(&params_filter.master_filter, value);
        setter.end_set_parameter(&params_filter.master_filter);
    });

    let gui_context_comp = Arc::clone(gui_context);
    let params_comp = Arc::clone(params);
    ui.on_master_comp_changed(move |value| {
        let setter = ParamSetter::new(gui_context_comp.as_ref());
        setter.begin_set_parameter(&params_comp.master_comp);
        setter.set_parameter_normalized(&params_comp.master_comp, value);
        setter.end_set_parameter(&params_comp.master_comp);
    });

    let tracks_play = Arc::clone(tracks);
    let global_tempo_play = Arc::clone(global_tempo);
    let metronome_enabled_play = Arc::clone(metronome_enabled);
    let metronome_count_in_ticks_play = Arc::clone(metronome_count_in_ticks);
    let metronome_count_in_playback_for_play =
        Arc::clone(metronome_count_in_playback);
    ui.on_toggle_play(move || {
        let any_playing = tracks_play
            .iter()
            .any(|track| track.is_playing.load(Ordering::Relaxed));
        let any_pending = tracks_play
            .iter()
            .any(|track| track.pending_play.load(Ordering::Relaxed));
        if any_playing || any_pending {
            for track in tracks_play.iter() {
                track.is_playing.store(false, Ordering::Relaxed);
                track.pending_play.store(false, Ordering::Relaxed);
                track.count_in_remaining.store(0, Ordering::Relaxed);
                track.void_enabled.store(false, Ordering::Relaxed);
            }
            return;
        }

        let tempo = f32::from_bits(global_tempo_play.load(Ordering::Relaxed)).clamp(20.0, 240.0);
        let count_in_ticks = metronome_count_in_ticks_play.load(Ordering::Relaxed);
        let use_count_in = metronome_enabled_play.load(Ordering::Relaxed)
            && metronome_count_in_playback_for_play.load(Ordering::Relaxed)
            && count_in_ticks > 0;
        for track in tracks_play.iter() {
            let loop_enabled = track.loop_enabled.load(Ordering::Relaxed);
            let loop_mode = track.loop_mode.load(Ordering::Relaxed);
            let loop_start_norm =
                f32::from_bits(track.loop_start.load(Ordering::Relaxed)).clamp(0.0, 0.999);
            let rotate_norm =
                f32::from_bits(track.tape_rotate.load(Ordering::Relaxed)).clamp(0.0, 1.0);
            let reverse_active = track.tape_reverse.load(Ordering::Relaxed) || loop_mode == 3;
            let loop_start = if loop_enabled {
                if let Some(samples) = track.samples.try_lock() {
                    let len = samples.get(0).map(|ch| ch.len()).unwrap_or(0);
                    let rotate_offset = (rotate_norm * len as f32) as usize;
                    if reverse_active {
                        let base_end = ((1.0 - loop_start_norm) * len as f32) as usize;
                        let loop_end = (base_end + rotate_offset).min(len);
                        let mut loop_len =
                            (f32::from_bits(track.loop_length.load(Ordering::Relaxed)) * len as f32)
                                as usize;
                        if loop_len == 0 {
                            loop_len = loop_end.max(1);
                        }
                        loop_end.saturating_sub(loop_len) as f32
                    } else {
                        let base_start = (loop_start_norm * len as f32) as usize;
                        ((base_start + rotate_offset) % len.max(1)) as f32
                    }
                } else {
                    0.0
                }
            } else {
                0.0
            };
            let trigger_start_norm =
                f32::from_bits(track.trigger_start.load(Ordering::Relaxed)).clamp(0.0, 0.999);
            let trigger_start = if let Some(samples) = track.samples.try_lock() {
                let len = samples.get(0).map(|ch| ch.len()).unwrap_or(0);
                let start_norm = if reverse_active {
                    (1.0 - trigger_start_norm).clamp(0.0, 0.999)
                } else {
                    trigger_start_norm
                };
                (start_norm * len as f32) as f32
            } else {
                0.0
            };
            let direction = if loop_mode == 3 { -1 } else { 1 };
            track.loop_dir.store(direction, Ordering::Relaxed);
            if loop_mode == 4 {
                if let Some(samples) = track.samples.try_lock() {
                    let len = samples.get(0).map(|ch| ch.len()).unwrap_or(0);
                    let loop_len =
                        (f32::from_bits(track.loop_length.load(Ordering::Relaxed)) * len as f32)
                            as usize;
                    let loop_len = loop_len.max(1);
                    let loop_end = (loop_start as usize + loop_len).min(len).max(1);
                    let loop_start_usize = loop_start as usize;
                    if loop_end > loop_start_usize {
                        let rand_pos =
                            loop_start_usize + fastrand::usize(..(loop_end - loop_start_usize));
                        track.play_pos.store((rand_pos as f32).to_bits(), Ordering::Relaxed);
                    } else {
                        track.play_pos.store(trigger_start.to_bits(), Ordering::Relaxed);
                    }
                } else {
                    track.play_pos.store(trigger_start.to_bits(), Ordering::Relaxed);
                }
            } else {
                track.play_pos.store(trigger_start.to_bits(), Ordering::Relaxed);
            }
            track
                .loop_start_last
                .store(loop_start as u32, Ordering::Relaxed);
            let mut direction = if loop_mode == 3 { -1 } else { 1 };
            if track.tape_reverse.load(Ordering::Relaxed) {
                direction *= -1;
            }
            let start_pos = f32::from_bits(track.play_pos.load(Ordering::Relaxed));
            track
                .keylock_phase
                .store(0.0f32.to_bits(), Ordering::Relaxed);
            track
                .keylock_grain_a
                .store(start_pos.to_bits(), Ordering::Relaxed);
            track.keylock_grain_b.store(
                (start_pos + direction as f32 * KEYLOCK_GRAIN_HOP as f32).to_bits(),
                Ordering::Relaxed,
            );
            track.debug_logged.store(false, Ordering::Relaxed);
            if use_count_in {
                let sr = track.sample_rate.load(Ordering::Relaxed).max(1);
                let count_in_samples = count_in_samples(tempo, sr, count_in_ticks);
                track
                    .count_in_remaining
                    .store(count_in_samples, Ordering::Relaxed);
                track.pending_play.store(true, Ordering::Relaxed);
                track.is_playing.store(false, Ordering::Relaxed);
            } else {
                track.pending_play.store(false, Ordering::Relaxed);
                track.count_in_remaining.store(0, Ordering::Relaxed);
                track.is_playing.store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_audition = Arc::clone(tracks);
    let params_audition = Arc::clone(params);
    ui.on_audition_start({
        let tracks = Arc::clone(&tracks_audition);
        let params = Arc::clone(&params_audition);
        move || {
            let track_idx = params.selected_track.value().saturating_sub(1) as usize;
            if track_idx >= NUM_TRACKS {
                return;
            }
            let track = &tracks[track_idx];

            let loop_enabled = track.loop_enabled.load(Ordering::Relaxed);
            let loop_mode = track.loop_mode.load(Ordering::Relaxed);
            let loop_start_norm =
                f32::from_bits(track.loop_start.load(Ordering::Relaxed)).clamp(0.0, 0.999);
            let rotate_norm =
                f32::from_bits(track.tape_rotate.load(Ordering::Relaxed)).clamp(0.0, 1.0);
            let reverse_active = track.tape_reverse.load(Ordering::Relaxed) || loop_mode == 3;

            let loop_start = if loop_enabled {
                if let Some(samples) = track.samples.try_lock() {
                    let len = samples.get(0).map(|ch| ch.len()).unwrap_or(0);
                    let rotate_offset = (rotate_norm * len as f32) as usize;
                    if reverse_active {
                        let base_end = ((1.0 - loop_start_norm) * len as f32) as usize;
                        let loop_end = (base_end + rotate_offset).min(len);
                        let mut loop_len =
                            (f32::from_bits(track.loop_length.load(Ordering::Relaxed)) * len as f32)
                                as usize;
                        if loop_len == 0 {
                            loop_len = loop_end.max(1);
                        }
                        loop_end.saturating_sub(loop_len) as f32
                    } else {
                        let base_start = (loop_start_norm * len as f32) as usize;
                        ((base_start + rotate_offset) % len.max(1)) as f32
                    }
                } else {
                    0.0
                }
            } else {
                0.0
            };

            let trigger_start_norm =
                f32::from_bits(track.trigger_start.load(Ordering::Relaxed)).clamp(0.0, 0.999);
            let trigger_start = if let Some(samples) = track.samples.try_lock() {
                let len = samples.get(0).map(|ch| ch.len()).unwrap_or(0);
                let start_norm = if reverse_active {
                    (1.0 - trigger_start_norm).clamp(0.0, 0.999)
                } else {
                    trigger_start_norm
                };
                (start_norm * len as f32) as f32
            } else {
                0.0
            };

            let direction = if loop_mode == 3 { -1 } else { 1 };
            track.loop_dir.store(direction, Ordering::Relaxed);

            if loop_mode == 4 {
                if let Some(samples) = track.samples.try_lock() {
                    let len = samples.get(0).map(|ch| ch.len()).unwrap_or(0);
                    let loop_len =
                        (f32::from_bits(track.loop_length.load(Ordering::Relaxed)) * len as f32)
                            as usize;
                    let loop_len = loop_len.max(1);
                    let loop_end = (loop_start as usize + loop_len).min(len).max(1);
                    let loop_start_usize = loop_start as usize;
                    if loop_end > loop_start_usize {
                        let rand_pos =
                            loop_start_usize + fastrand::usize(..(loop_end - loop_start_usize));
                        track.play_pos.store((rand_pos as f32).to_bits(), Ordering::Relaxed);
                    } else {
                        track.play_pos.store(trigger_start.to_bits(), Ordering::Relaxed);
                    }
                } else {
                    track.play_pos.store(trigger_start.to_bits(), Ordering::Relaxed);
                }
            } else {
                track.play_pos.store(trigger_start.to_bits(), Ordering::Relaxed);
            }

            track
                .loop_start_last
                .store(loop_start as u32, Ordering::Relaxed);
            let mut direction = if loop_mode == 3 { -1 } else { 1 };
            if track.tape_reverse.load(Ordering::Relaxed) {
                direction *= -1;
            }
            let start_pos = f32::from_bits(track.play_pos.load(Ordering::Relaxed));
            track
                .keylock_phase
                .store(0.0f32.to_bits(), Ordering::Relaxed);
            track
                .keylock_grain_a
                .store(start_pos.to_bits(), Ordering::Relaxed);
            track.keylock_grain_b.store(
                (start_pos + direction as f32 * KEYLOCK_GRAIN_HOP as f32).to_bits(),
                Ordering::Relaxed,
            );

            track.pending_play.store(false, Ordering::Relaxed);
            track.count_in_remaining.store(0, Ordering::Relaxed);
            track.is_playing.store(true, Ordering::Relaxed);
        }
    });

    ui.on_audition_end({
        let tracks = Arc::clone(&tracks_audition);
        let params = Arc::clone(&params_audition);
        move || {
            let track_idx = params.selected_track.value().saturating_sub(1) as usize;
            if track_idx < NUM_TRACKS {
                tracks[track_idx].is_playing.store(false, Ordering::Relaxed);
                tracks[track_idx].pending_play.store(false, Ordering::Relaxed);
            }
        }
    });

    let tracks_record = Arc::clone(tracks);
    let params_record = Arc::clone(params);
    let global_tempo_record = Arc::clone(global_tempo);
    let metronome_enabled_record = Arc::clone(metronome_enabled);
    let metronome_count_in_ticks_record = Arc::clone(metronome_count_in_ticks);
    let metronome_count_in_record_enabled = Arc::clone(metronome_count_in_record);
    ui.on_toggle_record(move || {
        let track_idx = params_record.selected_track.value().saturating_sub(1) as usize;
        if track_idx >= NUM_TRACKS {
            return;
        }
        let recording = tracks_record[track_idx]
            .is_recording
            .load(Ordering::Relaxed);
        let pending = tracks_record[track_idx]
            .pending_record
            .load(Ordering::Relaxed);
        if recording || pending {
            tracks_record[track_idx]
                .is_recording
                .store(false, Ordering::Relaxed);
            tracks_record[track_idx]
                .pending_record
                .store(false, Ordering::Relaxed);
            tracks_record[track_idx]
                .count_in_remaining
                .store(0, Ordering::Relaxed);
            if recording {
                if let (Some(samples), Some(mut summary)) = (
                    tracks_record[track_idx].samples.try_lock(),
                    tracks_record[track_idx].waveform_summary.try_lock(),
                ) {
                    if !samples.is_empty() {
                        calculate_waveform_summary(&samples[0], &mut summary);
                        tracks_record[track_idx]
                            .sample_rate
                            .store(RECORD_MAX_SAMPLE_RATE as u32, Ordering::Relaxed);
                    }
                }
            }
            return;
        }

        if let Some(mut samples) = tracks_record[track_idx].samples.try_lock() {
            let overdub = tracks_record[track_idx].tape_overdub.load(Ordering::Relaxed);
            if !overdub {
                for channel in samples.iter_mut() {
                    channel.clear();
                    channel.resize(RECORD_MAX_SAMPLES, 0.0);
                }
                *tracks_record[track_idx].sample_path.lock() = None;
                tracks_record[track_idx]
                    .record_pos
                    .store(0.0f32.to_bits(), Ordering::Relaxed);
            } else {
                let play_pos = tracks_record[track_idx].play_pos.load(Ordering::Relaxed);
                tracks_record[track_idx]
                    .record_pos
                    .store(play_pos, Ordering::Relaxed);
            }
            tracks_record[track_idx]
                .is_playing
                .store(false, Ordering::Relaxed);

            let tempo =
                f32::from_bits(global_tempo_record.load(Ordering::Relaxed)).clamp(20.0, 240.0);
            let count_in_ticks = metronome_count_in_ticks_record.load(Ordering::Relaxed);
            let use_count_in = metronome_enabled_record.load(Ordering::Relaxed)
                && metronome_count_in_record_enabled.load(Ordering::Relaxed)
                && count_in_ticks > 0;
            if use_count_in {
                let sr = tracks_record[track_idx].sample_rate.load(Ordering::Relaxed).max(1);
                let count_in_samples = count_in_samples(tempo, sr, count_in_ticks);
                tracks_record[track_idx]
                    .count_in_remaining
                    .store(count_in_samples, Ordering::Relaxed);
                tracks_record[track_idx]
                    .pending_record
                    .store(true, Ordering::Relaxed);
                tracks_record[track_idx]
                    .is_recording
                    .store(false, Ordering::Relaxed);
            } else {
                tracks_record[track_idx]
                    .pending_record
                    .store(false, Ordering::Relaxed);
                tracks_record[track_idx]
                    .count_in_remaining
                    .store(0, Ordering::Relaxed);
                tracks_record[track_idx]
                    .is_recording
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let params_load = Arc::clone(params);
    let sample_dialog_tx_load = sample_dialog_tx.clone();
    ui.on_load_sample(move || {
        let track_idx = params_load.selected_track.value().saturating_sub(1) as usize;
        if track_idx >= NUM_TRACKS {
            return;
        }
        let sample_dialog_tx = sample_dialog_tx_load.clone();
        spawn_with_stack(move || {
            let path = rfd::FileDialog::new()
                .add_filter(
                    "Media",
                    &[
                        "wav", "flac", "mp3", "ogg", "aif", "aiff", "m4a", "mp4", "mov", "mkv",
                        "avi", "webm", "m4v",
                    ],
                )
                .add_filter("All Files", &["*"])
                .pick_file();
            let _ = sample_dialog_tx.send(SampleDialogAction::Load { track_idx, path });
        });
    });

    let params_samp_load = Arc::clone(params);
    let sample_dialog_tx_syndrm = sample_dialog_tx.clone();
    ui.on_samp_load(move |index| {
        let track_idx = params_samp_load.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index.max(0) as usize;
        if track_idx >= NUM_TRACKS || channel_idx >= SYNDRM_SAMPLE_CHANNELS {
            return;
        }
        let sample_dialog_tx = sample_dialog_tx_syndrm.clone();
        spawn_with_stack(move || {
            let path = rfd::FileDialog::new()
                .add_filter(
                    "Media",
                    &[
                        "wav", "flac", "mp3", "ogg", "aif", "aiff", "m4a", "mp4", "mov", "mkv",
                        "avi", "webm", "m4v",
                    ],
                )
                .add_filter("All Files", &["*"])
                .pick_file();
            let _ = sample_dialog_tx.send(SampleDialogAction::LoadSyndrmSample {
                track_idx,
                channel_idx,
                path,
            });
        });
    });

    let params_save = Arc::clone(params);
    let sample_dialog_tx_save = sample_dialog_tx.clone();
    ui.on_save_sample(move || {
        let track_idx = params_save.selected_track.value().saturating_sub(1) as usize;
        if track_idx >= NUM_TRACKS {
            return;
        }
        let sample_dialog_tx = sample_dialog_tx_save.clone();
        spawn_with_stack(move || {
            let path = rfd::FileDialog::new()
                .add_filter("WAV", &["wav"])
                .save_file();
            if let Some(path) = path {
                let _ = sample_dialog_tx.send(SampleDialogAction::Save { track_idx, path });
            }
        });
    });

    let tracks_level = Arc::clone(tracks);
    let params_level = Arc::clone(params);
    ui.on_track_level_changed(move |value| {
        let track_idx = params_level.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_level[track_idx]
                .level
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mute = Arc::clone(tracks);
    let params_mute = Arc::clone(params);
    ui.on_toggle_track_mute(move || {
        let track_idx = params_mute.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let muted = tracks_mute[track_idx].is_muted.load(Ordering::Relaxed);
            tracks_mute[track_idx]
                .is_muted
                .store(!muted, Ordering::Relaxed);
        }
    });
    let tracks_mute_for = Arc::clone(tracks);
    ui.on_toggle_track_mute_for(move |track: i32| {
        let track_idx = track.max(1) as usize - 1;
        if track_idx < NUM_TRACKS {
            let muted = tracks_mute_for[track_idx].is_muted.load(Ordering::Relaxed);
            tracks_mute_for[track_idx]
                .is_muted
                .store(!muted, Ordering::Relaxed);
        }
    });

    let tracks_loop = Arc::clone(tracks);
    let params_loop = Arc::clone(params);
    ui.on_loop_start_changed(move |value| {
        let track_idx = params_loop.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_loop[track_idx]
                .loop_start
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_trigger = Arc::clone(tracks);
    let params_trigger = Arc::clone(params);
    ui.on_trigger_start_changed(move |value| {
        let track_idx = params_trigger.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_trigger[track_idx]
                .trigger_start
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_loop = Arc::clone(tracks);
    let params_loop = Arc::clone(params);
    ui.on_loop_length_changed(move |value| {
        let track_idx = params_loop.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_loop[track_idx]
                .loop_length
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_loop = Arc::clone(tracks);
    let params_loop = Arc::clone(params);
    ui.on_loop_xfade_changed(move |value| {
        let track_idx = params_loop.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_loop[track_idx]
                .loop_xfade
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_loop = Arc::clone(tracks);
    let params_loop = Arc::clone(params);
    ui.on_toggle_loop_enabled(move || {
        let track_idx = params_loop.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let enabled = tracks_loop[track_idx].loop_enabled.load(Ordering::Relaxed);
            tracks_loop[track_idx]
                .loop_enabled
                .store(!enabled, Ordering::Relaxed);
        }
    });

    let tracks_tape = Arc::clone(tracks);
    let params_tape = Arc::clone(params);
    ui.on_tape_speed_changed(move |value| {
        let track_idx = params_tape.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_tape[track_idx]
                .tape_speed
                .store(value.to_bits(), Ordering::Relaxed);
            tracks_tape[track_idx]
                .tape_sync_requested
                .store(true, Ordering::Relaxed);
        }
    });

    let tracks_tape = Arc::clone(tracks);
    let global_tempo = Arc::clone(global_tempo);
    ui.on_tape_tempo_changed(move |value| {
        global_tempo.store(value.to_bits(), Ordering::Relaxed);
        for track in tracks_tape.iter() {
            track.tape_tempo.store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let metronome_enabled = Arc::clone(metronome_enabled);
    ui.on_toggle_metronome(move || {
        let enabled = metronome_enabled.load(Ordering::Relaxed);
        metronome_enabled.store(!enabled, Ordering::Relaxed);
    });

    let metronome_count_in_ticks = Arc::clone(metronome_count_in_ticks);
    ui.on_metronome_count_in_changed(move |value| {
        let ticks = value.round().clamp(0.0, METRONOME_COUNT_IN_MAX_TICKS as f32) as u32;
        metronome_count_in_ticks.store(ticks, Ordering::Relaxed);
    });

    let metronome_count_in_playback_toggle =
        Arc::clone(metronome_count_in_playback);
    ui.on_toggle_metronome_count_playback(move || {
        let enabled = metronome_count_in_playback_toggle.load(Ordering::Relaxed);
        metronome_count_in_playback_toggle.store(!enabled, Ordering::Relaxed);
    });

    let metronome_count_in_record_toggle =
        Arc::clone(metronome_count_in_record);
    ui.on_toggle_metronome_count_record(move || {
        let enabled = metronome_count_in_record_toggle.load(Ordering::Relaxed);
        metronome_count_in_record_toggle.store(!enabled, Ordering::Relaxed);
    });

    let tracks_tape = Arc::clone(tracks);
    let params_tape = Arc::clone(params);
    ui.on_tape_rate_mode_selected(move |index| {
        let track_idx = params_tape.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let mode = index.clamp(0, 3) as u32;
            tracks_tape[track_idx]
                .tape_rate_mode
                .store(mode, Ordering::Relaxed);
            tracks_tape[track_idx]
                .tape_sync_requested
                .store(true, Ordering::Relaxed);
        }
    });

    let tracks_tape = Arc::clone(tracks);
    let params_tape = Arc::clone(params);
    ui.on_tape_rotate_changed(move |value| {
        let track_idx = params_tape.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_tape[track_idx]
                .tape_rotate
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_tape = Arc::clone(tracks);
    let params_tape = Arc::clone(params);
    ui.on_tape_glide_changed(move |value| {
        let track_idx = params_tape.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_tape[track_idx]
                .tape_glide
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_tape = Arc::clone(tracks);
    let params_tape = Arc::clone(params);
    ui.on_tape_sos_changed(move |value| {
        let track_idx = params_tape.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_tape[track_idx]
                .tape_sos
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_pitch_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_pitch
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_rate_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_rate
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_size_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_size
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_contour_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_contour
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_warp_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_warp
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_spray_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_spray
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_pattern_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_pattern
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_wet_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_wet
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_post_gain_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_post_gain
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_spatial_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_spatial
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_detune_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_detune
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_rand_rate_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_rand_rate
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_rand_size_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_rand_size
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_mosaic_sos_changed(move |value| {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_mosaic[track_idx]
                .mosaic_sos
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });


    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_toggle_mosaic_enabled(move || {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let enabled = tracks_mosaic[track_idx].mosaic_enabled.load(Ordering::Relaxed);
            tracks_mosaic[track_idx]
                .mosaic_enabled
                .store(!enabled, Ordering::Relaxed);
        }
    });

    let tracks_mosaic = Arc::clone(tracks);
    let params_mosaic = Arc::clone(params);
    ui.on_toggle_mosaic_loop_lock(move || {
        let track_idx = params_mosaic.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let enabled = tracks_mosaic[track_idx]
                .mosaic_loop_lock
                .load(Ordering::Relaxed);
            tracks_mosaic[track_idx]
                .mosaic_loop_lock
                .store(!enabled, Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_cutoff_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_cutoff
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_resonance_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_resonance
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_decay_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_decay
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_decay_mode_selected(move |index| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let mode = index.clamp(0, 1) as u32;
            tracks_ring[track_idx]
                .ring_decay_mode
                .store(mode, Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_pitch_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_pitch
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_tone_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_tone
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_tilt_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_tilt
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_slope_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_slope
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_wet_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_wet
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_detune_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_detune
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_waves_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_waves
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_waves_rate_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_waves_rate
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_noise_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_noise
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_ring_noise_rate_changed(move |value| {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_ring[track_idx]
                .ring_noise_rate
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_toggle_ring_enabled(move || {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let enabled = tracks_ring[track_idx].ring_enabled.load(Ordering::Relaxed);
            tracks_ring[track_idx]
                .ring_enabled
                .store(!enabled, Ordering::Relaxed);
        }
    });

    let tracks_ring = Arc::clone(tracks);
    let params_ring = Arc::clone(params);
    ui.on_toggle_ring_pre_post(move || {
        let track_idx = params_ring.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let pre_post = tracks_ring[track_idx].ring_pre_post.load(Ordering::Relaxed);
            tracks_ring[track_idx]
                .ring_pre_post
                .store(!pre_post, Ordering::Relaxed);
        }
    });

    let tracks_texture = Arc::clone(tracks);
    let params_texture = Arc::clone(params);
    ui.on_toggle_texture_enabled(move || {
        let track_idx = params_texture.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let enabled = tracks_texture[track_idx].texture_enabled.load(Ordering::Relaxed);
            tracks_texture[track_idx]
                .texture_enabled
                .store(!enabled, Ordering::Relaxed);
        }
    });

    let tracks_texture = Arc::clone(tracks);
    let params_texture = Arc::clone(params);
    ui.on_toggle_texture_gate(move || {
        let track_idx = params_texture.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let enabled = tracks_texture[track_idx].texture_gate.load(Ordering::Relaxed);
            tracks_texture[track_idx]
                .texture_gate
                .store(!enabled, Ordering::Relaxed);
        }
    });

    let tracks_texture = Arc::clone(tracks);
    let params_texture = Arc::clone(params);
    ui.on_texture_drive_changed(move |value| {
        let track_idx = params_texture.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_texture[track_idx]
                .texture_drive
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_texture = Arc::clone(tracks);
    let params_texture = Arc::clone(params);
    ui.on_texture_compress_changed(move |value| {
        let track_idx = params_texture.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_texture[track_idx]
                .texture_compress
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_texture = Arc::clone(tracks);
    let params_texture = Arc::clone(params);
    ui.on_texture_crush_changed(move |value| {
        let track_idx = params_texture.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_texture[track_idx]
                .texture_crush
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_texture = Arc::clone(tracks);
    let params_texture = Arc::clone(params);
    ui.on_texture_tilt_changed(move |value| {
        let track_idx = params_texture.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_texture[track_idx]
                .texture_tilt
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_texture = Arc::clone(tracks);
    let params_texture = Arc::clone(params);
    ui.on_texture_noise_changed(move |value| {
        let track_idx = params_texture.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_texture[track_idx]
                .texture_noise
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_texture = Arc::clone(tracks);
    let params_texture = Arc::clone(params);
    ui.on_texture_noise_decay_changed(move |value| {
        let track_idx = params_texture.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_texture[track_idx]
                .texture_noise_decay
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_texture = Arc::clone(tracks);
    let params_texture = Arc::clone(params);
    ui.on_texture_noise_color_changed(move |value| {
        let track_idx = params_texture.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_texture[track_idx]
                .texture_noise_color
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_texture = Arc::clone(tracks);
    let params_texture = Arc::clone(params);
    ui.on_texture_wet_changed(move |value| {
        let track_idx = params_texture.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_texture[track_idx]
                .texture_wet
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_texture = Arc::clone(tracks);
    let params_texture = Arc::clone(params);
    ui.on_texture_post_gain_changed(move |value| {
        let track_idx = params_texture.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_texture[track_idx]
                .texture_post_gain
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_toggle_reflect_enabled(move || {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let enabled = tracks_reflect[track_idx].reflect_enabled.load(Ordering::Relaxed);
            tracks_reflect[track_idx]
                .reflect_enabled
                .store(!enabled, Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_toggle_reflect_freeze(move || {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let freeze = tracks_reflect[track_idx].reflect_freeze.load(Ordering::Relaxed);
            tracks_reflect[track_idx]
                .reflect_freeze
                .store(!freeze, Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_reflect_clear(move || {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_reflect[track_idx]
                .reflect_clear
                .store(true, Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_reflect_delay_changed(move |value| {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_reflect[track_idx]
                .reflect_delay
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_reflect_time_changed(move |value| {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_reflect[track_idx]
                .reflect_time
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_reflect_time_mode_selected(move |index| {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_reflect[track_idx]
                .reflect_time_mode
                .store(index.max(0) as u32, Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_reflect_reverb_changed(move |value| {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_reflect[track_idx]
                .reflect_reverb
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_reflect_size_changed(move |value| {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_reflect[track_idx]
                .reflect_size
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_reflect_feedback_changed(move |value| {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_reflect[track_idx]
                .reflect_feedback
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_reflect_spread_changed(move |value| {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_reflect[track_idx]
                .reflect_spread
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_reflect_damp_changed(move |value| {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_reflect[track_idx]
                .reflect_damp
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_reflect_decay_changed(move |value| {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_reflect[track_idx]
                .reflect_decay
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_reflect = Arc::clone(tracks);
    let params_reflect = Arc::clone(params);
    ui.on_reflect_post_gain_changed(move |value| {
        let track_idx = params_reflect.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_reflect[track_idx]
                .reflect_post_gain
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_g8 = Arc::clone(tracks);
    let params_g8 = Arc::clone(params);
    ui.on_toggle_g8_enabled(move || {
        let track_idx = params_g8.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let enabled = tracks_g8[track_idx].g8_enabled.load(Ordering::Relaxed);
            tracks_g8[track_idx]
                .g8_enabled
                .store(!enabled, Ordering::Relaxed);
        }
    });

    let tracks_g8 = Arc::clone(tracks);
    let params_g8 = Arc::clone(params);
    ui.on_g8_rate_selected(move |index| {
        let track_idx = params_g8.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let rate_index = index.clamp(0, 4) as u32;
            tracks_g8[track_idx]
                .g8_rate_index
                .store(rate_index, Ordering::Relaxed);
        }
    });

    let tracks_g8 = Arc::clone(tracks);
    let params_g8 = Arc::clone(params);
    ui.on_g8_step_changed(move |index, value| {
        let track_idx = params_g8.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step_idx = index.clamp(0, (G8_STEPS - 1) as i32) as usize;
            let clamped = value.clamp(0.0, 1.0);
            tracks_g8[track_idx].g8_steps[step_idx]
                .store(clamped.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_modul8 = Arc::clone(tracks);
    let params_modul8 = Arc::clone(params);
    ui.on_toggle_modul8_enabled(move || {
        let track_idx = params_modul8.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let enabled = tracks_modul8[track_idx].modul8_enabled.load(Ordering::Relaxed);
            tracks_modul8[track_idx]
                .modul8_enabled
                .store(!enabled, Ordering::Relaxed);
        }
    });

    let tracks_modul8 = Arc::clone(tracks);
    let params_modul8 = Arc::clone(params);
    ui.on_modul8_wave_changed(move |index, value| {
        let track_idx = params_modul8.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lfo_idx = index.clamp(0, (MODUL8_LFOS - 1) as i32) as usize;
            tracks_modul8[track_idx].modul8_wave[lfo_idx]
                .store(value.clamp(0, 4) as u32, Ordering::Relaxed);
        }
    });

    let tracks_modul8 = Arc::clone(tracks);
    let params_modul8 = Arc::clone(params);
    ui.on_modul8_rate_changed(move |index, value| {
        let track_idx = params_modul8.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lfo_idx = index.clamp(0, (MODUL8_LFOS - 1) as i32) as usize;
            tracks_modul8[track_idx].modul8_rate[lfo_idx]
                .store(value.clamp(0.01, 20.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_modul8 = Arc::clone(tracks);
    let params_modul8 = Arc::clone(params);
    ui.on_modul8_sync_changed(move |index, value| {
        let track_idx = params_modul8.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lfo_idx = index.clamp(0, (MODUL8_LFOS - 1) as i32) as usize;
            tracks_modul8[track_idx].modul8_sync[lfo_idx].store(value, Ordering::Relaxed);
        }
    });

    let tracks_modul8 = Arc::clone(tracks);
    let params_modul8 = Arc::clone(params);
    ui.on_modul8_division_changed(move |index, value| {
        let track_idx = params_modul8.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lfo_idx = index.clamp(0, (MODUL8_LFOS - 1) as i32) as usize;
            tracks_modul8[track_idx].modul8_division[lfo_idx]
                .store(value.clamp(0, 5) as u32, Ordering::Relaxed);
        }
    });

    let tracks_modul8 = Arc::clone(tracks);
    let params_modul8 = Arc::clone(params);
    ui.on_modul8_amount_changed(move |index, value| {
        let track_idx = params_modul8.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lfo_idx = index.clamp(0, (MODUL8_LFOS - 1) as i32) as usize;
            tracks_modul8[track_idx].modul8_amount[lfo_idx]
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_modul8 = Arc::clone(tracks);
    let params_modul8 = Arc::clone(params);
    ui.on_modul8_target_changed(move |index, value| {
        let track_idx = params_modul8.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lfo_idx = index.clamp(0, (MODUL8_LFOS - 1) as i32) as usize;
            let engine_type = tracks_modul8[track_idx].engine_type.load(Ordering::Relaxed);
            let max_index =
                modul8_target_ids_for_engine(engine_type).len().saturating_sub(1) as i32;
            tracks_modul8[track_idx].modul8_target[lfo_idx]
                .store(value.clamp(0, max_index) as u32, Ordering::Relaxed);
        }
    });

    let tracks_tape = Arc::clone(tracks);
    let params_tape = Arc::clone(params);
    ui.on_toggle_tape_reverse(move || {
        let track_idx = params_tape.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let reversed = tracks_tape[track_idx].tape_reverse.load(Ordering::Relaxed);
            tracks_tape[track_idx]
                .tape_reverse
                .store(!reversed, Ordering::Relaxed);
        }
    });

    let tracks_tape = Arc::clone(tracks);
    let params_tape = Arc::clone(params);
    ui.on_toggle_tape_freeze(move || {
        let track_idx = params_tape.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let frozen = tracks_tape[track_idx].tape_freeze.load(Ordering::Relaxed);
            tracks_tape[track_idx]
                .tape_freeze
                .store(!frozen, Ordering::Relaxed);
        }
    });

    let tracks_tape = Arc::clone(tracks);
    let params_tape = Arc::clone(params);
    ui.on_toggle_tape_keylock(move || {
        let track_idx = params_tape.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let keylock = tracks_tape[track_idx].tape_keylock.load(Ordering::Relaxed);
            let enabled = !keylock;
            tracks_tape[track_idx]
                .tape_keylock
                .store(enabled, Ordering::Relaxed);
            if enabled {
                let mut direction = tracks_tape[track_idx].loop_dir.load(Ordering::Relaxed);
                if direction == 0 {
                    direction = 1;
                }
                if tracks_tape[track_idx].tape_reverse.load(Ordering::Relaxed) {
                    direction *= -1;
                }
                let play_pos = f32::from_bits(
                    tracks_tape[track_idx].play_pos.load(Ordering::Relaxed),
                );
                tracks_tape[track_idx]
                    .keylock_phase
                    .store(0.0f32.to_bits(), Ordering::Relaxed);
                tracks_tape[track_idx]
                    .keylock_grain_a
                    .store(play_pos.to_bits(), Ordering::Relaxed);
                tracks_tape[track_idx].keylock_grain_b.store(
                    (play_pos + direction as f32 * KEYLOCK_GRAIN_HOP as f32).to_bits(),
                    Ordering::Relaxed,
                );
            }
        }
    });

    let tracks_tape = Arc::clone(tracks);
    let params_tape = Arc::clone(params);
    ui.on_toggle_tape_monitor(move || {
        let track_idx = params_tape.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let monitor = tracks_tape[track_idx].tape_monitor.load(Ordering::Relaxed);
            tracks_tape[track_idx]
                .tape_monitor
                .store(!monitor, Ordering::Relaxed);
        }
    });

    let tracks_tape = Arc::clone(tracks);
    let params_tape = Arc::clone(params);
    ui.on_toggle_tape_overdub(move || {
        let track_idx = params_tape.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let overdub = tracks_tape[track_idx].tape_overdub.load(Ordering::Relaxed);
            tracks_tape[track_idx]
                .tape_overdub
                .store(!overdub, Ordering::Relaxed);
        }
    });


    let tracks_loop = Arc::clone(tracks);
    let params_loop = Arc::clone(params);
    ui.on_loop_mode_selected(move |index| {
        let track_idx = params_loop.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
        let mode = index.clamp(0, 5) as u32;
            tracks_loop[track_idx]
                .loop_mode
                .store(mode, Ordering::Relaxed);
            tracks_loop[track_idx].loop_dir.store(1, Ordering::Relaxed);
        }
    });

    let ui_visualizer = ui_weak.clone();
    ui.on_visualizer_mode_selected(move |index| {
        if let Some(ui) = ui_visualizer.upgrade() {
            ui.set_visualizer_mode(index);
        }
    });

    let tracks_engine_confirm = Arc::clone(tracks);
    let ui_engine_confirm = ui_weak.clone();
    let pending_engine_confirm = Arc::clone(&pending_engine);
    ui.on_confirm_engine_load(move || {
        if let Some(pending) = pending_engine_confirm.lock().take() {
            if pending.track_idx < NUM_TRACKS {
                reset_track_for_engine(
                    &tracks_engine_confirm[pending.track_idx],
                    pending.engine_type,
                );
            }
        }
        if let Some(ui) = ui_engine_confirm.upgrade() {
            ui.set_show_engine_confirm(false);
        }
    });

    let ui_engine_cancel = ui_weak.clone();
    let pending_engine_cancel = Arc::clone(&pending_engine);
    ui.on_cancel_engine_load(move || {
        *pending_engine_cancel.lock() = None;
        if let Some(ui) = ui_engine_cancel.upgrade() {
            ui.set_show_engine_confirm(false);
        }
    });

    ui.on_quit(|| {
        std::process::exit(0);
    });

    let ui_toggle = ui_weak.clone();
    ui.on_toggle_settings(move || {
        if let Some(ui) = ui_toggle.upgrade() {
            ui.set_show_settings(!ui.get_show_settings());
            // Request focus when opening
            if ui.get_show_settings() {
                ui.window().request_redraw();
            }
        }
    });

    ui.on_open_docs(|| {
        open_docs();
    });

    let ui_output_device = ui_weak.clone();
    ui.on_output_device_selected(move |index| {
        if let Some(ui) = ui_output_device.upgrade() {
            ui.set_output_device_index(index);
        }
    });

    let ui_input_device = ui_weak.clone();
    ui.on_input_device_selected(move |index| {
        if let Some(ui) = ui_input_device.upgrade() {
            ui.set_input_device_index(index);
        }
    });

    let ui_sample_rate = ui_weak.clone();
    ui.on_sample_rate_selected(move |index| {
        if let Some(ui) = ui_sample_rate.upgrade() {
            ui.set_sample_rate_index(index);
        }
    });

    let ui_buffer_size = ui_weak.clone();
    ui.on_buffer_size_selected(move |index| {
        if let Some(ui) = ui_buffer_size.upgrade() {
            ui.set_buffer_size_index(index);
        }
    });

    let ui_refresh = ui_weak.clone();
    ui.on_refresh_devices(move || {
        let Some(ui) = ui_refresh.upgrade() else { return; };
        let devices = available_output_devices();
        let inputs = available_input_devices();
        let model = ModelRc::new(VecModel::from(
            devices
                .iter()
                .map(|device| SharedString::from(device.as_str()))
                .collect::<Vec<_>>(),
        ));
        ui.set_output_devices(model);
        if ui.get_output_device_index() >= devices.len() as i32 {
            ui.set_output_device_index(0);
        }
        let input_model = ModelRc::new(VecModel::from(
            inputs
                .iter()
                .map(|device| SharedString::from(device.as_str()))
                .collect::<Vec<_>>(),
        ));
        ui.set_input_devices(input_model);
        if ui.get_input_device_index() >= inputs.len() as i32 {
            ui.set_input_device_index(0);
        }
    });

    let ui_apply = ui_weak.clone();
    let sample_rates = sample_rates.to_vec();
    let buffer_sizes = buffer_sizes.to_vec();
    let gui_context_apply = Arc::clone(gui_context);
    ui.on_apply_settings(move || {
        let Some(ui) = ui_apply.upgrade() else { return; };
        if gui_context_apply.plugin_api() != PluginApi::Standalone {
            ui.set_settings_status("Audio settings are only available in standalone.".into());
            return;
        }
        let output_devices = available_output_devices();
        let input_devices = available_input_devices();
        let output_device = output_devices.get(ui.get_output_device_index() as usize);
        let input_device = input_devices.get(ui.get_input_device_index() as usize);
        let sample_rate = sample_rates.get(ui.get_sample_rate_index() as usize).copied();
        let buffer_size = buffer_sizes.get(ui.get_buffer_size_index() as usize).copied();
        if let Err(err) = restart_with_audio_settings(
            output_device,
            input_device,
            sample_rate,
            buffer_size,
        ) {
            ui.set_settings_status(format!("Failed to restart audio: {err}").into());
        }
    });

    ui.on_save_project({
        let project_dialog_tx = project_dialog_tx.clone();
        move || {
            let project_dialog_tx = project_dialog_tx.clone();
            spawn_with_stack(move || {
                let path = rfd::FileDialog::new()
                    .add_filter("TLBX-1 Project", &["tlbx", "json"])
                    .save_file();
                if let Some(path) = path {
                    let _ = project_dialog_tx.send(ProjectDialogAction::Save(path));
                }
            });
        }
    });

    ui.on_load_project({
        let project_dialog_tx = project_dialog_tx.clone();
        move || {
            let project_dialog_tx = project_dialog_tx.clone();
            spawn_with_stack(move || {
                let path = rfd::FileDialog::new()
                    .add_filter("TLBX-1 Project", &["tlbx", "json"])
                    .pick_file();
                if let Some(path) = path {
                    let _ = project_dialog_tx.send(ProjectDialogAction::Load(path));
                }
            });
        }
    });

    // Animate Engine Callbacks
    for i in 0..4 {
        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        let slot_idx = i;
        match i {
            0 => ui.on_animate_slot_a_type_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_types[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_type_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_types[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_type_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_types[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_type_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_types[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        let animate_library_a = Arc::clone(&animate_library);
        let animate_library_b = Arc::clone(&animate_library);
        let animate_library_c = Arc::clone(&animate_library);
        let animate_library_d = Arc::clone(&animate_library);
        match i {
            0 => ui.on_animate_slot_a_wavetable_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wavetables[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
                animate_library_a.ensure_wavetable_loaded(index as usize);
            }),
            1 => ui.on_animate_slot_b_wavetable_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wavetables[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
                animate_library_b.ensure_wavetable_loaded(index as usize);
            }),
            2 => ui.on_animate_slot_c_wavetable_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wavetables[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
                animate_library_c.ensure_wavetable_loaded(index as usize);
            }),
            3 => ui.on_animate_slot_d_wavetable_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wavetables[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
                animate_library_d.ensure_wavetable_loaded(index as usize);
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        let animate_library_a = Arc::clone(&animate_library);
        let animate_library_b = Arc::clone(&animate_library);
        let animate_library_c = Arc::clone(&animate_library);
        let animate_library_d = Arc::clone(&animate_library);
        match i {
            0 => ui.on_animate_slot_a_sample_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_samples[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
                animate_library_a.ensure_sample_loaded(index as usize);
            }),
            1 => ui.on_animate_slot_b_sample_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_samples[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
                animate_library_b.ensure_sample_loaded(index as usize);
            }),
            2 => ui.on_animate_slot_c_sample_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_samples[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
                animate_library_c.ensure_sample_loaded(index as usize);
            }),
            3 => ui.on_animate_slot_d_sample_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_samples[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
                animate_library_d.ensure_sample_loaded(index as usize);
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        match i {
            0 => ui.on_animate_slot_a_coarse_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_coarse[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_coarse_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_coarse[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_coarse_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_coarse[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_coarse_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_coarse[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        match i {
            0 => ui.on_animate_slot_a_fine_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_fine[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_fine_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_fine[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_fine_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_fine[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_fine_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_fine[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        match i {
            0 => ui.on_animate_slot_a_level_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_level[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_level_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_level[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_level_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_level[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_level_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_level[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        match i {
            0 => ui.on_animate_slot_a_pan_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_pan[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_pan_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_pan[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_pan_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_pan[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_pan_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_pan[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        match i {
            0 => ui.on_animate_slot_a_wt_lfo_amount_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_amount[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_wt_lfo_amount_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_amount[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_wt_lfo_amount_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_amount[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_wt_lfo_amount_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_amount[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        match i {
            0 => ui.on_animate_slot_a_wt_lfo_shape_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_shape[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_wt_lfo_shape_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_shape[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_wt_lfo_shape_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_shape[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_wt_lfo_shape_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_shape[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        match i {
            0 => ui.on_animate_slot_a_wt_lfo_rate_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_rate[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_wt_lfo_rate_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_rate[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_wt_lfo_rate_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_rate[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_wt_lfo_rate_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_rate[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        match i {
            0 => ui.on_animate_slot_a_wt_lfo_sync_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_sync[slot_idx]
                        .store(value, Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_wt_lfo_sync_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_sync[slot_idx]
                        .store(value, Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_wt_lfo_sync_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_sync[slot_idx]
                        .store(value, Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_wt_lfo_sync_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_sync[slot_idx]
                        .store(value, Ordering::Relaxed);
                }
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        match i {
            0 => ui.on_animate_slot_a_wt_lfo_division_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_division[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_wt_lfo_division_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_division[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_wt_lfo_division_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_division[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_wt_lfo_division_changed(move |index| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_wt_lfo_division[slot_idx]
                        .store(index as u32, Ordering::Relaxed);
                }
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        match i {
            0 => ui.on_animate_slot_a_sample_start_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_sample_start[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_sample_start_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_sample_start[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_sample_start_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_sample_start[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_sample_start_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_sample_start[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        match i {
            0 => ui.on_animate_slot_a_loop_start_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_loop_start[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_loop_start_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_loop_start[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_loop_start_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_loop_start[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_loop_start_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_loop_start[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            _ => (),
        }

        let tracks_animate = Arc::clone(tracks);
        let params_animate = Arc::clone(params);
        match i {
            0 => ui.on_animate_slot_a_loop_end_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_loop_end[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            1 => ui.on_animate_slot_b_loop_end_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_loop_end[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            2 => ui.on_animate_slot_c_loop_end_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_loop_end[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            3 => ui.on_animate_slot_d_loop_end_changed(move |value| {
                let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
                if track_idx < NUM_TRACKS {
                    tracks_animate[track_idx].animate_slot_loop_end[slot_idx]
                        .store(value.to_bits(), Ordering::Relaxed);
                }
            }),
            _ => (),
        }
    }

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_slot_a_filter_type_changed(move |index| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_slot_filter_type[0]
                .store(index as u32, Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_slot_a_filter_cutoff_changed(move |value| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_slot_filter_cutoff[0]
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_slot_a_filter_resonance_changed(move |value| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_slot_filter_resonance[0]
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_slot_a_attack_changed(move |value| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_slot_a_attack
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_slot_a_decay_changed(move |value| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_slot_a_decay
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_slot_a_sustain_changed(move |value| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_slot_a_sustain
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_slot_a_release_changed(move |value| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_slot_a_release
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_vector_changed(move |x, y| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_vector_x
                .store(x.to_bits(), Ordering::Relaxed);
            tracks_animate[track_idx]
                .animate_vector_y
                .store(y.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_lfo_x_waveform_changed(move |index| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_lfo_x_waveform
                .store(index as u32, Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_lfo_x_sync_changed(move |value| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx].animate_lfo_x_sync.store(value, Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_lfo_x_division_changed(move |index| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_lfo_x_division
                .store(index as u32, Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_lfo_x_rate_changed(move |value| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_lfo_x_rate
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_lfo_x_amount_changed(move |value| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_lfo_x_amount
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_lfo_y_waveform_changed(move |index| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_lfo_y_waveform
                .store(index as u32, Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_lfo_y_sync_changed(move |value| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx].animate_lfo_y_sync.store(value, Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_lfo_y_division_changed(move |index| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_lfo_y_division
                .store(index as u32, Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_lfo_y_rate_changed(move |value| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_lfo_y_rate
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_lfo_y_amount_changed(move |value| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_animate[track_idx]
                .animate_lfo_y_amount
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.global::<RDSKeybedBus>().on_note_triggered(move |note| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let engine_type = tracks_animate[track_idx].engine_type.load(Ordering::Relaxed);
            if engine_type == 2 {
                tracks_animate[track_idx]
                    .animate_keybed_note
                    .store(note, Ordering::Relaxed);
                tracks_animate[track_idx]
                    .animate_keybed_trigger
                    .store(true, Ordering::Relaxed);
            } else if engine_type == 5 {
                tracks_animate[track_idx]
                    .fmmi_keybed_note
                    .store(note, Ordering::Relaxed);
                tracks_animate[track_idx]
                    .fmmi_keybed_trigger
                    .store(true, Ordering::Relaxed);
            } else if engine_type == 6 {
                tracks_animate[track_idx]
                    .monomi_keybed_note
                    .store(note, Ordering::Relaxed);
                tracks_animate[track_idx]
                    .monomi_keybed_trigger
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_animate = Arc::clone(tracks);
    let params_animate = Arc::clone(params);
    ui.on_animate_sequencer_grid_toggled(move |row, step| {
        let track_idx = params_animate.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let index = (row * 16 + step) as usize;
            if index < 160 {
                let current = tracks_animate[track_idx].animate_sequencer_grid[index].load(Ordering::Relaxed);
                tracks_animate[track_idx].animate_sequencer_grid[index].store(!current, Ordering::Relaxed);
            }
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_pitch_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_kick[track_idx]
                .kick_pitch
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_decay_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_kick[track_idx]
                .kick_decay
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_attack_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_kick[track_idx]
                .kick_attack
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_pitch_env_amount_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_kick[track_idx]
                .kick_pitch_env_amount
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_drive_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_kick[track_idx]
                .kick_drive
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_level_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_kick[track_idx]
                .kick_level
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_filter_type_changed(move |index| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_kick[track_idx]
                .kick_filter_type
                .store(index as u32, Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_filter_cutoff_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_kick[track_idx]
                .kick_filter_cutoff
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_filter_resonance_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_kick[track_idx]
                .kick_filter_resonance
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_filter_pre_drive_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_kick[track_idx]
                .kick_filter_pre_drive
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_cut_group_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_kick[track_idx]
                .kick_cut_group
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_cut_by_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_kick[track_idx]
                .kick_cut_by
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_prob_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_kick[track_idx]
                .kick_prob
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_modul8 = Arc::clone(tracks);
    let params_modul8 = Arc::clone(params);
    ui.on_modul8_bias_changed(move |index, value| {
        let track_idx = params_modul8.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lfo_idx = index.clamp(0, (MODUL8_LFOS - 1) as i32) as usize;
            tracks_modul8[track_idx].modul8_bias[lfo_idx]
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_lane_enabled_changed(move |value| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_kick[track_idx]
                .kick_lane_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_kick = Arc::clone(tracks);
    let params_kick = Arc::clone(params);
    ui.on_kick_sequencer_grid_toggled(move |step| {
        let track_idx = params_kick.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let index = step as usize;
            if index < SYNDRM_STEPS {
                let current = tracks_kick[track_idx].kick_sequencer_grid[index].load(Ordering::Relaxed);
                tracks_kick[track_idx].kick_sequencer_grid[index].store(!current, Ordering::Relaxed);
            }
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_tone_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_snare[track_idx]
                .snare_tone
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_decay_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_snare[track_idx]
                .snare_decay
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_snappy_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_snare[track_idx]
                .snare_snappy
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_attack_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_snare[track_idx]
                .snare_attack
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_drive_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_snare[track_idx]
                .snare_drive
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_level_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_snare[track_idx]
                .snare_level
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_filter_type_changed(move |index| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_snare[track_idx]
                .snare_filter_type
                .store(index as u32, Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_filter_cutoff_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_snare[track_idx]
                .snare_filter_cutoff
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_filter_resonance_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_snare[track_idx]
                .snare_filter_resonance
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_filter_pre_drive_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_snare[track_idx]
                .snare_filter_pre_drive
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_cut_group_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_snare[track_idx]
                .snare_cut_group
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_cut_by_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_snare[track_idx]
                .snare_cut_by
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_prob_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_snare[track_idx]
                .snare_prob
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_lane_enabled_changed(move |value| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_snare[track_idx]
                .snare_lane_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_snare = Arc::clone(tracks);
    let params_snare = Arc::clone(params);
    ui.on_snare_sequencer_grid_toggled(move |step| {
        let track_idx = params_snare.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let index = step as usize;
            if index < SYNDRM_STEPS {
                let current = tracks_snare[track_idx].snare_sequencer_grid[index].load(Ordering::Relaxed);
                tracks_snare[track_idx].snare_sequencer_grid[index].store(!current, Ordering::Relaxed);
            }
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_pitch_changed(move |value| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_clap[track_idx]
                .clap_pitch
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_decay_changed(move |value| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_clap[track_idx]
                .clap_decay
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_tone_changed(move |value| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_clap[track_idx]
                .clap_tone
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_drive_changed(move |value| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_clap[track_idx]
                .clap_drive
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_level_changed(move |value| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_clap[track_idx]
                .clap_level
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_filter_type_changed(move |index| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_clap[track_idx]
                .clap_filter_type
                .store(index as u32, Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_filter_cutoff_changed(move |value| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_clap[track_idx]
                .clap_filter_cutoff
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_filter_resonance_changed(move |value| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_clap[track_idx]
                .clap_filter_resonance
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_filter_pre_drive_changed(move |value| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_clap[track_idx]
                .clap_filter_pre_drive
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_cut_group_changed(move |value| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_clap[track_idx]
                .clap_cut_group
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_cut_by_changed(move |value| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_clap[track_idx]
                .clap_cut_by
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_prob_changed(move |value| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_clap[track_idx]
                .clap_prob
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_lane_enabled_changed(move |value| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_clap[track_idx]
                .clap_lane_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_clap = Arc::clone(tracks);
    let params_clap = Arc::clone(params);
    ui.on_clap_sequencer_grid_toggled(move |step| {
        let track_idx = params_clap.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let index = step as usize;
            if index < SYNDRM_STEPS {
                let current = tracks_clap[track_idx].clap_sequencer_grid[index].load(Ordering::Relaxed);
                tracks_clap[track_idx].clap_sequencer_grid[index].store(!current, Ordering::Relaxed);
            }
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_pitch_changed(move |value| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_hat[track_idx]
                .hat_pitch
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_decay_changed(move |value| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_hat[track_idx]
                .hat_decay
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_tone_changed(move |value| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_hat[track_idx]
                .hat_tone
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_drive_changed(move |value| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_hat[track_idx]
                .hat_drive
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_level_changed(move |value| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_hat[track_idx]
                .hat_level
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_filter_type_changed(move |index| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_hat[track_idx]
                .hat_filter_type
                .store(index as u32, Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_filter_cutoff_changed(move |value| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_hat[track_idx]
                .hat_filter_cutoff
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_filter_resonance_changed(move |value| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_hat[track_idx]
                .hat_filter_resonance
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_filter_pre_drive_changed(move |value| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_hat[track_idx]
                .hat_filter_pre_drive
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_cut_group_changed(move |value| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_hat[track_idx]
                .hat_cut_group
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_cut_by_changed(move |value| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_hat[track_idx]
                .hat_cut_by
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_prob_changed(move |value| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_hat[track_idx]
                .hat_prob
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_lane_enabled_changed(move |value| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_hat[track_idx]
                .hat_lane_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_hat = Arc::clone(tracks);
    let params_hat = Arc::clone(params);
    ui.on_hat_sequencer_grid_toggled(move |step| {
        let track_idx = params_hat.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let index = step as usize;
            if index < SYNDRM_STEPS {
                let current = tracks_hat[track_idx].hat_sequencer_grid[index].load(Ordering::Relaxed);
                tracks_hat[track_idx].hat_sequencer_grid[index].store(!current, Ordering::Relaxed);
            }
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_pitch_changed(move |value| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc1[track_idx]
                .perc1_pitch
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_decay_changed(move |value| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc1[track_idx]
                .perc1_decay
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_tone_changed(move |value| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc1[track_idx]
                .perc1_tone
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_drive_changed(move |value| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc1[track_idx]
                .perc1_drive
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_level_changed(move |value| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc1[track_idx]
                .perc1_level
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_filter_type_changed(move |index| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc1[track_idx]
                .perc1_filter_type
                .store(index.clamp(0, 3) as u32, Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_filter_cutoff_changed(move |value| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc1[track_idx]
                .perc1_filter_cutoff
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_filter_resonance_changed(move |value| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc1[track_idx]
                .perc1_filter_resonance
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_filter_pre_drive_changed(move |value| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc1[track_idx]
                .perc1_filter_pre_drive
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_cut_group_changed(move |value| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_perc1[track_idx]
                .perc1_cut_group
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_cut_by_changed(move |value| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_perc1[track_idx]
                .perc1_cut_by
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_prob_changed(move |value| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc1[track_idx]
                .perc1_prob
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_lane_enabled_changed(move |value| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc1[track_idx]
                .perc1_lane_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_perc1 = Arc::clone(tracks);
    let params_perc1 = Arc::clone(params);
    ui.on_perc1_sequencer_grid_toggled(move |step| {
        let track_idx = params_perc1.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let index = step as usize;
            if index < SYNDRM_STEPS {
                let current =
                    tracks_perc1[track_idx].perc1_sequencer_grid[index].load(Ordering::Relaxed);
                tracks_perc1[track_idx]
                    .perc1_sequencer_grid[index]
                    .store(!current, Ordering::Relaxed);
            }
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_pitch_changed(move |value| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc2[track_idx]
                .perc2_pitch
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_decay_changed(move |value| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc2[track_idx]
                .perc2_decay
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_tone_changed(move |value| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc2[track_idx]
                .perc2_tone
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_drive_changed(move |value| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc2[track_idx]
                .perc2_drive
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_level_changed(move |value| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc2[track_idx]
                .perc2_level
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_filter_type_changed(move |index| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc2[track_idx]
                .perc2_filter_type
                .store(index.clamp(0, 3) as u32, Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_filter_cutoff_changed(move |value| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc2[track_idx]
                .perc2_filter_cutoff
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_filter_resonance_changed(move |value| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc2[track_idx]
                .perc2_filter_resonance
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_filter_pre_drive_changed(move |value| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc2[track_idx]
                .perc2_filter_pre_drive
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_cut_group_changed(move |value| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_perc2[track_idx]
                .perc2_cut_group
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_cut_by_changed(move |value| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_perc2[track_idx]
                .perc2_cut_by
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_prob_changed(move |value| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc2[track_idx]
                .perc2_prob
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_lane_enabled_changed(move |value| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_perc2[track_idx]
                .perc2_lane_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_perc2 = Arc::clone(tracks);
    let params_perc2 = Arc::clone(params);
    ui.on_perc2_sequencer_grid_toggled(move |step| {
        let track_idx = params_perc2.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let index = step as usize;
            if index < SYNDRM_STEPS {
                let current =
                    tracks_perc2[track_idx].perc2_sequencer_grid[index].load(Ordering::Relaxed);
                tracks_perc2[track_idx]
                    .perc2_sequencer_grid[index]
                    .store(!current, Ordering::Relaxed);
            }
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_pitch_changed(move |value| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_crash[track_idx]
                .crash_pitch
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_decay_changed(move |value| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_crash[track_idx]
                .crash_decay
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_tone_changed(move |value| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_crash[track_idx]
                .crash_tone
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_drive_changed(move |value| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_crash[track_idx]
                .crash_drive
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_level_changed(move |value| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_crash[track_idx]
                .crash_level
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_filter_type_changed(move |index| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_crash[track_idx]
                .crash_filter_type
                .store(index.clamp(0, 3) as u32, Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_filter_cutoff_changed(move |value| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_crash[track_idx]
                .crash_filter_cutoff
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_filter_resonance_changed(move |value| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_crash[track_idx]
                .crash_filter_resonance
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_filter_pre_drive_changed(move |value| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_crash[track_idx]
                .crash_filter_pre_drive
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_cut_group_changed(move |value| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_crash[track_idx]
                .crash_cut_group
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_cut_by_changed(move |value| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_crash[track_idx]
                .crash_cut_by
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_prob_changed(move |value| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_crash[track_idx]
                .crash_prob
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_lane_enabled_changed(move |value| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_crash[track_idx]
                .crash_lane_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_crash = Arc::clone(tracks);
    let params_crash = Arc::clone(params);
    ui.on_crash_sequencer_grid_toggled(move |step| {
        let track_idx = params_crash.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let index = step as usize;
            if index < SYNDRM_STEPS {
                let current =
                    tracks_crash[track_idx].crash_sequencer_grid[index].load(Ordering::Relaxed);
                tracks_crash[track_idx]
                    .crash_sequencer_grid[index]
                    .store(!current, Ordering::Relaxed);
            }
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_pitch_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            tracks_samp[track_idx].samp_pitch[channel_idx]
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_attack_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            tracks_samp[track_idx].samp_attack[channel_idx]
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_decay_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            tracks_samp[track_idx].samp_decay[channel_idx]
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_drive_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            tracks_samp[track_idx].samp_drive[channel_idx]
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_level_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            tracks_samp[track_idx].samp_level[channel_idx]
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_filter_type_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            tracks_samp[track_idx].samp_filter_type[channel_idx]
                .store(value.clamp(0, 3) as u32, Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_filter_cutoff_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            tracks_samp[track_idx].samp_filter_cutoff[channel_idx]
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_filter_resonance_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            tracks_samp[track_idx].samp_filter_resonance[channel_idx]
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_filter_pre_drive_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            tracks_samp[track_idx].samp_filter_pre_drive[channel_idx]
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_cut_group_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_samp[track_idx].samp_cut_group[channel_idx]
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_cut_by_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            let clamped = value.round().clamp(0.0, 14.0) as u32;
            tracks_samp[track_idx].samp_cut_by[channel_idx]
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_prob_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            tracks_samp[track_idx].samp_prob[channel_idx]
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_lane_enabled_changed(move |index, value| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            tracks_samp[track_idx].samp_lane_enabled[channel_idx]
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_samp = Arc::clone(tracks);
    let params_samp = Arc::clone(params);
    ui.on_samp_sequencer_grid_toggled(move |index, step| {
        let track_idx = params_samp.selected_track.value().saturating_sub(1) as usize;
        let channel_idx = index as usize;
        if track_idx < NUM_TRACKS && channel_idx < SYNDRM_SAMPLE_CHANNELS {
            let step_idx = step as usize;
            if step_idx < SYNDRM_STEPS {
                let current = tracks_samp[track_idx].samp_sequencer_grid[channel_idx][step_idx]
                    .load(Ordering::Relaxed);
                tracks_samp[track_idx].samp_sequencer_grid[channel_idx][step_idx]
                    .store(!current, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_page_changed(move |page| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = page.clamp(0, (SYNDRM_PAGES - 1) as i32) as u32;
            tracks_syndrm[track_idx]
                .syndrm_page
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_edit_lane_changed(move |lane| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = lane.clamp(0, (SYNDRM_LANES - 1) as i32) as u32;
            tracks_syndrm[track_idx]
                .syndrm_edit_lane
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_edit_step_changed(move |step| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = step.clamp(0, (SYNDRM_STEPS - 1) as i32) as u32;
            tracks_syndrm[track_idx]
                .syndrm_edit_step
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_hold_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_syndrm[track_idx]
                .syndrm_step_hold
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_amount_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_syndrm[track_idx]
                .syndrm_randomize_amount
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_override_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let edit_lane =
                    tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
                if edit_lane == 0 {
                    tracks_syndrm[track_idx].kick_step_override_enabled[edit_step]
                        .store(value, Ordering::Relaxed);
                } else if edit_lane == 1 {
                    tracks_syndrm[track_idx].snare_step_override_enabled[edit_step]
                        .store(value, Ordering::Relaxed);
                } else if edit_lane == 2 {
                    tracks_syndrm[track_idx].clap_step_override_enabled[edit_step]
                        .store(value, Ordering::Relaxed);
                } else if edit_lane == 3 {
                    tracks_syndrm[track_idx].hat_step_override_enabled[edit_step]
                        .store(value, Ordering::Relaxed);
                } else if edit_lane == 4 {
                    tracks_syndrm[track_idx].perc1_step_override_enabled[edit_step]
                        .store(value, Ordering::Relaxed);
                } else if edit_lane == 5 {
                    tracks_syndrm[track_idx].perc2_step_override_enabled[edit_step]
                        .store(value, Ordering::Relaxed);
                } else if edit_lane == 6 {
                    tracks_syndrm[track_idx].crash_step_override_enabled[edit_step]
                        .store(value, Ordering::Relaxed);
                } else {
                    let channel_idx = edit_lane.saturating_sub(7) as usize;
                    if channel_idx < SYNDRM_SAMPLE_CHANNELS {
                        tracks_syndrm[track_idx].samp_step_override_enabled[channel_idx][edit_step]
                            .store(value, Ordering::Relaxed);
                    }
                }
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_kick_pitch_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].kick_step_pitch[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].kick_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_kick_decay_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].kick_step_decay[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].kick_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_kick_attack_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].kick_step_attack[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].kick_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_kick_drive_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].kick_step_drive[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].kick_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_kick_level_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].kick_step_level[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].kick_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_kick_filter_type_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].kick_step_filter_type[edit_step]
                    .store(index as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].kick_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_kick_filter_cutoff_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].kick_step_filter_cutoff[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].kick_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_kick_filter_resonance_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].kick_step_filter_resonance[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].kick_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_kick_retrig_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].kick_step_retrig_enabled[edit_step]
                    .store(value, Ordering::Relaxed);
                tracks_syndrm[track_idx].kick_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_kick_retrig_division_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let division = if index <= 0 { 2 } else { 4 };
                tracks_syndrm[track_idx].kick_step_retrig_division[edit_step]
                    .store(division as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].kick_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_snare_tone_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].snare_step_tone[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].snare_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_snare_decay_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].snare_step_decay[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].snare_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_snare_snappy_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].snare_step_snappy[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].snare_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_snare_attack_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].snare_step_attack[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].snare_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_snare_drive_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].snare_step_drive[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].snare_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_snare_level_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].snare_step_level[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].snare_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_snare_filter_type_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].snare_step_filter_type[edit_step]
                    .store(index as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].snare_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_snare_filter_cutoff_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].snare_step_filter_cutoff[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].snare_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_snare_filter_resonance_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].snare_step_filter_resonance[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].snare_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_snare_retrig_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].snare_step_retrig_enabled[edit_step]
                    .store(value, Ordering::Relaxed);
                tracks_syndrm[track_idx].snare_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_snare_retrig_division_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let division = if index <= 0 { 2 } else { 4 };
                tracks_syndrm[track_idx].snare_step_retrig_division[edit_step]
                    .store(division as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].snare_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_clap_pitch_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].clap_step_pitch[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].clap_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_clap_decay_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].clap_step_decay[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].clap_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_clap_tone_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].clap_step_tone[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].clap_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_clap_drive_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].clap_step_drive[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].clap_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_clap_level_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].clap_step_level[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].clap_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_clap_filter_type_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].clap_step_filter_type[edit_step]
                    .store(index as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].clap_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_clap_filter_cutoff_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].clap_step_filter_cutoff[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].clap_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_clap_filter_resonance_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].clap_step_filter_resonance[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].clap_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_clap_retrig_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].clap_step_retrig_enabled[edit_step]
                    .store(value, Ordering::Relaxed);
                tracks_syndrm[track_idx].clap_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_clap_retrig_division_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let division = if index <= 0 { 2 } else { 4 };
                tracks_syndrm[track_idx].clap_step_retrig_division[edit_step]
                    .store(division as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].clap_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_hat_pitch_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].hat_step_pitch[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].hat_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_hat_decay_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].hat_step_decay[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].hat_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_hat_tone_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].hat_step_tone[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].hat_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_hat_drive_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].hat_step_drive[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].hat_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_hat_level_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].hat_step_level[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].hat_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_hat_filter_type_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].hat_step_filter_type[edit_step]
                    .store(index as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].hat_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_hat_filter_cutoff_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].hat_step_filter_cutoff[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].hat_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_hat_filter_resonance_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].hat_step_filter_resonance[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].hat_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_hat_retrig_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].hat_step_retrig_enabled[edit_step]
                    .store(value, Ordering::Relaxed);
                tracks_syndrm[track_idx].hat_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_hat_retrig_division_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let division = if index <= 0 { 2 } else { 4 };
                tracks_syndrm[track_idx].hat_step_retrig_division[edit_step]
                    .store(division as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].hat_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc1_pitch_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc1_step_pitch[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc1_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc1_decay_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc1_step_decay[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc1_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc1_tone_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc1_step_tone[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc1_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc1_drive_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc1_step_drive[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc1_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc1_level_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc1_step_level[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc1_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc1_filter_type_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc1_step_filter_type[edit_step]
                    .store(index.clamp(0, 3) as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].perc1_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc1_filter_cutoff_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc1_step_filter_cutoff[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc1_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc1_filter_resonance_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc1_step_filter_resonance[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc1_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc1_retrig_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc1_step_retrig_enabled[edit_step]
                    .store(value, Ordering::Relaxed);
                tracks_syndrm[track_idx].perc1_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc1_retrig_division_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let division = if index <= 0 { 2 } else { 4 };
                tracks_syndrm[track_idx].perc1_step_retrig_division[edit_step]
                    .store(division as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].perc1_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc2_pitch_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc2_step_pitch[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc2_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc2_decay_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc2_step_decay[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc2_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc2_tone_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc2_step_tone[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc2_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc2_drive_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc2_step_drive[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc2_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc2_level_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc2_step_level[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc2_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc2_filter_type_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc2_step_filter_type[edit_step]
                    .store(index.clamp(0, 3) as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].perc2_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc2_filter_cutoff_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc2_step_filter_cutoff[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc2_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc2_filter_resonance_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc2_step_filter_resonance[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].perc2_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc2_retrig_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].perc2_step_retrig_enabled[edit_step]
                    .store(value, Ordering::Relaxed);
                tracks_syndrm[track_idx].perc2_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_perc2_retrig_division_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let division = if index <= 0 { 2 } else { 4 };
                tracks_syndrm[track_idx].perc2_step_retrig_division[edit_step]
                    .store(division as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].perc2_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_crash_pitch_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].crash_step_pitch[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].crash_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_crash_decay_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].crash_step_decay[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].crash_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_crash_tone_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].crash_step_tone[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].crash_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_crash_drive_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].crash_step_drive[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].crash_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_crash_level_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].crash_step_level[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].crash_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_crash_filter_type_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].crash_step_filter_type[edit_step]
                    .store(index.clamp(0, 3) as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].crash_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_crash_filter_cutoff_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].crash_step_filter_cutoff[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].crash_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_crash_filter_resonance_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].crash_step_filter_resonance[edit_step]
                    .store(value.to_bits(), Ordering::Relaxed);
                tracks_syndrm[track_idx].crash_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_crash_retrig_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                tracks_syndrm[track_idx].crash_step_retrig_enabled[edit_step]
                    .store(value, Ordering::Relaxed);
                tracks_syndrm[track_idx].crash_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_crash_retrig_division_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let division = if index <= 0 { 2 } else { 4 };
                tracks_syndrm[track_idx].crash_step_retrig_division[edit_step]
                    .store(division as u32, Ordering::Relaxed);
                tracks_syndrm[track_idx].crash_step_override_enabled[edit_step]
                    .store(true, Ordering::Relaxed);
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_samp_pitch_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed) as usize;
                if lane >= 7 && lane < SYNDRM_LANES {
                    let channel_idx = lane - 7;
                    tracks_syndrm[track_idx].samp_step_pitch[channel_idx][edit_step]
                        .store(value.to_bits(), Ordering::Relaxed);
                    tracks_syndrm[track_idx].samp_step_override_enabled[channel_idx][edit_step]
                        .store(true, Ordering::Relaxed);
                }
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_samp_attack_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed) as usize;
                if lane >= 7 && lane < SYNDRM_LANES {
                    let channel_idx = lane - 7;
                    tracks_syndrm[track_idx].samp_step_attack[channel_idx][edit_step]
                        .store(value.to_bits(), Ordering::Relaxed);
                    tracks_syndrm[track_idx].samp_step_override_enabled[channel_idx][edit_step]
                        .store(true, Ordering::Relaxed);
                }
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_samp_decay_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed) as usize;
                if lane >= 7 && lane < SYNDRM_LANES {
                    let channel_idx = lane - 7;
                    tracks_syndrm[track_idx].samp_step_decay[channel_idx][edit_step]
                        .store(value.to_bits(), Ordering::Relaxed);
                    tracks_syndrm[track_idx].samp_step_override_enabled[channel_idx][edit_step]
                        .store(true, Ordering::Relaxed);
                }
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_samp_drive_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed) as usize;
                if lane >= 7 && lane < SYNDRM_LANES {
                    let channel_idx = lane - 7;
                    tracks_syndrm[track_idx].samp_step_drive[channel_idx][edit_step]
                        .store(value.to_bits(), Ordering::Relaxed);
                    tracks_syndrm[track_idx].samp_step_override_enabled[channel_idx][edit_step]
                        .store(true, Ordering::Relaxed);
                }
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_samp_level_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed) as usize;
                if lane >= 7 && lane < SYNDRM_LANES {
                    let channel_idx = lane - 7;
                    tracks_syndrm[track_idx].samp_step_level[channel_idx][edit_step]
                        .store(value.to_bits(), Ordering::Relaxed);
                    tracks_syndrm[track_idx].samp_step_override_enabled[channel_idx][edit_step]
                        .store(true, Ordering::Relaxed);
                }
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_samp_filter_type_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed) as usize;
                if lane >= 7 && lane < SYNDRM_LANES {
                    let channel_idx = lane - 7;
                    tracks_syndrm[track_idx].samp_step_filter_type[channel_idx][edit_step]
                        .store(index.clamp(0, 3) as u32, Ordering::Relaxed);
                    tracks_syndrm[track_idx].samp_step_override_enabled[channel_idx][edit_step]
                        .store(true, Ordering::Relaxed);
                }
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_samp_filter_cutoff_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed) as usize;
                if lane >= 7 && lane < SYNDRM_LANES {
                    let channel_idx = lane - 7;
                    tracks_syndrm[track_idx].samp_step_filter_cutoff[channel_idx][edit_step]
                        .store(value.to_bits(), Ordering::Relaxed);
                    tracks_syndrm[track_idx].samp_step_override_enabled[channel_idx][edit_step]
                        .store(true, Ordering::Relaxed);
                }
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_samp_filter_resonance_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed) as usize;
                if lane >= 7 && lane < SYNDRM_LANES {
                    let channel_idx = lane - 7;
                    tracks_syndrm[track_idx].samp_step_filter_resonance[channel_idx][edit_step]
                        .store(value.to_bits(), Ordering::Relaxed);
                    tracks_syndrm[track_idx].samp_step_override_enabled[channel_idx][edit_step]
                        .store(true, Ordering::Relaxed);
                }
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_samp_retrig_changed(move |value| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed) as usize;
                if lane >= 7 && lane < SYNDRM_LANES {
                    let channel_idx = lane - 7;
                    tracks_syndrm[track_idx].samp_step_retrig_enabled[channel_idx][edit_step]
                        .store(value, Ordering::Relaxed);
                    tracks_syndrm[track_idx].samp_step_override_enabled[channel_idx][edit_step]
                        .store(true, Ordering::Relaxed);
                }
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_step_samp_retrig_division_changed(move |index| {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let edit_step =
                tracks_syndrm[track_idx].syndrm_edit_step.load(Ordering::Relaxed) as usize;
            if edit_step < SYNDRM_STEPS {
                let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed) as usize;
                if lane >= 7 && lane < SYNDRM_LANES {
                    let channel_idx = lane - 7;
                    let division = if index <= 0 { 2 } else { 4 };
                    tracks_syndrm[track_idx].samp_step_retrig_division[channel_idx][edit_step]
                        .store(division as u32, Ordering::Relaxed);
                    tracks_syndrm[track_idx].samp_step_override_enabled[channel_idx][edit_step]
                        .store(true, Ordering::Relaxed);
                }
            }
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_steps_lane_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            let start = page * SYNDRM_PAGE_SIZE;
            let amount = f32::from_bits(
                tracks_syndrm[track_idx]
                    .syndrm_randomize_amount
                    .load(Ordering::Relaxed),
            );
            syndrm_randomize_apply(
                &tracks_syndrm[track_idx],
                lanes,
                start,
                SYNDRM_PAGE_SIZE,
                true,
                false,
                amount,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_steps_lane_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            let amount = f32::from_bits(
                tracks_syndrm[track_idx]
                    .syndrm_randomize_amount
                    .load(Ordering::Relaxed),
            );
            syndrm_randomize_apply(
                &tracks_syndrm[track_idx],
                lanes,
                0,
                SYNDRM_STEPS,
                true,
                false,
                amount,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_steps_all_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let start = page * SYNDRM_PAGE_SIZE;
            let amount = f32::from_bits(
                tracks_syndrm[track_idx]
                    .syndrm_randomize_amount
                    .load(Ordering::Relaxed),
            );
            syndrm_randomize_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                start,
                SYNDRM_PAGE_SIZE,
                true,
                false,
                amount,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_steps_all_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let amount = f32::from_bits(
                tracks_syndrm[track_idx]
                    .syndrm_randomize_amount
                    .load(Ordering::Relaxed),
            );
            syndrm_randomize_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                0,
                SYNDRM_STEPS,
                true,
                false,
                amount,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_params_lane_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            let start = page * SYNDRM_PAGE_SIZE;
            let amount = f32::from_bits(
                tracks_syndrm[track_idx]
                    .syndrm_randomize_amount
                    .load(Ordering::Relaxed),
            );
            syndrm_randomize_apply(
                &tracks_syndrm[track_idx],
                lanes,
                start,
                SYNDRM_PAGE_SIZE,
                false,
                true,
                amount,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_params_lane_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            let amount = f32::from_bits(
                tracks_syndrm[track_idx]
                    .syndrm_randomize_amount
                    .load(Ordering::Relaxed),
            );
            syndrm_randomize_apply(
                &tracks_syndrm[track_idx],
                lanes,
                0,
                SYNDRM_STEPS,
                false,
                true,
                amount,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_params_all_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let start = page * SYNDRM_PAGE_SIZE;
            let amount = f32::from_bits(
                tracks_syndrm[track_idx]
                    .syndrm_randomize_amount
                    .load(Ordering::Relaxed),
            );
            syndrm_randomize_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                start,
                SYNDRM_PAGE_SIZE,
                false,
                true,
                amount,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_params_all_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let amount = f32::from_bits(
                tracks_syndrm[track_idx]
                    .syndrm_randomize_amount
                    .load(Ordering::Relaxed),
            );
            syndrm_randomize_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                0,
                SYNDRM_STEPS,
                false,
                true,
                amount,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_both_lane_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            let start = page * SYNDRM_PAGE_SIZE;
            let amount = f32::from_bits(
                tracks_syndrm[track_idx]
                    .syndrm_randomize_amount
                    .load(Ordering::Relaxed),
            );
            syndrm_randomize_apply(
                &tracks_syndrm[track_idx],
                lanes,
                start,
                SYNDRM_PAGE_SIZE,
                true,
                true,
                amount,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_both_lane_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            let amount = f32::from_bits(
                tracks_syndrm[track_idx]
                    .syndrm_randomize_amount
                    .load(Ordering::Relaxed),
            );
            syndrm_randomize_apply(
                &tracks_syndrm[track_idx],
                lanes,
                0,
                SYNDRM_STEPS,
                true,
                true,
                amount,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_both_all_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let start = page * SYNDRM_PAGE_SIZE;
            let amount = f32::from_bits(
                tracks_syndrm[track_idx]
                    .syndrm_randomize_amount
                    .load(Ordering::Relaxed),
            );
            syndrm_randomize_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                start,
                SYNDRM_PAGE_SIZE,
                true,
                true,
                amount,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_randomize_both_all_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let amount = f32::from_bits(
                tracks_syndrm[track_idx]
                    .syndrm_randomize_amount
                    .load(Ordering::Relaxed),
            );
            syndrm_randomize_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                0,
                SYNDRM_STEPS,
                true,
                true,
                amount,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_clear_steps_lane_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            let start = page * SYNDRM_PAGE_SIZE;
            syndrm_clear_apply(&tracks_syndrm[track_idx], lanes, start, SYNDRM_PAGE_SIZE, true, false);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_clear_steps_lane_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            syndrm_clear_apply(&tracks_syndrm[track_idx], lanes, 0, SYNDRM_STEPS, true, false);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_clear_steps_all_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let start = page * SYNDRM_PAGE_SIZE;
            syndrm_clear_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                start,
                SYNDRM_PAGE_SIZE,
                true,
                false,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_clear_steps_all_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            syndrm_clear_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                0,
                SYNDRM_STEPS,
                true,
                false,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_clear_params_lane_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            let start = page * SYNDRM_PAGE_SIZE;
            syndrm_clear_apply(&tracks_syndrm[track_idx], lanes, start, SYNDRM_PAGE_SIZE, false, true);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_clear_params_lane_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            syndrm_clear_apply(&tracks_syndrm[track_idx], lanes, 0, SYNDRM_STEPS, false, true);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_clear_params_all_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let start = page * SYNDRM_PAGE_SIZE;
            syndrm_clear_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                start,
                SYNDRM_PAGE_SIZE,
                false,
                true,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_clear_params_all_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            syndrm_clear_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                0,
                SYNDRM_STEPS,
                false,
                true,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_clear_both_lane_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            let start = page * SYNDRM_PAGE_SIZE;
            syndrm_clear_apply(&tracks_syndrm[track_idx], lanes, start, SYNDRM_PAGE_SIZE, true, true);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_clear_both_lane_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            syndrm_clear_apply(&tracks_syndrm[track_idx], lanes, 0, SYNDRM_STEPS, true, true);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_clear_both_all_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let start = page * SYNDRM_PAGE_SIZE;
            syndrm_clear_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                start,
                SYNDRM_PAGE_SIZE,
                true,
                true,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_clear_both_all_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            syndrm_clear_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                0,
                SYNDRM_STEPS,
                true,
                true,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_copy_steps_lane_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            let start = page * SYNDRM_PAGE_SIZE;
            syndrm_copy_apply(&tracks_syndrm[track_idx], lanes, start, SYNDRM_PAGE_SIZE, true, false, true);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_copy_steps_lane_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            syndrm_copy_apply(&tracks_syndrm[track_idx], lanes, 0, SYNDRM_STEPS, true, false, false);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_copy_steps_all_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let start = page * SYNDRM_PAGE_SIZE;
            syndrm_copy_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                start,
                SYNDRM_PAGE_SIZE,
                true,
                false,
                true,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_copy_steps_all_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            syndrm_copy_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                0,
                SYNDRM_STEPS,
                true,
                false,
                false,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_copy_params_lane_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            let start = page * SYNDRM_PAGE_SIZE;
            syndrm_copy_apply(&tracks_syndrm[track_idx], lanes, start, SYNDRM_PAGE_SIZE, false, true, true);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_copy_params_lane_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            syndrm_copy_apply(&tracks_syndrm[track_idx], lanes, 0, SYNDRM_STEPS, false, true, false);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_copy_params_all_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let start = page * SYNDRM_PAGE_SIZE;
            syndrm_copy_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                start,
                SYNDRM_PAGE_SIZE,
                false,
                true,
                true,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_copy_params_all_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            syndrm_copy_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                0,
                SYNDRM_STEPS,
                false,
                true,
                false,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_copy_both_lane_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            let start = page * SYNDRM_PAGE_SIZE;
            syndrm_copy_apply(&tracks_syndrm[track_idx], lanes, start, SYNDRM_PAGE_SIZE, true, true, true);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_copy_both_lane_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            let lanes = syndrm_lane_mask(lane);
            syndrm_copy_apply(&tracks_syndrm[track_idx], lanes, 0, SYNDRM_STEPS, true, true, false);
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_copy_both_all_page(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let start = page * SYNDRM_PAGE_SIZE;
            syndrm_copy_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                start,
                SYNDRM_PAGE_SIZE,
                true,
                true,
                true,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_copy_both_all_all(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            syndrm_copy_apply(
                &tracks_syndrm[track_idx],
                syndrm_all_lanes_mask(),
                0,
                SYNDRM_STEPS,
                true,
                true,
                false,
            );
        }
    });

    let tracks_syndrm = Arc::clone(tracks);
    let params_syndrm = Arc::clone(params);
    ui.on_syndrm_paste(move || {
        let track_idx = params_syndrm.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_syndrm[track_idx].syndrm_page.load(Ordering::Relaxed) as usize;
            let lane = tracks_syndrm[track_idx].syndrm_edit_lane.load(Ordering::Relaxed);
            syndrm_paste_apply(&tracks_syndrm[track_idx], lane, page);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_car_wave_changed(move |index| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_car_wave
                .store(index as u32, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_car_freq_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_car_freq
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_car_detune_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_car_detune
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_mod_wave_changed(move |index| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_mod_wave
                .store(index as u32, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_mod_mode_changed(move |index| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_mod_mode
                .store(index as u32, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_mod_value_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_mod_value
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_mod_detune_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_mod_detune
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_index_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_index
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_feedback_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_feedback
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_drive_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_drive
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_out_level_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_out_level
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_amp_attack_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_amp_attack
                .store(value.clamp(0.0, 127.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_amp_decay_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_amp_decay
                .store(value.clamp(0.0, 127.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_amp_sustain_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_amp_sustain
                .store(value.clamp(0.0, 127.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_amp_release_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_amp_release
                .store(value.clamp(0.0, 127.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_prob_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let normalized = (value / 100.0).clamp(0.0, 1.0);
            tracks_fmmi[track_idx]
                .fmmi_prob
                .store(normalized.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_poly_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_poly_enabled
                .store(value, Ordering::Relaxed);
            if value {
                tracks_fmmi[track_idx]
                    .fmmi_gate_stage
                    .store(0, Ordering::Relaxed);
                tracks_fmmi[track_idx]
                    .fmmi_gate_pos
                    .store(0, Ordering::Relaxed);
                tracks_fmmi[track_idx]
                    .fmmi_gate_level
                    .store(0.0f32.to_bits(), Ordering::Relaxed);
                tracks_fmmi[track_idx]
                    .fmmi_gate_hold
                    .store(0, Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_page_changed(move |page| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_page
                .store(page as u32, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_edit_step_changed(move |step| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_edit_step
                .store(step as u32, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_sequencer_grid_toggled(move |step| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step_idx = step as usize;
            if step_idx < FMMI_STEPS {
                let current =
                    tracks_fmmi[track_idx].fmmi_sequencer_grid[step_idx].load(Ordering::Relaxed);
                tracks_fmmi[track_idx]
                    .fmmi_sequencer_grid[step_idx]
                    .store(!current, Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_randomize(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let mut rng_state = tracks_fmmi[track_idx].fmmi_rng_state.load(Ordering::Relaxed);
            fmmi_randomize_global(&tracks_fmmi[track_idx], &mut rng_state);
            tracks_fmmi[track_idx]
                .fmmi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_reset_pattern(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            fmmi_reset_pattern(&tracks_fmmi[track_idx]);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_randomize_pattern(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let mut rng_state = tracks_fmmi[track_idx].fmmi_rng_state.load(Ordering::Relaxed);
            fmmi_randomize_pattern(&tracks_fmmi[track_idx], &mut rng_state);
            tracks_fmmi[track_idx]
                .fmmi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_clear_page(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_fmmi[track_idx].fmmi_page.load(Ordering::Relaxed) as usize;
            fmmi_clear_page(&tracks_fmmi[track_idx], page);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_clear_seq(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            fmmi_clear_sequence(&tracks_fmmi[track_idx]);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_randomize_steps_page(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_fmmi[track_idx].fmmi_page.load(Ordering::Relaxed) as usize;
            let mut rng_state = tracks_fmmi[track_idx].fmmi_rng_state.load(Ordering::Relaxed);
            fmmi_randomize_steps_page(&tracks_fmmi[track_idx], page, &mut rng_state);
            tracks_fmmi[track_idx]
                .fmmi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_randomize_steps_all(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let mut rng_state = tracks_fmmi[track_idx].fmmi_rng_state.load(Ordering::Relaxed);
            fmmi_randomize_pattern(&tracks_fmmi[track_idx], &mut rng_state);
            tracks_fmmi[track_idx]
                .fmmi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_randomize_params_page(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_fmmi[track_idx].fmmi_page.load(Ordering::Relaxed) as usize;
            let mut rng_state = tracks_fmmi[track_idx].fmmi_rng_state.load(Ordering::Relaxed);
            let mod_mode = tracks_fmmi[track_idx].fmmi_mod_mode.load(Ordering::Relaxed);
            fmmi_randomize_page_params(&tracks_fmmi[track_idx], page, mod_mode, &mut rng_state);
            tracks_fmmi[track_idx]
                .fmmi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_randomize_params_all(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let mut rng_state = tracks_fmmi[track_idx].fmmi_rng_state.load(Ordering::Relaxed);
            let mod_mode = tracks_fmmi[track_idx].fmmi_mod_mode.load(Ordering::Relaxed);
            fmmi_randomize_all_params(&tracks_fmmi[track_idx], mod_mode, &mut rng_state);
            tracks_fmmi[track_idx]
                .fmmi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_randomize_both_page(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_fmmi[track_idx].fmmi_page.load(Ordering::Relaxed) as usize;
            let mut rng_state = tracks_fmmi[track_idx].fmmi_rng_state.load(Ordering::Relaxed);
            let mod_mode = tracks_fmmi[track_idx].fmmi_mod_mode.load(Ordering::Relaxed);
            fmmi_randomize_steps_page(&tracks_fmmi[track_idx], page, &mut rng_state);
            fmmi_randomize_page_params(&tracks_fmmi[track_idx], page, mod_mode, &mut rng_state);
            tracks_fmmi[track_idx]
                .fmmi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_randomize_both_all(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let mut rng_state = tracks_fmmi[track_idx].fmmi_rng_state.load(Ordering::Relaxed);
            let mod_mode = tracks_fmmi[track_idx].fmmi_mod_mode.load(Ordering::Relaxed);
            fmmi_randomize_pattern(&tracks_fmmi[track_idx], &mut rng_state);
            fmmi_randomize_all_params(&tracks_fmmi[track_idx], mod_mode, &mut rng_state);
            tracks_fmmi[track_idx]
                .fmmi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_clear_steps_page(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_fmmi[track_idx].fmmi_page.load(Ordering::Relaxed) as usize;
            fmmi_clear_steps_page(&tracks_fmmi[track_idx], page);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_clear_steps_all(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            fmmi_clear_steps_all(&tracks_fmmi[track_idx]);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_clear_params_page(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_fmmi[track_idx].fmmi_page.load(Ordering::Relaxed) as usize;
            fmmi_clear_params_page(&tracks_fmmi[track_idx], page);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_clear_params_all(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            fmmi_clear_params_all(&tracks_fmmi[track_idx]);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_clear_both_page(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_fmmi[track_idx].fmmi_page.load(Ordering::Relaxed) as usize;
            fmmi_clear_page(&tracks_fmmi[track_idx], page);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_clear_both_all(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            fmmi_clear_sequence(&tracks_fmmi[track_idx]);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_copy_steps_page(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_fmmi[track_idx].fmmi_page.load(Ordering::Relaxed) as usize;
            fmmi_copy_apply(
                &tracks_fmmi[track_idx],
                page * FMMI_PAGE_SIZE,
                FMMI_PAGE_SIZE,
                true,
                false,
                true,
            );
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_copy_steps_all(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            fmmi_copy_apply(&tracks_fmmi[track_idx], 0, FMMI_STEPS, true, false, false);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_copy_params_page(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_fmmi[track_idx].fmmi_page.load(Ordering::Relaxed) as usize;
            fmmi_copy_apply(
                &tracks_fmmi[track_idx],
                page * FMMI_PAGE_SIZE,
                FMMI_PAGE_SIZE,
                false,
                true,
                true,
            );
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_copy_params_all(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            fmmi_copy_apply(&tracks_fmmi[track_idx], 0, FMMI_STEPS, false, true, false);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_copy_both_page(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_fmmi[track_idx].fmmi_page.load(Ordering::Relaxed) as usize;
            fmmi_copy_apply(
                &tracks_fmmi[track_idx],
                page * FMMI_PAGE_SIZE,
                FMMI_PAGE_SIZE,
                true,
                true,
                true,
            );
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_copy_both_all(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            fmmi_copy_apply(&tracks_fmmi[track_idx], 0, FMMI_STEPS, true, true, false);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_paste(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_fmmi[track_idx].fmmi_page.load(Ordering::Relaxed) as usize;
            fmmi_paste_apply(&tracks_fmmi[track_idx], page);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_note_index_changed(move |index| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                let midi = fmmi_note_index_to_midi(index);
                tracks_fmmi[track_idx]
                    .fmmi_step_note[step]
                    .store(midi, Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_car_wave_changed(move |index| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                let wave = if index <= 0 { -1 } else { (index - 1).clamp(0, 3) };
                tracks_fmmi[track_idx]
                    .fmmi_step_car_wave[step]
                    .store(wave, Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_mod_wave_changed(move |index| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                let wave = if index <= 0 { -1 } else { (index - 1).clamp(0, 3) };
                tracks_fmmi[track_idx]
                    .fmmi_step_mod_wave[step]
                    .store(wave, Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_mod_mode_changed(move |index| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                let mode = if index <= 0 { -1 } else { (index - 1).clamp(0, 1) };
                tracks_fmmi[track_idx]
                    .fmmi_step_mod_mode[step]
                    .store(mode, Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_car_freq_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                tracks_fmmi[track_idx]
                    .fmmi_step_car_freq[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_car_detune_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                tracks_fmmi[track_idx]
                    .fmmi_step_car_detune[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_mod_value_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                tracks_fmmi[track_idx]
                    .fmmi_step_mod_value[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_mod_detune_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                tracks_fmmi[track_idx]
                    .fmmi_step_mod_detune[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_index_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                tracks_fmmi[track_idx]
                    .fmmi_step_index[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_feedback_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                tracks_fmmi[track_idx]
                    .fmmi_step_feedback[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_drive_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                tracks_fmmi[track_idx]
                    .fmmi_step_drive[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_out_level_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                tracks_fmmi[track_idx]
                    .fmmi_step_out_level[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_amp_attack_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                tracks_fmmi[track_idx]
                    .fmmi_step_amp_attack[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_amp_decay_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                tracks_fmmi[track_idx]
                    .fmmi_step_amp_decay[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_amp_sustain_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                tracks_fmmi[track_idx]
                    .fmmi_step_amp_sustain[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_amp_release_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                tracks_fmmi[track_idx]
                    .fmmi_step_amp_release[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_step_gate_length_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            if step < FMMI_STEPS {
                let clamped = value.max(0.0);
                tracks_fmmi[track_idx]
                    .fmmi_step_gate_length[step]
                    .store(clamped.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_note_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_note_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_car_wave_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_car_wave_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_mod_wave_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_mod_wave_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_mod_mode_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_mod_mode_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_car_freq_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_car_freq_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_car_detune_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_car_detune_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_mod_value_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_mod_value_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_mod_detune_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_mod_detune_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_index_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_index_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_feedback_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_feedback_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_drive_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_drive_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_out_level_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_out_level_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_amp_attack_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_amp_attack_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_amp_decay_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_amp_decay_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_amp_sustain_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_amp_sustain_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_amp_release_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_amp_release_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_gate_length_enabled_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_fmmi[track_idx]
                .fmmi_rand_gate_length_enabled
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_randomize_amount_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.clamp(0.0, 1.0);
            tracks_fmmi[track_idx]
                .fmmi_randomize_amount
                .store(clamped.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_randomize_steps_amount_changed(move |value| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.clamp(0.0, 1.0);
            tracks_fmmi[track_idx]
                .fmmi_randomize_steps_amount
                .store(clamped.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_scale_selected(move |index| {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let scales = fmmi_scales();
            let clamped = if scales.is_empty() {
                0
            } else {
                index.max(0).min((scales.len() - 1) as i32) as u32
            };
            tracks_fmmi[track_idx]
                .fmmi_scale_index
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_step_params(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_fmmi[track_idx].fmmi_edit_step.load(Ordering::Relaxed) as usize;
            let mut rng_state = tracks_fmmi[track_idx].fmmi_rng_state.load(Ordering::Relaxed);
            let mod_mode = tracks_fmmi[track_idx].fmmi_mod_mode.load(Ordering::Relaxed);
            fmmi_randomize_step_params(&tracks_fmmi[track_idx], step, mod_mode, &mut rng_state);
            tracks_fmmi[track_idx]
                .fmmi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_page_params(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_fmmi[track_idx].fmmi_page.load(Ordering::Relaxed) as usize;
            let mut rng_state = tracks_fmmi[track_idx].fmmi_rng_state.load(Ordering::Relaxed);
            let mod_mode = tracks_fmmi[track_idx].fmmi_mod_mode.load(Ordering::Relaxed);
            fmmi_randomize_page_params(&tracks_fmmi[track_idx], page, mod_mode, &mut rng_state);
            tracks_fmmi[track_idx]
                .fmmi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_fmmi = Arc::clone(tracks);
    let params_fmmi = Arc::clone(params);
    ui.on_fmmi_rand_all_params(move || {
        let track_idx = params_fmmi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let mut rng_state = tracks_fmmi[track_idx].fmmi_rng_state.load(Ordering::Relaxed);
            let mod_mode = tracks_fmmi[track_idx].fmmi_mod_mode.load(Ordering::Relaxed);
            fmmi_randomize_all_params(&tracks_fmmi[track_idx], mod_mode, &mut rng_state);
            tracks_fmmi[track_idx]
                .fmmi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_osc_wave_changed(move |index, value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let idx = index.clamp(0, 2) as usize;
            tracks_monomi[track_idx]
                .monomi_osc_wave[idx]
                .store(value.max(0) as u32, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_osc_octave_changed(move |index, value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let idx = index.clamp(0, 2) as usize;
            tracks_monomi[track_idx]
                .monomi_osc_octave[idx]
                .store(value.clamp(0, 2) as u32, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_osc_detune_changed(move |index, value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let idx = index.clamp(0, 2) as usize;
            tracks_monomi[track_idx]
                .monomi_osc_detune[idx]
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_osc_mix_changed(move |index, value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let idx = index.clamp(0, 2) as usize;
            tracks_monomi[track_idx]
                .monomi_osc_mix[idx]
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_osc_pwm_changed(move |index, value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let idx = index.clamp(0, 2) as usize;
            tracks_monomi[track_idx]
                .monomi_osc_pwm[idx]
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_cutoff_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_cutoff
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_resonance_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let filter_mode = tracks_monomi[track_idx].monomi_filter_mode.load(Ordering::Relaxed);
            let value = value.clamp(0.0, if filter_mode == 0 { 1.0 } else { 8.0 });
            tracks_monomi[track_idx]
                .monomi_resonance
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_filter_morph_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_filter_morph
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_filter_mode_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_filter_mode
                .store(value.clamp(0, 2) as u32, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_volume_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_volume
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_amp_attack_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_amp_attack
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_amp_decay_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_amp_decay
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_amp_sustain_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_amp_sustain
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_amp_release_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_amp_release
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_filter_attack_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_filter_attack
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_filter_decay_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_filter_decay
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_filter_sustain_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_filter_sustain
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_filter_release_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_filter_release
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_filter_intensity_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_filter_intensity
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_filter_polarity_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_filter_polarity
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_filter_saturation_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_filter_saturation
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_filter_sat_env_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_filter_sat_env
                .store(value.clamp(0.0, 1.0).to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_filter_sat_pre_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_filter_sat_pre
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_mix_comp_mode_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_mix_comp_mode
                .store(value.max(0) as u32, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_glide_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_glide
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_prob_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let prob = (value / 100.0).clamp(0.0, 1.0);
            tracks_monomi[track_idx]
                .monomi_prob
                .store(prob.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_lfo_shape_changed(move |index, value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let idx = index.clamp(0, 2) as usize;
            tracks_monomi[track_idx]
                .monomi_lfo_shape[idx]
                .store(value.max(0) as u32, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_lfo_target_changed(move |index, value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let idx = index.clamp(0, 2) as usize;
            let clamped = value.max(0) as u32;
            tracks_monomi[track_idx]
                .monomi_lfo_target[idx]
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_lfo_amount_changed(move |index, value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let idx = index.clamp(0, 2) as usize;
            tracks_monomi[track_idx]
                .monomi_lfo_amount[idx]
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_lfo_rate_changed(move |index, value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let idx = index.clamp(0, 2) as usize;
            tracks_monomi[track_idx]
                .monomi_lfo_rate[idx]
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_lfo_sync_changed(move |index, value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let idx = index.clamp(0, 2) as usize;
            tracks_monomi[track_idx]
                .monomi_lfo_sync[idx]
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_lfo_steps_changed(move |index, value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let idx = index.clamp(0, 2) as usize;
            tracks_monomi[track_idx]
                .monomi_lfo_steps[idx]
                .store(value.max(1) as u32, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_page_changed(move |page| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = page.max(0).min((MONOMI_PAGES - 1) as i32) as u32;
            tracks_monomi[track_idx]
                .monomi_page
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_edit_step_changed(move |step| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = step.max(0).min((MONOMI_STEPS - 1) as i32) as u32;
            tracks_monomi[track_idx]
                .monomi_edit_step
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_sequencer_grid_toggled(move |step| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step_idx = step as usize;
            if step_idx < MONOMI_STEPS {
                let current =
                    tracks_monomi[track_idx].monomi_sequencer_grid[step_idx].load(Ordering::Relaxed);
                tracks_monomi[track_idx]
                    .monomi_sequencer_grid[step_idx]
                    .store(!current, Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_scale_selected(move |index| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let scales = fmmi_scales();
            let clamped = if scales.is_empty() {
                0
            } else {
                index.max(0).min((scales.len() - 1) as i32) as u32
            };
            tracks_monomi[track_idx]
                .monomi_scale_index
                .store(clamped, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_note_index_changed(move |index| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                let note = if index <= 0 {
                    -1
                } else {
                    (MONOMI_NOTE_BASE + (index - 1)) as i32
                };
                tracks_monomi[track_idx]
                    .monomi_step_note[step]
                    .store(note, Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_cutoff_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_cutoff[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_resonance_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                let filter_mode = tracks_monomi[track_idx].monomi_filter_mode.load(Ordering::Relaxed);
                let value = value.clamp(0.0, if filter_mode == 0 { 1.0 } else { 8.0 });
                tracks_monomi[track_idx].monomi_step_resonance[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_env_attack_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_env_attack[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_env_decay_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_env_decay[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_env_sustain_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_env_sustain[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_env_release_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_env_release[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_gate_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_gate[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_filter_morph_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_filter_morph[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_glide_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_glide[step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_osc1_mix_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_osc_mix[0][step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_osc2_mix_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_osc_mix[1][step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_osc3_mix_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_osc_mix[2][step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_osc1_detune_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_osc_detune[0][step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_osc2_detune_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_osc_detune[1][step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_osc3_detune_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_osc_detune[2][step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_osc1_pwm_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_osc_pwm[0][step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_osc2_pwm_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_osc_pwm[1][step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_step_osc3_pwm_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            if step < MONOMI_STEPS {
                tracks_monomi[track_idx].monomi_step_osc_pwm[2][step]
                    .store(value.to_bits(), Ordering::Relaxed);
            }
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_cutoff_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_cutoff
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_resonance_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_resonance
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_env_attack_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_env_attack
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_env_decay_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_env_decay
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_env_sustain_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_env_sustain
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_env_release_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_env_release
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_gate_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_gate
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_filter_morph_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_filter_morph
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_glide_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_glide
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_osc1_mix_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_osc_mix[0]
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_osc2_mix_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_osc_mix[1]
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_osc3_mix_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_osc_mix[2]
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_osc1_detune_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_osc_detune[0]
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_osc2_detune_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_osc_detune[1]
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_osc3_detune_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_osc_detune[2]
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_osc1_pwm_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_osc_pwm[0]
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_osc2_pwm_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_osc_pwm[1]
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_rand_osc3_pwm_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_monomi[track_idx]
                .monomi_rand_osc_pwm[2]
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_randomize_amount_changed(move |value| {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let clamped = value.clamp(0.0, 1.0);
            tracks_monomi[track_idx]
                .monomi_randomize_amount
                .store(clamped.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_randomize_notes_step(move || {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            let mut rng_state = tracks_monomi[track_idx].monomi_rng_state.load(Ordering::Relaxed);
            monomi_randomize_notes_step(&tracks_monomi[track_idx], step, &mut rng_state);
            tracks_monomi[track_idx]
                .monomi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_randomize_notes_page(move || {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_monomi[track_idx].monomi_page.load(Ordering::Relaxed) as usize;
            let mut rng_state = tracks_monomi[track_idx].monomi_rng_state.load(Ordering::Relaxed);
            monomi_randomize_notes_page(&tracks_monomi[track_idx], page, &mut rng_state);
            tracks_monomi[track_idx]
                .monomi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_randomize_notes_all(move || {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let mut rng_state = tracks_monomi[track_idx].monomi_rng_state.load(Ordering::Relaxed);
            monomi_randomize_notes_all(&tracks_monomi[track_idx], &mut rng_state);
            tracks_monomi[track_idx]
                .monomi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_reset_notes(move || {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            monomi_reset_notes(&tracks_monomi[track_idx]);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_randomize_params_step(move || {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let step = tracks_monomi[track_idx].monomi_edit_step.load(Ordering::Relaxed) as usize;
            let mut rng_state = tracks_monomi[track_idx].monomi_rng_state.load(Ordering::Relaxed);
            monomi_randomize_params_step(&tracks_monomi[track_idx], step, &mut rng_state);
            tracks_monomi[track_idx]
                .monomi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_randomize_params_page(move || {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let page = tracks_monomi[track_idx].monomi_page.load(Ordering::Relaxed) as usize;
            let mut rng_state = tracks_monomi[track_idx].monomi_rng_state.load(Ordering::Relaxed);
            monomi_randomize_params_page(&tracks_monomi[track_idx], page, &mut rng_state);
            tracks_monomi[track_idx]
                .monomi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_randomize_params_all(move || {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let mut rng_state = tracks_monomi[track_idx].monomi_rng_state.load(Ordering::Relaxed);
            monomi_randomize_params_all(&tracks_monomi[track_idx], &mut rng_state);
            tracks_monomi[track_idx]
                .monomi_rng_state
                .store(rng_state, Ordering::Relaxed);
        }
    });

    let tracks_monomi = Arc::clone(tracks);
    let params_monomi = Arc::clone(params);
    ui.on_monomi_reset_params(move || {
        let track_idx = params_monomi.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            monomi_reset_params(&tracks_monomi[track_idx]);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_base_freq_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_base_freq
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_chaos_depth_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_chaos_depth
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_entropy_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_entropy
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_pan_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_pan
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_width_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_width
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_close_decay_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_close_decay
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_filter_cutoff_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_filter_cutoff
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_filter_resonance_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_filter_resonance
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_drive_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_drive
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_filter_pre_drive_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_filter_pre_drive
                .store(value, Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_feedback_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_feedback
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_diffusion_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_diffusion
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_mod_rate_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_mod_rate
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_void_level_changed(move |value| {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            tracks_void[track_idx]
                .void_level
                .store(value.to_bits(), Ordering::Relaxed);
        }
    });

    let tracks_void = Arc::clone(tracks);
    let params_void = Arc::clone(params);
    ui.on_toggle_void(move || {
        let track_idx = params_void.selected_track.value().saturating_sub(1) as usize;
        if track_idx < NUM_TRACKS {
            let current = tracks_void[track_idx].void_enabled.load(Ordering::Relaxed);
            tracks_void[track_idx].void_enabled.store(!current, Ordering::Relaxed);
        }
    });

    refresh_browser_impl(ui, &current_path.lock(), current_folder_content_model);
}

#[derive(Clone)]
enum ProjectDialogAction {
    Save(PathBuf),
    Load(PathBuf),
    SaveWithInfo {
        path: PathBuf,
        title: String,
        description: String,
    },
    ExportZip {
        path: PathBuf,
        title: String,
        description: String,
    },
}

#[derive(Clone)]
enum SampleDialogAction {
    Load { track_idx: usize, path: Option<PathBuf> },
    Save { track_idx: usize, path: PathBuf },
    LoadSyndrmSample {
        track_idx: usize,
        channel_idx: usize,
        path: Option<PathBuf>,
    },
}

struct SlintPlatform {
    start_time: Instant,
}

impl Platform for SlintPlatform {
    fn create_window_adapter(
        &self,
    ) -> Result<std::rc::Rc<dyn slint::platform::WindowAdapter>, PlatformError> {
        let window = MinimalSoftwareWindow::new(RepaintBufferType::ReusedBuffer);
        SLINT_WINDOW_SLOT.with(|slot| {
            *slot.borrow_mut() = Some(window.clone());
        });
        Ok(window)
    }

    fn duration_since_start(&self) -> std::time::Duration {
        self.start_time.elapsed()
    }
}

fn ensure_slint_platform() {
    static SET_PLATFORM: Once = Once::new();
    SET_PLATFORM.call_once(|| {
        let _ = platform::set_platform(Box::new(SlintPlatform {
            start_time: Instant::now(),
        }));
    });
}

fn create_slint_ui() -> (std::rc::Rc<MinimalSoftwareWindow>, Box<TLBX1UI>) {
    SLINT_WINDOW_SLOT.with(|slot| {
        *slot.borrow_mut() = None;
    });
    let ui = Box::new(TLBX1UI::new().expect("Failed to create Slint UI"));
    let window = SLINT_WINDOW_SLOT.with(|slot| {
        slot.borrow_mut()
            .take()
            .expect("Slint window adapter not created")
    });
    (window, ui)
}

thread_local! {
    static SLINT_WINDOW_SLOT: RefCell<Option<std::rc::Rc<MinimalSoftwareWindow>>> =
        RefCell::new(None);
}

/// This version of `baseview` uses a different version of `raw_window_handle than NIH-plug, so we
/// need to adapt it ourselves.
struct ParentWindowHandleAdapter(nih_plug::editor::ParentWindowHandle);

unsafe impl HasRawWindowHandle for ParentWindowHandleAdapter {
    fn raw_window_handle(&self) -> RawWindowHandle {
        match self.0 {
            ParentWindowHandle::X11Window(window) => {
                let mut handle = raw_window_handle::XcbWindowHandle::empty();
                handle.window = window;
                RawWindowHandle::Xcb(handle)
            }
            ParentWindowHandle::AppKitNsView(ns_view) => {
                let mut handle = raw_window_handle::AppKitWindowHandle::empty();
                handle.ns_view = ns_view;
                RawWindowHandle::AppKit(handle)
            }
            ParentWindowHandle::Win32Hwnd(hwnd) => {
                let mut handle = raw_window_handle::Win32WindowHandle::empty();
                handle.hwnd = hwnd;
                RawWindowHandle::Win32(handle)
            }
        }
    }
}

/// Softbuffer uses raw_window_handle v6, but baseview uses raw_window_handle v5, so we need to
/// adapt it ourselves.
#[derive(Clone)]
struct SoftbufferWindowHandleAdapter {
    raw_display_handle: raw_window_handle_06::RawDisplayHandle,
    raw_window_handle: raw_window_handle_06::RawWindowHandle,
}

impl raw_window_handle_06::HasDisplayHandle for SoftbufferWindowHandleAdapter {
    fn display_handle(
        &self,
    ) -> Result<raw_window_handle_06::DisplayHandle<'_>, raw_window_handle_06::HandleError> {
        unsafe {
            Ok(raw_window_handle_06::DisplayHandle::borrow_raw(
                self.raw_display_handle,
            ))
        }
    }
}

impl raw_window_handle_06::HasWindowHandle for SoftbufferWindowHandleAdapter {
    fn window_handle(
        &self,
    ) -> Result<raw_window_handle_06::WindowHandle<'_>, raw_window_handle_06::HandleError> {
        unsafe {
            Ok(raw_window_handle_06::WindowHandle::borrow_raw(
                self.raw_window_handle,
            ))
        }
    }
}

fn baseview_window_to_surface_target(
    window: &baseview::Window<'_>,
) -> SoftbufferWindowHandleAdapter {
    use raw_window_handle::{HasRawDisplayHandle, HasRawWindowHandle};

    let raw_display_handle = window.raw_display_handle();
    let raw_window_handle = window.raw_window_handle();

    SoftbufferWindowHandleAdapter {
        raw_display_handle: match raw_display_handle {
            raw_window_handle::RawDisplayHandle::AppKit(_) => {
                raw_window_handle_06::RawDisplayHandle::AppKit(
                    raw_window_handle_06::AppKitDisplayHandle::new(),
                )
            }
            raw_window_handle::RawDisplayHandle::Xlib(handle) => {
                raw_window_handle_06::RawDisplayHandle::Xlib(
                    raw_window_handle_06::XlibDisplayHandle::new(
                        std::ptr::NonNull::new(handle.display),
                        handle.screen,
                    ),
                )
            }
            raw_window_handle::RawDisplayHandle::Xcb(handle) => {
                raw_window_handle_06::RawDisplayHandle::Xcb(
                    raw_window_handle_06::XcbDisplayHandle::new(
                        std::ptr::NonNull::new(handle.connection),
                        handle.screen,
                    ),
                )
            }
            raw_window_handle::RawDisplayHandle::Windows(_) => {
                raw_window_handle_06::RawDisplayHandle::Windows(
                    raw_window_handle_06::WindowsDisplayHandle::new(),
                )
            }
            _ => todo!(),
        },
        raw_window_handle: match raw_window_handle {
            raw_window_handle::RawWindowHandle::AppKit(handle) => {
                raw_window_handle_06::RawWindowHandle::AppKit(
                    raw_window_handle_06::AppKitWindowHandle::new(
                        std::ptr::NonNull::new(handle.ns_view).unwrap(),
                    ),
                )
            }
            raw_window_handle::RawWindowHandle::Xlib(handle) => {
                raw_window_handle_06::RawWindowHandle::Xlib(
                    raw_window_handle_06::XlibWindowHandle::new(handle.window),
                )
            }
            raw_window_handle::RawWindowHandle::Xcb(handle) => {
                raw_window_handle_06::RawWindowHandle::Xcb(
                    raw_window_handle_06::XcbWindowHandle::new(
                        std::num::NonZeroU32::new(handle.window).unwrap(),
                    ),
                )
            }
            raw_window_handle::RawWindowHandle::Win32(handle) => {
                let mut raw_handle = raw_window_handle_06::Win32WindowHandle::new(
                    std::num::NonZeroIsize::new(handle.hwnd as isize).unwrap(),
                );

                raw_handle.hinstance = std::num::NonZeroIsize::new(handle.hinstance as isize);

                raw_window_handle_06::RawWindowHandle::Win32(raw_handle)
            }
            _ => todo!(),
        },
    }
}

fn key_to_slint_string(key: &Key) -> Option<String> {
    match key {
        Key::Character(c) => Some(c.clone()),
        Key::Escape => Some("\u{001b}".to_string()),
        Key::Enter => Some("\r".to_string()),
        Key::Backspace => Some("\u{0008}".to_string()),
        Key::Tab => Some("\t".to_string()),
        Key::ArrowUp => Some("\u{f000}".to_string()),
        Key::ArrowDown => Some("\u{f001}".to_string()),
        Key::ArrowLeft => Some("\u{f002}".to_string()),
        Key::ArrowRight => Some("\u{f003}".to_string()),
        Key::Delete => Some("\u{007f}".to_string()),
        _ => None,
    }
}

fn map_mouse_button(button: baseview::MouseButton) -> Option<PointerEventButton> {
    match button {
        baseview::MouseButton::Left => Some(PointerEventButton::Left),
        baseview::MouseButton::Right => Some(PointerEventButton::Right),
        baseview::MouseButton::Middle => Some(PointerEventButton::Middle),
        _ => Some(PointerEventButton::Other),
    }
}

impl Vst3Plugin for TLBX1 {
    const VST3_CLASS_ID: [u8; 16] = *b"TLBX1Zencode____";
    const VST3_SUBCATEGORIES: &'static [Vst3SubCategory] =
        &[Vst3SubCategory::Instrument, Vst3SubCategory::Sampler];
}

impl ClapPlugin for TLBX1 {
    const CLAP_ID: &'static str = "com.zencoder.tlbx-1";
    const CLAP_DESCRIPTION: Option<&'static str> = Some("An audio toolbox plugin");
    const CLAP_MANUAL_URL: Option<&'static str> = None;
    const CLAP_SUPPORT_URL: Option<&'static str> = None;
    const CLAP_FEATURES: &'static [ClapFeature] = &[ClapFeature::Instrument, ClapFeature::Sampler, ClapFeature::Stereo];
}

nih_export_vst3!(TLBX1);
nih_export_clap!(TLBX1);

fn current_arg_value(flag: &str) -> Option<String> {
    let mut args = std::env::args();
    while let Some(arg) = args.next() {
        if arg == flag {
            return args.next();
        }
    }
    None
}

fn available_output_devices() -> Vec<String> {
    let host = {
        #[cfg(target_os = "windows")]
        {
            cpal::host_from_id(cpal::HostId::Wasapi).unwrap_or_else(|_| cpal::default_host())
        }
        #[cfg(not(target_os = "windows"))]
        {
            cpal::default_host()
        }
    };

    match host.output_devices() {
        Ok(devices) => devices.filter_map(|device| device.name().ok()).collect(),
        Err(_) => Vec::new(),
    }
}

fn available_input_devices() -> Vec<String> {
    let host = {
        #[cfg(target_os = "windows")]
        {
            cpal::host_from_id(cpal::HostId::Wasapi).unwrap_or_else(|_| cpal::default_host())
        }
        #[cfg(not(target_os = "windows"))]
        {
            cpal::default_host()
        }
    };

    match host.input_devices() {
        Ok(devices) => devices.filter_map(|device| device.name().ok()).collect(),
        Err(_) => Vec::new(),
    }
}

fn restart_with_audio_settings(
    output_device: Option<&String>,
    input_device: Option<&String>,
    sample_rate: Option<u32>,
    buffer_size: Option<u32>,
) -> Result<(), String> {
    let exe = std::env::current_exe().map_err(|err| err.to_string())?;
    let mut cmd = ProcessCommand::new(exe);

    if let Some(device) = output_device {
        cmd.arg("--output-device").arg(device);
    }
    if let Some(device) = input_device {
        cmd.arg("--input-device").arg(device);
    }
    if let Some(rate) = sample_rate {
        cmd.arg("--sample-rate").arg(rate.to_string());
    }
    if let Some(size) = buffer_size {
        cmd.arg("--period-size").arg(size.to_string());
    }

    cmd.spawn().map_err(|err| err.to_string())?;
    std::process::exit(0);
}
